% -----------------------------------------------------------------------------
% Xic Manual
% (C) Copyright 2009, Whiteley Research Inc., Sunnyvale CA
% $Id: drc.tex,v 1.37 2017/03/22 22:27:01 stevew Exp $
% -----------------------------------------------------------------------------

% -----------------------------------------------------------------------------
% xic:drcmenu 091509
\chapter{The DRC Menu:  Design Rule Checking}

The {\cb DRC Menu} contains commands which control checking of design
rules.  The menu is accessible only in physical mode, and design rule
checking can only be applied in physical mode.  {\Xic} has the
capability of checking for design rule violations as any object is
created or modified, and for checking regions and cells interactively
or in batch mode.  The algorithm fully supports non-Manhattan
geometry.  Design rules are provided in the technology file, or
interactively using the {\cb Edit Rules} command.

The table below lists the commands found in the {\cb DRC Menu}, and
supplies the internal command name and a brief description.

\begin{tabular}{|l|l|l|p{2.25in}|} \hline
\multicolumn{4}{|c|}{\kb DRC Menu}\\ \hline
\kb Label & \kb Name & \kb Pop-up & \kb Function\\ \hline\hline
\et Setup & \vt limit & \cb DRC Parameter Setup & Set limits and other
   parameters\\ \hline
\et Set Skip Flags & \vt sflag & none & Set skip flags\\ \hline
\et Enable Interactive & \vt intr & none & Set interactive DRC\\ \hline
\et No Pop Up Errors & \vt nopop & none & No interactive errors list\\ \hline
\et Batch Check & \vt check & \cb DRC Run Control & Initiate DRC run\\ \hline
\et Check In Region & \vt point & none & Test rules in region\\ \hline
\et Clear Errors & \vt clear & none & Erase error indicators\\ \hline
\et Query Errors & \vt query & none & Print error messages\\ \hline
\et Dump Error File & \vt erdmp & none & Dump errors to file\\ \hline
\et Update Highlighting & \vt erupd & none & Update highlighting from file\\
  \hline
\et Show Errors & \vt next & sub-window & Sequentially display errors from
  file\\ \hline
\et Create Layer & \vt erlyr & none & Write highlight error regions to
  objects on layer\\ \hline
\et Edit Rules & \vt dredt & \cb Design Rule Editor & Edit rules for layers\\
 \hline
\end{tabular}

After a check is performed, violating objects are shown on-screen with
the border highlighted, and a highlighting border is drawn around the
test region containing the error.  These objects are {\it not} removed
from the database.  It is up to the user to fix or ignore errors as
they are indicated.

Presently, the indication of a violation is not saved as the cell is
written.

Design rules are specified in the technology file, or with the {\cb
Design Rule Editor} made visible with the {\cb Edit Rules} button in
the {\cb DRC Menu}.  The rules are specified by a keyword, followed by
an optional source region specification, followed by parameters.  In
addition to the built-in rule primitives to be described, a capability
exists for users to define specialized or more complex tests.


% -----------------------------------------------------------------------------
% layer_exp 032217
\section{Layer Expressions}
\label{layerexp}
\index{layer expressions}
\index{design rules!expressions}
Many of the design rules, extraction specifications, and commands make
use of ``layer expressions''.  These expressions are used to signify
regions of the layout where certain combinations of layers (or absence
of layers) exist.  A layer expression consists of a logical
expression, in the format recognized by the script parser used to
evaluate script files.

The expression may contain physical layer and derived layer (see
\ref{drvlyr}) names, functions from the list below, operators from the
table below, numeric constants, and parentheses to enforce precedence. 
In its simplest form, a layer expression is a layer name, which can be
thought of as a list of regions corresponding to the dark areas
(boxes, polygons, and wires) of that layer.  A numeric value of zero
represents emptiness, and a nonzero value represents full coverage.

When a layer expression is evaluated in the {\cb !layer} command or
the {\cb Evaluate Layer Expression} panel, the result is always a
normal layer, thus derived layers can be made visible by this means. 
If the layer expression represents a simple copy, the created physical
layer will take any attributes of the derived layer (color, fill,
etc.) that were given to the derived layer. 

If the names of any defined layers are numeric values, one must be a
little careful when specifying the equivalent numeric value, since a
layer name interpretation will supersede a numeric interpretation. 
For example, in the presence of a layer named ``1'', one could use
``1.0'' to specify the number 1.  A four-digit hex number is always
assumed to be a layer name, even if a layer of that name does not
presently exist.  This is necessary so that when reading the
technology file, layer expressions can reference layers with numerical
names (likely from GDSII conversion) that have not yet been defined.
Layer names in the ``decimal'' format must be double quoted, e.g.,
{\vt "22,0"}.

The layer name token can actually take an extended syntax which
enables extraction of geometry from cells other than the current cell. 

\begin{quote}
{\it lname\/}[{\vt .}{\it stname\/}][{\vt .}{\it cellname\/}]
\end{quote}

See the description of the {\cb !layer} command in \ref{layercmd} for
a description of this syntax and examples.

The following operators are accepted in layer expressions:
       
\begin{tabular}{|l|l|} \hline
\et $\&$ or $*$ & intersection\\ \hline
\et $|$ or $+$  & union\\ \hline
\et $!$  & inversion\\ \hline
\et $\symbol{94}$  & exclusive-or\\ \hline
\et $-$  & and-not, i.e., $A-B = A\&!B$\\ \hline
\vt and  & synonym for $\&$\\ \hline
\vt or   & synonym for $|$\\ \hline
\vt not  & synonym for $!$ or $-$\\ \hline
\vt xor  & synonym for $\symbol{94}$\\ \hline
\end{tabular}

The operator-equivalent keywords ({\vt and}, {\vt or}, {\vt not}, {\vt
xor}) are recognized without case sensitivity.  The {\vt not} keyword
can represent a unary negation or a binary ``andnot'', depending on
the context.  Thus, for layers {\vt A} and {\vt B}, each of the
following are equivalent:  {\vt A not B}, {\vt A $-$ B}, {\vt A $\&!$
B}, {\vt A and not B}.

Parentheses can be used to enforce precedence.

The expression returns an internal data structure representing those
regions of the current cell where the expression is true, i.e., where
the layers exist with the given logic.

There is a special layer named ``\$\$'' which logically consists of
boxes covering each of the subcells in the current cell.

The {\cb !layer} command can create a new layer from a layer
expression, and is therefor a good vehicle for experimenting with
layer expressions.

The tokens are interpreted as they would be in an ordinary expression
involving numbers, thus their precedence might not be quite as
expected in layer expressions.  For example
\begin{quote}
    {\vt !layer CAA = !CAA \& \$\$}
\end{quote}
and
\begin{quote}
    {\vt !layer CAA = !CAA * \$\$}
\end{quote}
are {\it not} equivalent.  The latter expression is equivalent to
\begin{quote}
    {\vt !layer CAA = !(CAA \& \$\$)}
\end{quote}
since `*' has higher precedence than `\&'.  The equivalent expression
is
\begin{quote}
    {\vt !layer CAA = (!CAA) * \$\$}
\end{quote}
(recall that `\$\$' is the name for an internal layer consisting of
subcell bounding boxes).

\index{Layer expressions, functions}
The following function calls are supported in layer expressions.  Only
the functions listed below are available, and all return a layer
expression object.

\begin{description}
\index{sqz layer expression function}
\item{\vt sqz}(layer\_exp {\it expr\/})\\
This is a special function that evaluates the layer expression passed
as an argument, but the geometry for the given layers is obtained from
the selection queue (the currently selected objects), and not the
entire cell as in the normal case.  It can be freely used within a
larger layer expression.

Below are some examples, using the {\cb !layer} command.

\begin{description}
\item{\vt !layer new = sqz(CPG-CAA)}\\
Create a layer ``new'' that will contain the selected objects on CPG
clipped around selected objects on CAA.
\item{\vt !layer new = VIA \& sqz(M2)}\\
Create a layer ``new'' that will contain the areas of VIA that overlap
selected objects on M2.
\item{\vt !layer CPG = CPG - sqz(temp)}\\
Clip out the selected objects on layer temp from CPG.
\end{description}

\item{\vt bloat}(real {\it incr\/}, layer\_exp {\it layer\/},
 int {\it mode\/})\\
\index{bloat layer expression function}
This expands the features on the layer by {\it incr} (in microns),
which may be negative.  The effect is similar to the {\cb !bloat}
command and the {\vt BloatZ} script function.  The {\it mode} integer
is described with the {\cb !bloat} command.

\index{extent layer expression function}
\item{\vt extent}(layer\_exp {\it layer\/})\\
This evaluates to a trapezoid list containing at most one entry, a
rectangle giving the bounding box of the expression result.  The
return is null if the expression is nowhere dark.  This is similar to
the {\vt ExtentZ} script function.

\index{edges layer expression function}
\item{\vt edges}(real {\it incr\/}, layer\_exp {\it layer\/},
 int {\it mode\/})\\
This creates an edge list, similar to the {\vt EdgesZ} script
function.  See the description of that function for the edge modes
available.  The modes 0--3 are equivalent to returns from the {\vt
bloat} function when returning the edge template, for the four corner
fill-in modes.

\index{manhattanize layer expression function}
\item{\vt manhattanize}(real {\it dimen\/}, layer\_exp {\it layer\/},
 int {\it mode\/})\\
This converts the representation to a Manhattan approximation.  The
first argument is the minimum width or height in microns of rectangles
that are created to approximate the non-Manhattan parts.  The third
argument is an integer taken as zero or nonzero to specify which of
two algorithms to use.  This is similar to the {\cb !manh} command
(where the algorithms are described), and to the {\vt ManhattanizeZ}
script function.

\index{box layer expression function}
\item{\vt box}(real {\it l\/}, real {\it b\/}, real {\it r\/},
 real {\it t\/})\\
This defines a rectangular region from the four real arguments, which
can be used for clipping or construction in layer expressions.  The
coordinates are given in microns.  This is similar to the {\vt BoxZ}
script function.

\index{zoid layer expression function}
\item{\vt zoid}(real {\it xll\/}, real {\it xlr\/}, real {\it yl\/},
real {\it xul\/}, real {\it xur\/}, real {\it yu\/})\\
This defines a horizontal trapezoid region from the six real
arguments, which can be used for clipping or construction in layer
expressions.  The coordinates are given in microns.  This is similar
to the {\vt ZoidZ} script function.

\index{filt layer expression function}
\item{\vt filt}(layer\_exp {\it zoids\/}, layer\_exp {\it lyr2\/})\\
This function is rather specialized.  First, the trapezoids passed in
the first argument are separated into groups of mutually-connected
trapezoids.  Each group is like a wire net.  We throw out the groups
that do not intersect with nonzero area the dark area implied by the
second argument.  The return value is a list of the trapezoids that
remain.

\index{geomAnd layer expression function}
\item{\vt geomAnd}(layer\_exp {\it lyr1} [, layer\_exp {\it lyr2\/}])\\
If one argument is given, the result is the overlapping parts of
regions in the internal list corresponding to the argument.  This is
only useful if the argument was explicitly constructed with {\vt
geomCat} (see below).  With two arguments, this is equivalent to the
intersection operator.  The function is similar to the {\vt GeomAnd}
script function.

\index{geomAndNot layer expression function}
\item{\vt geomAndNot}(layer\_exp {\it lyr1\/}, layer\_exp {\it lyr2\/})\\
This is equivalent to the and-not operator, and is similar to the {\vt
GeomAndNot} script function.

\index{geomCat layer expression function}
\item{\vt geomCat}(layer\_exp {\it lyr1\/}, ... )\\
This takes one or more layer expression arguments and simply
concatenates the regions, without any merging or clipping, similar to
the {\vt GeomCat} script function.

\index{geomNot layer expression function}
\item{\vt geomNot}(layer\_exp {\it lyr\/})\\
This is equivalent to the inversion operator, similar to the {\vt
GeomNot} script function.

\index{geomOr layer expression function}
\item{\vt geomOr}(layer\_exp {\it lyr1\/}, ...)\\
This takes one or more layer expression arguments and returns the
union, constructed internally so that no two regions overlap.  This is
similar to the {\vt GeomOr} script function.

\index{geomXor layer expression function}
\item{\vt geomXor}(layer\_exp {\it lyr1} [, layer\_exp {\it lyr2\/}])\\
If one argument is given, the return is the set of regions
representing the exclusive-or of regions represented by the argument. 
This is only useful if the user has explicitly constructed the
argument using {\vt geomCat}.  If two arguments are given, the result
is the exclusive-or of the areas, equivalent to the exclusive-or
operator.  This function is similar to the {\vt GeomXor} script
function.

\index{drcZlist layer expression function}
\item{\vt drcZlist}(string {\it layername\/}, string {\it rulename\/},
  integer {\it index\/}, layer\_exp {\it lyr1\/})\\
This will return the test areas based on an existing design rule
definition, very similar to the {\vt DRCzList} script function.  This
function exists only when design rule checking is included in the
feature set.

\index{drcZlistEx layer expression function}
\item{\vt drcZlistEx}(layer\_exp {\it lyr1\/}, tring {\it target\/},
  string {\it inside\/}, string {\it outside\/}, integer {\it incode\/},
  integer {\it outcode\/}, real {\it dimen\/})\\
This will return the test areas based on the DRC test area generation
specified by the arguments, very similar to the {\vt DRCzListEx}
script function.  This function exists only when design rule checking
is included in the feature set.

\end{description}

    Examples:

\begin{quote}
    {\vt !layer M2 = M2 \& box(100, 100, 200, 200)}
\end{quote}
      This clips M2 to the given box.

\begin{quote}
    {\vt !layer M2 = bloat(5, M2, 0)}
\end{quote}
      This bloats the M2 geometry by 5 microns.

% -----------------------------------------------------------------------------
% drvlayer 032217
\section{Derived Layers}
\label{drvlyr}
\index{derived layers}
Derived layers are layers which represent the result of a layer
expression involving normal layers and other derived layers.  Although
derived layers are invisible, they can be used to create normal layers
which can be seen.  Derived layers were developed forthe design rule
checking (DRC) system, but can be used in any layer expression.

There are actually two implementations of derived layer functionality. 
In the original implementation, developed for the DRC system, the
geometry of derived layers must be created or updated before the
derived layer is referenced.  In use, reference to a derived layer in
a layer expression retrieves this geometry, very similar to what
happens when a normal layer is referenced.  Ordinarily, the derived
layer geometry will be cleared after final use.  The DRC system
handles creation and destruction of derived layer geometry
transparently.

In the second mode of operation, when the parse tree for the derived
layer is created, references to derived layers will be recursively
parsed and stitched into the tree.  The final parse tree will contain
normal layers only, and can therefor be evaluated in any context,
without the need for precomputed geometry caches.  This method is more
convenient and flexible, however the original method may run more
quickly, particularly when there are a large number of evaluateions of
the same expression, as in DRC.

The derived layer evaluation mode is invisible to the used except
tehat it can be specifically set when using the derived layer script
library function interface.  This provides explicit control of derived
layer geometry creation and destruction, and evaluation mode, through
functions like {\vt EvalDerivedLayers} and {\vt ClearDerivedLayers}.

Derived layers can be defined in the technology file, or the
definitions may be imported from a Virtuoso ASCII technology file. 
Derived layers can also be created with the {\vt AddDerivedLayer}
script function.

A derived layer definition consists of a layer name, a positive
integer index number, and a layer expression string.  The layer
expression can not be null or empty.  The index number is used for
establishing the order when the derived layers are listed, such as
when printing an updated technology file.  This number need not be
unique among derived layers, derived layers with the same index are
ordered alphabetically by name.

The derived layer name may be in the {\it layer\/}:{\it purpose} form,
or may be a simple alphanumeric name.  It either case, it is treated
as a case-insensitive atomic token in name comparisons.  This is
subtly different from normal layers, where for example ``{\vt M1}''
and ``{\vt M1:drawing}'' refer to the same {\Xic} layer (the {\vt
drawing} purpose is the default and need not be explicitly specified). 
As derived layer names, the two forms represent two different derived
layers.

Derived layers can be created arbitrarily.  If a name is already in
use, the existing derived layer definition is updated.  It is not an
error if a derived layer has a name that matches a normal layer. 
References to that name will resolve to the normal layer, thus with a
few exceptions the derived layer would be inaccessible.


% -----------------------------------------------------------------------------
% drcrules 010715
\section{Built-In Design Rules}
\label{designrules}

{\Xic} provides a number of internal rule evaluation functions, to
be described in this section.  These should cover basic and common
design rules as published for a particular fabrication process.  More
complex rules can perhaps be accommodated with the
user-defined rule capability.

Design rules are associated with {\Xic} physical and derived layers. 
In the technology file, the rule definitions appear in layer blocks
for physical and derived layers.

The rules, and derived layers, make use of layer expressions.  A layer
expression can be a single layer name, or a more complicated
expression involving other normal and derived layer names.  In a rule
specification, the expression syntactically represents a single token,
though the expression may include white space.  The expression in the
specification is parsed as far as possible (white space is ignored),
and the rest of the line is taken as further input to the
specification.

The result of the evaluation of a layer expression can be thought of
as a set of geometric figures representing areas where the expression
is true.  Below are two example rule specifications that use layer
expressions.

\begin{quote}
{\vt Overlap M1 | M2  \#layer must be covered by M1 or M2}\\
{\vt NoOverlap Via\&!M1 \#layer must never overlap Via without M1}
\end{quote}

Where a layer expression can be used, a derived layer can also be used.
The examples above can be expressed alternatively using derived layers.

\begin{quote} \vt
DerivedLayer m1orm2 M1 | M2\\
DerivedLayer vianotm1 Via\&!M1\\
...\\
Overlap m1orm2  \#layer must be covered by M1 or M2\\
NoOverlap vianotm1 \#layer can't overlap Via without M1
\end{quote}

Whether it is ``better'' to use layer expressions or derived layers in
the rules is still a bit open, as derived layers are a new feature. 
There may be performance differences, as evaluation is quite
different.  In the case of derived layers, all geometry on the derived
layers is computed before a DRC run, and cleared after the run.  Thus,
during rule evaluation, existing geometry is simply accessed.  When a
layer expression is used, the expression is evaluated in test regions
while the rule is being evaluated.  Thus, the expression requires
evauation, over a tiny area, many times.  It is not clear that one
method or the other would be generally faster, users should
experiment.  Use of layer expressions may be preferred if memory is
constraining, as the amount of memory required to save derived layer
geometry may be substantial.

Use of derived layers may be required for certain types of rules.
For example, suppose that we have a constraint:
\begin{quote}\vt
(NP or PP) Enclosure of PO 0.15
\end{quote}

What this means is that layers NP or PP must cover layer PO, with 0.15
microns distance surrounding PO covered by NP or PP.  This translates
directly to the {\vt MinNoOverlap} rule, but applied on the layer
combination NP{\vt |}PP, which can be accomplished with a derived layer.

\begin{quote}\vt
DerivedLayer implant NP|PP\\
MinNoOverlap PO 0.15 \# (NP or PP) Enclosure of PO 0.15
\end{quote}

\index{pseudo-flat representation}
Ordinarily, a design rule evaluation proceeds as follows.  All
evaluation is performed using a ``pseudo-flat'' representation of the
cell hierarchy, which effectively translates the coordinates of every
object in the hierarchy to the space of the top-level cell.  Each
object in this space can be tested without having to know which cell
in the hierarchy actually contains the object.  The ``global'' tests,
that are not associated with individual objects, such as checking for
holes, are done first.  Then, the per-object tests are performed on
each object in the pseudo-flat representation.  For each object (box,
polygon, or wire), each test listed for the layer of the object is run
in sequence.  The per-area tests, which are done first, are applied to
the area of the object, and remaining tests are applied to constructed
regions along each edge of the object.

Below are descriptions of the built-in design rule test functions, and
the syntax used to specify the test in a layer block in the technology
file.  Each rule line starts with the defining keyword, followed by an
optional {\et Region} expression, required parameters, and an optional
explanation string.

If the {\et Region} keyword and associated expression are given in the
rule specification, the source area becomes those regions where the
expression is true, within the boundaries of the object.  The per-area
tests are applied to the areas where the expression is true, and the
other tests are applied to the edges of these regions.  In simple
cases, the {\et Region} expression is not necessary, but it does
provide additional capability for more complex testing.

Use of {\vt Region} is very similar to defining the rule on
a derived layer consisting of the original layer ANDed with the
{\vt Region} expression.

An optional descriptive string can follow the rule specification.
This string will be saved and included in violation reports.
It is a good idea start the explanation string (if any) with the
script comment character `{\vt \#}' to guarantee termination of the
preceding expression.  Recall that white space is ignored when
parsing the expression.  Most of the time, the parser can recognize
the end of the expression, so the comment character is not necessary,
but it is possible that the explanation string might start with an
operator token such as `{\vt *}' or a reserved keyword such as ``{\vt
not}'', and the expression parse would fail.

For certain rules, the description may have multiple components, i.e.,
it actually consists of multiple strings.  This syntax will be
described below for the affected rules, but is amounts to simply
double-quoting the individual strings.  When constraints are imported
from a Virtuoso ASCII technology file, there are occasions where
multiple constraints, each with a description string, map to a single
{\Xic} primitive rule.  These strings will be recovered when
converting back to Virtuoso format with the {\cb !dumpcds} command.

In the discussion that follows, the following definitions will be
used.  An ``object'' is a physical entity found in the database.  A
``figure'' is a geometrical shape and an associated layer expression
which is true within the shape.  A figure can represent an object and
the object's layer, for example, or one of the regions where a layer
expression is true, and the layer expression.  The ``source'' is a set
of figures where rule evaluation is to be performed.  If no {\et
Region} is given, the source is simply the figure representing the
object's geometry and the object's layer.  Otherwise, the source is
the set of figures where the region expression is true within the
object.  Two or more figures are ``compatible'' if they are associated
with the same layer expression.

\subsection{Global Rules}

The first two rules operate differently from the others, in that they
do not operate on a per-object basis, rather they operate on an entire
pseudo-flattened layer.  As such, they can be computationally and
memory intensive.  These ``global'' tests are performed before the
others, however they are performed only if the area being checked is
the entire cell area.

\index{design rules}

\paragraph{{\et Connected} Rule}
\index{Connected keyword}
\index{design rules!Connected}

\begin{description}
\item{Syntax: {\vt Connected} [{\vt Region} {\it region\_expr\/}]
 [{\it string\/}]}\\

If given in the layer block, the layer or region description (which is
applied to the whole layer) is tested to see that all figures are
mutually connected (touch or overlap).  Disjoint groups of figures are
flagged as violations in the top level cell.  The group with the
largest area is assumed to be the ``correct'' group.
\end{description}

\paragraph{{\et NoHoles} Rule}
\index{NoHoles keyword}
\index{design rules!NoHoles}

\begin{description}
\item{Syntax: {\vt NoHoles} [{\vt Region} {\it region\_expr\/}]
 [{\vt MinArea} {\it area\/}] [{\vt MinWidth} {\it width\/}]
 [{\it string\/}]}\\

If given in the layer block, the layer or region description (which is
applied to the whole layer) is tested for clear area surrounded by
dark area.  Each such area is optionally tested.  If the {\vt MinArea}
is given and positive and the clear area is smaller, a violation will
be reported.  If the {\vt MinWidth} is given and positive, the clear
area must be large enough so that for any edge, a rectangular
projection along the edge extending into the interior by the given
width will be clear.  If not, a violation will be reported.  If
neither of the {\vt MinArea} or {\vt MinWidth} are given, then any
such clear area found will be flagged as a violation.

The {\vt MinArea} and {\vt MinWidth} clauses are set by the {\vt
minHoleArea} and {\vt minHoleWidth} constraints when importing
Virtuoso technology data.  Each constraint may have a separate
reference string.  To keep these distinguishable, the {\it string} can
actually be three double quoted strings, e.g., the form is

\begin{quote}\vt
"\# rule description" "minHoleArea string" "minHoleWidth string"
\end{quote}

This guarantees that the original reference strings are regenerated
when the {\cb !dumpcds} command is used to generate a Virtuoso
technology file.  If a component string doesn't exist, one can use
{\vt ""} (two double-quote marks) as a placeholder.  Strings to the
right that don't exist can be skipped entirely.
\end{description}

\subsection{Area Rules}

The following are the per-area tests, and are applied to the area of
each source figure, for each object in the pseudo-flat representation.

\paragraph{{\et Exist} Rule}
\index{Exist keyword}
\index{design rules!Exist}

\begin{description}
\item{Syntax: {\vt Exist} [{\it string\/}]}\\

This rule will indicate a violation if any dark area is found on the
layer containing the rule.  Unlike most if not all other rules, no
{\et Region} specification is allowed.
 
The {\et Exist} rule is intended for derived layers whose construction
would indicate an incorrect combination of other layers (normal and
derived).  Layer expressions and derived layers can be used as
alternatives to many of the built in rules, and for formulating new
rules.  The results are a bit different from the per-object and
per-edge iteration of the normal rule evaluation flow.  All violations
are found as objects on the derived layer, there is no search limit
(e.g., the normal flow may limit reporting to one violation per
object, though an object may be associated with multiple violations). 
The approach gives the rule-author flexibility.
\end{description}


\paragraph{{\et Overlap} Rule}
\index{Overlap keyword}
\index{design rules!Overlap}

\begin{description}
\item{Syntax: {\vt Overlap} [{\vt Region} {\it region\_expr\/}]
   {\it expression} [{\it string\/}]}\\

This test fails if any source figure is not completely covered by the
figures associated with the {\it expression\/}.  In other words, for
the situation where no {\et Region} is given, the {\it expression}
must evaluate true at every point of every object on the present
layer.  This is illustrated in Figure \ref{drcoverlap}, for no {\et
Region} and an expression consisting of a single layer.
\end{description}

\begin{figure}
\caption{\label{drcoverlap} The {\et Overlap} test.  The present figure
(solid) must be completely covered by figures resulting from evaluating
the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/overlap.eps}
\end{center}
\end{figure}

\paragraph{{\et IfOverlap} Rule}
\index{IfOverlap keyword}
\index{design rules!IfOverlap}

\begin{description}
\item{Syntax: {\vt IfOverlap} [{\vt Region} {\it region\_expr\/}]
    {\it expression} [{\it string\/}]}\\

This test fails if any source figure is partially covered by the
figures associated with the {\it expression\/}.  Unlike the {\et
Overlap} keyword, this test does not fail if there is no intersection. 
The {\it expression} must be either always true or always false at
every point of a source figure, or for every object on the present
layer if no {\et Region} is given.  Figure \ref{drcifoverlap}
illustrates use of this keyword, for no {\et Region} and an expression
consisting of a single layer.
\end{description}

\begin{figure}
\caption{\label{drcifoverlap} The {\et IfOverlap} test.  The present figure
(solid) can not be partially covered by figures resulting from evaluating
the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/ifoverlap.eps}
\end{center}
\end{figure}

\paragraph{{\et NoOverlap} Rule}
\index{NoOverlap keyword}
\index{design rules!NoOverlap}

\begin{description}
\item{Syntax: {\vt NoOverlap} [{\vt Region} {\it region\_expr\/}]
    {\it expression} [{\it string\/}]}\\

This test fails if any source figure has non-zero intersection area
with the figures associated the {\it expression\/}.  The {\it
expression} must evaluate false at every point of every source figure. 
This is illustrated in Figure \ref{drcnooverlap}, for no {\et Region}
and an expression consisting of a single layer. 
\end{description}

\begin{figure}
\caption{\label{drcnooverlap} The {\et NoOverlap} test.  The present
figure (solid) can not intersect with figures resulting from
evaluating the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/nooverlap.eps}
\end{center}
\end{figure}

\paragraph{{\et AnyOverlap} Rule}
\index{AnyOverlap keyword}
\index{design rules!AnyOverlap}

\begin{description}
\item{Syntax: {\vt AnyOverlap} [{\vt Region} {\it region\_expr\/}]
    {\it expression} [{\it string\/}]}\\

The {\et AnyOverlap} test signals a violation if any source figure has
no intersection area with the figures associated with the {\it
expression\/}.  This is illustrated in Figure \ref{drcanyoverlap}, for
no {\et Region} and an expression consisting of a single layer.
\end{description}

\begin{figure}
\caption{\label{drcanyoverlap} The {\et AnyOverlap} test.  The present
figure (solid) must be partially or fully covered by figures resulting
from evaluating the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/anyoverlap.eps}
\end{center}
\end{figure}

\paragraph{{\et PartOverlap} Rule}
\index{PartOverlap keyword}
\index{design rules!PartOverlap}

\begin{description}
\item{Syntax: {\vt PartOverlap} [{\vt Region} {\it region\_expr\/}]
    {\it expression} [{\it string\/}]}\\

The {\et PartOverlap} test signals a violation if any source figure is
either completely covered or completely uncovered by the figures
associated with the {\it expression\/}.  This is illustrated in Figure
\ref{drcpartoverlap}, for no {\et Region} and an expression consisting
of a single layer.
\end{description}

\begin{figure}
\caption{\label{drcpartoverlap} The {\et PartOverlap} test.  The
present figure (solid) must be partially covered by figures resulting
from evaluating the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/partoverlap.eps}
\end{center}
\end{figure}

\paragraph{{\et AnyNoOverlap} Rule}
\index{AnyNoOverlap keyword}
\index{design rules!AnyNoOverlap}

\begin{description}
\item{Syntax: {\vt AnyNoOverlap} [{\vt Region} {\it region\_expr\/}]
    {\it expression} [{\it string\/}]}\\

The {\et AnyNoOverlap} test signals a violation if any source figure
is completely covered by the figures associated with the {\it
expression\/}.  This is illustrated in Figure \ref{drcanynooverlap},
for no {\et Region} and an expression consisting of a single layer. 
\end{description}

\begin{figure}
\caption{\label{drcanynooverlap} The {\et AnyNoOverlap} test.  The
present figure (solid) must be partially uncovered by figures resulting
from evaluating the expression argument (dotted).}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/anynooverlap.eps}
\end{center}
\end{figure}

The returns from the various Overlap tests are summarized in the table
below.

\begin{tabular}{|l||l|l|l|} \hline
\et rule & \et total coverage & \et partial coverage & \et no coverage\\
 \hline \hline
\et Overlap & ok & error & error\\ \hline
\et IfOverlap & ok & error & ok\\ \hline
\et NoOverlap & error & error & ok\\ \hline
\et AnyOverlap & ok & ok & error\\ \hline
\et PartOverlap & error & ok & error\\ \hline
\et AnyNoOverlap & error & ok & ok\\ \hline
\end{tabular}

\paragraph{{\et MinArea} Rule}
\index{MinArea keyword}
\index{design rules!MinArea}

\begin{description}
\item{Syntax: {\vt MinArea} [{\vt Region} {\it region\_expr\/}] {\it area}
 [{\it string\/}]}\\

For each object tested, the neighborhood of the object is searched for
mutually touching, source compatible objects.  The area covered by the
objects is computed, and this is compared with the given area (which
is given in square microns).  If the computed area is less than the
test value a DRC violation is indicated. 

When importing Virtuoso technology data, the {\vt minArea}
constraint maps directly to this rule.
\end{description}

\paragraph{{\et MaxArea} Rule}
\index{MaxArea keyword}
\index{design rules!MaxArea}

\begin{description}
\item{Syntax: {\vt MaxArea} [{\vt Region} {\it region\_expr\/}] {\it area}
 [{\it string\/}]}\\

The total area of the source figures is compared with the given area
(which is given in square microns).  If the area of the figures is
greater than the test value a DRC violation is indicated.  The area is
measured on a per-object basis, and is the sum if there are multiple
figures (due to a region expression).  This does not account for
adjacent objects.
\end{description}

\subsection{Edge Rules}

In the discussion to follow, the ``source'' is the material of the
object being checked, either a layer (on which the rule is defined) or
a layer expression result if the {\vt Region} specification is given. 
The ``target'' is the set of figures associated with the {\it
expression} supplied to the rule, for those rules that take an {\it
expression}.

The rules described in this section are ``edge tests'' where the
region of interest is generally a small constructed area along an
edge.  The test is applied for each applicable edge portion of each
source figure.  The constructed area is rectangular, parallel to the
source figure edge, and may extend out of the source figure, or into
the source figure.  These extend only along the parts of the source
figure edge where certain conditions apply, as will be described.  The
width of the test area (perpendicular to the figure edge) is the
dimension associated with the rule.

We find the edge portions of a source figure as follows.  We iterate
through the edges.  For each edge, we construct a unit-width test area
that extends outside of the figure.  We throw out the parts of the
edge where the test area intersects ``source compatible figures'',
meaning the same layer or layer expresion as the source.  Thus we
throw out the part of the edge which is not really an edge, but a
boundary between dark areas of the same type and is therefor not a
physical discontinuity.  The resulting edge portion is the starting
point for further restrictions that are rule-specific.

Below is a table which identifies the edge portions identified for
the built-in rules, and the test performed.

\begin{tabular}{|l|l|l|l|l|l|} \hline
\bf rule & \bf where & \bf test & \bf src out & \bf trg in & \bf trg out\\
  \hline\hline
\vt MinEdgeLength & in & len & u & c & c\\ \hline
\vt MaxWidth     & in  & snf & u &   &  \\ \hline
\vt MinWidth     & in  & sf  & u &   &  \\ \hline
\vt MinSpace     & out & se  & u &   &  \\ \hline
\vt MinSpaceTo   & out & te  & u & u & x\\ \hline
\vt MinSpaceFrom & out & tf  & u & c & x\\ \hline
\vt MinOverlap   & in  & tf  & u & c & x\\ \hline
\vt MinNoOverlap & in  & te  & u & u & x\\ \hline
\end{tabular}

The first column specifies the built-in rule name of the ``edge''
rules.  These will be described in more detail below.  The {\bf where}
column indicates the direction of the constructed test area along a
source figure edge, either projecting into the figure or outside of
the figure.  The {\bf test} indicates the type of test to perform in
the constructed area.  These are

\begin{quote}
\begin{description}
\item{len}\\
Measure the edge length and compare to given dimension.
\item{snf}\\
The test area is not fully covered by source-compatible material.
\item{sf}\\
The test area is fully covered by source-compatible material.
\item{se}\\
The test area contains no source-compatible material.
\item{tf}\\
The test area is fully covered by target-compatible material.
\item{te}\\
The test area contains no target-compatible material.
\end{description}
\end{quote}

The three remaining columns indicate the part of the source figure
edge that is used to construct the test area.  These indicate the
required coverage of the source material just outside the edge, and
target material just inside and just outside of the edge.  The
possibilities are

\begin{quote}
\begin{description}
\item{c}\\
Covered by the material.
\item{u}\\
Not covered by the material.
\item{x}\\
Doesn't matter.
\end{description}
\end{quote}

So, for example, for {\vt MinSpaceTo}, we take the part of the edges
that are not covered by source just outside of the edge, and not
covered by target just inside of the edge.  The test will pass if the
constructed area, which extends out of the figure, intersects no
target material.

Each of the ``edge'' rules recognize two additional keywords:
\begin{description}
\item{\vt Outside} {\it layer\_expr}\\
This will apply when identifying the part of the edge of a source
figure to use when constructing test areas.  The given layer
expression must be dark along the edge just outside of the figure, in
the parts of the edge to use for the test area.  This provides an
additional rather arbitrary constraint on the test area construction
which may be of use in some cases.

\item{\vt Inside} {\it layer\_expr}\\
This is very similar to the {\vt Outside} constraint, but applies to
the side of the edge just inside of the figure.  Only the parts of the
edge where the given layer expression is dark just inside of the
figure are considered for edges of the test area.
\end{description}

For example:
\begin{quote}
``The minimum distance to CO from a NP/PP butt edge over OD is 0.06
microns.''
\end{quote}

This can be implemented as
\begin{quote} \vt
PhysLayer NP\\
MinSpaceTo Region OD Inside !PP Outside PP CO 0.06\\
PhysLayer PP\\
MinSpaceTo Region OD Inside !NP Outside NP CO 0.06
\end{quote}

The built-in edge rules are described in more detail below.  In each,
for simplicity we will use the following as an abbreviation for the
syntax elements:
\begin{quote}
{\it EdgeArgs} = [{\vt Region} {\it region\_expr\/}]
[{\vt Inside} {\it inside\_expr\/}]
[{\vt Outside} {\it outside\_expr\/}]
\end{quote}

\paragraph{{\et MinEdgeLength} Rule}
\index{MinEdgeLength keyword}
\index{design rules!MinEdgeLength}

\begin{description}
\item{Syntax: {\vt MinEdgeLength} [{\it EdgeArgs\/}]
    {\it expression length} [{\it string\/}] }\\

This test checks the length of the edges where source and target
figures intersect.  For each edge of the source figure, the parts of
the edge where {\it expression} is true on both sides of the edge are
considered.  If the length of the part is less than the given {\it
length}, a violation is flagged.

Example:
\begin{quote}
Rule: ``M3 width must be 2 microns or greater when crossing over M2 edges.''
\end{quote}

This can be handled in two ways.  The first method is to put the rule
in the M2 block:

\vspace*{.5cm}

\begin{quote}\rr\vt
    Layer M2\\
    ...\\
    MinEdgeLength M3 2\\
\end{quote}

The second approach is to put a slightly different implementation into
the M3 block.  This has a problem in that if the M3 is composed of
several objects which together provide the minimum edge length, this
test will fail since it looks at the objects individually.

\begin{quote}\rr\vt
    Layer M3\\
    ...\\
    MinEdgeLength Region M2 M3 2\\
\end{quote}
\end{description}

\begin{figure}
\caption{\label{drcminedgelength} The {\et MinEdgeLength} test.  The
length of the intersecting edge of the present figure (solid) and the
target (dotted) must be greater than the value given.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minedgelength.eps}
\end{center}
\end{figure}

\paragraph{{\et MaxWidth} Rule}
\index{MaxWidth keyword}
\index{design rules!MaxWidth}

\begin{description}
\item{Syntax: {\vt MaxWidth} [{\it EdgeArgs\/}]
   {\it width\_in\_microns} [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures, and the edge length is
greater than the given dimension, a rectangle extending normally from
the edge into the source figure by the given dimension plus a tiny
extra is constructed.  The test fails if this constructed rectangle is
completely covered by source-compatible figures.

The ``tiny extra'' is one internal unit for Manhattan edges.  An
additional ``fudge factor'' is added for non-Manhattan edges to
overcome roundoff error.

When importing Virtuoso technology data, the {\vt maxWidth} constraint
maps directly to this rule.
\end{description}

\paragraph{{\et MinWidth} Rule}
\index{MinWidth keyword}
\index{design rules!MinWidth}

\begin{description}
\item{Syntax: {\vt MinWidth} [{\it EdgeArgs\/}]
   {\it width\_in\_microns} [{\vt Diagonal} {\it alt\_width\/}]
   [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures, a rectangle extending
normally from the edge into the source figure by the given dimension
is constructed.  The test fails if this constructed rectangle is not
completely covered by source-compatible figures.  Note that the angle
formed by two adjacent edges of a figure measured inside of the figure
must be 90 degrees or larger, i.e., this rule prevents acute angles in
polygons.  Figure \ref{drcminwidth} illustrates the test performed
under this keyword, for no {\et Region}.

If the {\vt Diagonal} clause is given and the {\it alt\_width} is
positive, the {\it alt\_width} will be used when the edge being tested
is nonorthogonal.

The {\et MinWidth} test also fails if the length of a line defined by
the overlap points of two mutually overlapping corners of a source
figure and another compatible figure is less than the given dimension,
including the condition where corners of the two figures touch but the
intersection area is zero.

When importing Virtuoso technology data, the {\vt minWidth} constraint
maps directly to this rule.

The {\vt Diagonal} clause is set by {\vt minDiagonalWidth} constraint
when importing virtuoso technology data.  This may have its own
reference string.  To keep this distinguishable, the {\it string} can
actually be two double-quoted strings, e.g., the form is

\begin{quote}\vt
"\# rule description" "minDiagonalWidth string"
\end{quote}

This guarantees that the original reference strings are regenerated
when the {\cb !dumpcds} command is used to generate a Virtuoso
technology file.  If a component string doesn't exist, one can use
{\vt ""} (two double-quote marks) as a placeholder.  Strings to the
right that don't exist can be skipped entirely.
\end{description}

\begin{figure}
\caption{\label{drcminwidth} The {\et MinWidth} test.  The edge-to-edge
spacing across a region on the present layer must not be less than the
given dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minwidth.eps}
\end{center}
\end{figure}

\paragraph{{\et MinSpace} Rule}
\index{MinSpace keyword}
\index{design rules!MinSpace}

\begin{description}
\item{Syntax: {\vt MinSpace} [{\it EdgeArgs\/}]
   {\it space\_in\_microns} {\vt |} {\vt SpacingTable} {\it table definition}
   [{\vt Diagonal} {\it diag\_space\/}]
   [{\vt SameNet} {\it snet\_space\/}] [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures, a rectangle extending
normally from the edge out of the source figure by the given dimension
is constructed.  The test fails if the constructed rectangle has
nonzero intersection area with source-compatible figures.  Note that
the angle formed by two adjacent edges of a figure measured outside
the figure must be 90 degrees or greater, i.e., this rule prevents
acute notches in polygons, and acute bends in wires.  Figure
\ref{drcminspace} illustrates the test performed under this keyword,
for no {\et Region}.

If a spacing table (see \ref{spacetab}) is specified and active, the
dimension used is computed from the spacing table, for Manhattan
edges.  An inactive table will still supply the default spacing, which
is taken as the {\it space\_in\_microns\/}.

If the {\vt Diagonal} clause is given with positive {\it
diag\_space\/}, then the {\it diag\_space} value will be used when the
edge being tested is nonorthogonal.

The {\vt SameNet} clause is currently not implemented, and its
presence has no effect.

The {\et MinSpace} test also fails if the space from a corner of a
source figure to another non-touching compatible figure is less than
the dimension.

When importing Virtuoso technology data, the {\vt minSpacing}
single-layer constraint maps directly to this rule.

The {\vt Diagonal} and {\vt SameNet} clauses are set by {\vt
minDiagonalSpacing} and {\vt minSameNetSpacing} single-layer
constraints when importing virtuoso technology data.  These may have
their own reference strings.  To keep these distinguishable, the {\it
string} can actually be three double-quoted strings, e.g., the form is

\begin{quote}\vt
"\# rule description" "minDiagonalSpacing string" "minSameNetSpacing string"
\end{quote}

This guarantees that the original reference strings are regenerated
when the {\cb !dumpcds} command is used to generate a Virtuoso
technology file.  If a component string doesn't exist, one can use
{\vt ""} (two double-quote marks) as a placeholder.  Strings to the
right that don't exist can be skipped entirely.
\end{description}

\begin{figure}
\caption{\label{drcminspace} The {\et MinSpace} test.  The edge-to-edge
spacing between regions on the present layer must not be less than
the given dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minspace.eps}
\end{center}
\end{figure}

\paragraph{{\et MinSpaceTo} Rule}
\index{MinSpaceTo keyword}
\index{design rules!MinSpaceTo}

\begin{description}
\item{Syntax: {\vt MinSpaceTo} [{\it EdgeArgs\/}]
   {\it expression}
   {\it space\_in\_microns} {\vt |} {\vt SpacingTable} {\it table definition}
   [{\vt Diagonal} {\it diag\_space\/}]
   [{\vt SameNet} {\it snet\_space\/}] [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures or with target figures
which extend into the interior of the source figure, a rectangle
extending normally from the edge out of the source figure by the given
dimension is constructed.  The test fails if the constructed rectangle
has nonzero intersection area with target figures.  Note that overlap
of the two figures is never flagged as a {\et MinSpaceTo} violation,
but touching figures will generate a violation.  Figure
\ref{drcminspaceto} illustrates the test performed under this keyword,
for no {\et Region} and an {\it expression} consisting of a single
layer.

If a spacing table (see \ref{spacetab}) is specified and active, the
dimension used is computed from the spacing table, for Manhattan
edges.  An inactive table will still supply the default spacing, which
is taken as the {\it space\_in\_microns\/}.

If the {\vt Diagonal} clause is given with positive {\it diag\_space},
then the {\it diag\_space} value will be used when the edge being
tested is nonorthogonal.

The {\vt SameNet} clause is currently not implemented, and its
presence has no effect.

The {\et MinSpaceTo} test also fails if the distance from a corner of
the source figure to a non-touching target figure is less than the
dimension.  The corner test is skipped if the corner point is on the
edge of or internal to another figure compatible with either the
source or the {\it expression}.

When importing Virtuoso technology data, the {\vt minSpacing}
two-layer constraint maps directly to this rule.

The {\vt Diagonal} and {\vt SameNet} clauses are set by {\vt
minDiagonalSpacing} and {\vt minSameNetSpacing} two-layer
constraints when importing virtuoso technology data.  These may have
their own reference strings.  To keep these distinguishable, the {\it
string} can actually be three double-quoted strings, e.g., the form is

\begin{quote}\vt
"\# rule description" "minDiagonalSpacing string" "minSameNetSpacing string"
\end{quote}

This guarantees that the original reference strings are regenerated
when the {\cb !dumpcds} command is used to generate a Virtuoso
technology file.  If a component string doesn't exist, one can use
{\vt ""} (two double-quote marks) as a placeholder.  Strings to the
right that don't exist can be skipped entirely.
\end{description}

\begin{figure}
\caption{\label{drcminspaceto} The {\et MinSpaceTo} test.  The minimum
edge-to-edge spacing between regions of the present layer (solid) and the
argument layer (dotted) must not be less than the given dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minspaceto.eps}
\end{center}
\end{figure}

\paragraph{{\et MinSpaceFrom} Rule}
\index{MinSpaceFrom keyword}
\index{design rules!MinSpaceFrom}

\begin{description}
\item{Syntax: {\vt MinSpaceFrom} [{\it EdgeArgs\/}]
    {\it expression dimension\_in\_microns}
    [{\vt Enclosed} {\it enc\_dimen\/}]
    [{\vt Opposite} {\it dimen1 dimen2\/}] [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures but are coincident or
overlapping with target figures which extend to the interior of the
source figure, a rectangle extending normally from the edge out of the
source figure by the given dimension is constructed.  The test fails
if the constructed rectangle is not completely covered by target
figures.  Figure \ref{drcminspacefrom} illustrates the test performed
under this keyword, for no {\et Region} and an {\it expression}
consisting of a single layer. 

If the {\vt Enclosed} keyword is given, it requires that where the
source and target intersect, the source is entirely covered by the
target, with a spacing greater than or equal to the {\it enc\_dimen}
between outside edges.  This applies only if the source figure is
rectangular.  If this clause is used, the {\it
dimesnsion\_in\_microns} should be set to zero.

The {\vt Opposite} clause also requires that if there is intersection,
the source must be entirely covered by the target.  This test also
applies only when the source shape is rectangular.  Two widths are
given following the keyword.  The test passes if two opposite sides of
the source rectangle have extension greater than or equal to the
larger of the two numbers, and the other two edges have extensions
greater than or equal to the smaller dimension.  If the two dimensions
are equal, this is equivalent to the {\vt Enclosed} clause.  When the
two values are different, there is no corner test performed.  If this
clause is given, the {\it dimension\_in\_microns} should be set to
zero.

In either clause, a dimension value of 0.0 can be given, meaning that
the source and target can share an edge.

Without the clauses, this is in many cases redundant with the {\et
MinNoOverlap} test (see below) if applied to the result of the {\it
expression}, if the {\it expression} is simply a layer name.

The {\vt Enclosed} and {\vt Opposite} clauses are set by {\vt
minEnclosure} and {\vt minOppExtension} constraints when importing
virtuoso technology data.  These may have their own reference strings. 
To keep these distinguishable, the {\it string} can actually be three
double-quoted strings, e.g., the form is

\begin{quote}\vt
"\# rule description" "minEnclosure string" "minOppExtension string"
\end{quote}

This guarantees that the original reference strings are regenerated
when the {\cb !dumpcds} command is used to generate a Virtuoso
technology file.  If a component string doesn't exist, one can use
{\vt ""} (two double-quote marks) as a placeholder.  Strings to the
right that don't exist can be skipped entirely.
\end{description}

\begin{figure}
\caption{\label{drcminspacefrom} The {\et MinSpaceFrom} test.  The rule
is violated if the projection from the current layer, if any, is less
than the supplied dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minspacefrom.eps}
\end{center}
\end{figure}

\paragraph{{\et  MinOverlap} Rule}
\index{MinOverlap keyword}
\index{design rules!MinOverlap}

\begin{description}
\item{Syntax: {\vt MinOverlap} [{\it EdgeArgs\/}]
    {\it expression dimension\_in\_microns} [{\it string\/}] }\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures and are coincident or
overlapping with target figures which extend into the interior of the
source figure, a rectangle extending normally from the edge into the
source figure a distance given by the dimension is constructed.  The
test fails if the constructed rectangle is not completely covered by
target figures.  Figure \ref{drcminoverlap} illustrates the test
performed under this keyword, for no {\et Region} and an {\it
expression} consisting of a single layer.

When importing Virtuoso technology data, the {\vt minExtension}
constraint maps directly to this rule.
\end{description}

\begin{figure}
\caption{\label{drcminoverlap} The {\et MinOverlap} test.  The minimum
width of an intersection of the present layer (solid) and the argument
layer (dotted) must not be less than the given dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minoverlap.eps}
\end{center}
\end{figure}

\paragraph{{\et MinNoOverlap} Rule}
\index{MinNoOverlap keyword}
\index{design rules!MinNoOverlap}

\begin{description}
\item{Syntax: {\vt MinNoOverlap} [{\it EdgeArgs\/}]
    {\it expression dimension\_in\_microns} [{\it string\/}]}\\

For the parts of each edge of the source that are not coincident or
overlapping with source-compatible figures or with target figures
which extend into the interior of the source figure, a rectangle
extending normally from the edge into the source figure a distance
given by the dimension is constructed.  The test fails if the
constructed rectangle has nonzero intersection area with target
figures.  Figure \ref{drcminnooverlap} illustrates the test performed
under this keyword, for no {\et Region} and an {\it expression}
consisting of a single layer.
\end{description}

\begin{figure}
\caption{\label{drcminnooverlap} The {\et MinNoOverlap} test.  The minimum
width of regions of the present layer (solid) which do not intersect the
argument layer (dotted) must not be less than the given dimension.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/minnooverlap.eps}
\end{center}
\end{figure}


% -----------------------------------------------------------------------------
% spacetab 120214
\section{Spacing Tables}
\label{spacetab}
The design rule checking system supports one and two-dimensional
spacing tables, for use in the {\et MinSpace} and {\et MinSpaceTo}
rules.  These provide a size-dependent spacing value.

Spacing tables may be imported from Cadence Virtuoso ASCII technology
files, or may be created and used exclusively within {\Xic}.  The
format is the same as the {\it width} and {\it width---length} spacing
tables found in Virtuoso constraint definitions.

In {\Xic}, spacing tables are not independent objects, but are owned
by a {\et MinSpace} or {\et MinSpaceTo} design rule.  Each rule of
these types can have a spacing table.  The tables are printed when an
{\Xic} technology file is generated, as part of the rule specification
string.  The rule text is printed using backslash line continuation
characters for legibility, as the rule string will be rather long when
the table is included.  The same format is used when listing rules in
the {\cb Edit Rules} window, and in the text editor used to edit the
spacing table text from the rule editor windows for these rules.

Below is the text for a spacing table, which will be explained as an
example.

\begin{quote}\vt
SpacingTable 0.0900 2 0x0 11$\backslash$\\
   0.0050 0.0050 0.0900$\backslash$\\
   0.2050 0.3850 0.1100$\backslash$\\
   0.4250 0.3850 0.1100$\backslash$\\
   0.4250 0.4250 0.1600$\backslash$\\
   1.5050 0.3850 0.1100$\backslash$\\
   1.5050 0.4250 0.1600$\backslash$\\
   1.5050 1.5050 0.5000$\backslash$\\
   4.5050 0.3850 0.1100$\backslash$\\
   4.5050 0.4250 0.1600$\backslash$\\
   4.5050 1.5050 0.5000$\backslash$\\
   4.5050 4.5050 1.5000$\backslash$
\end{quote}

The {\vt SpacingTable} keyword begins the definition.  Note that each
line ends with a backslash character.  This ``hides'' the return
character, so that logically the text forms a single line.  One could
certainly enter the text as a single line, the hidden line breaks are
for readability only.  The kind and number of text tokens that form
the definition are well defined, so there is no ambiguity in where the
table definition ends, when it is included in a larger string.

Following the initial keyword are four numeric tokens.  The first is
the default spacing in microns, as a floating-point number.  This will
apply when the table does not resolve a value.  This should be the
same number as the default spacing in the associated design rule, but
will override that value if different.

The second number is the table dimensionality, which is either 1 or 2. 
The example is a two dimensional table, which is probably most common. 
Each row of a two dimensional table contains three numbers, for {\it
width\/}, {\it length\/}, and the spacing value.  In a one dimensional
table, the {\it length} values are not present.

The third number is a hexadecimal value which is used as a flags byte. 
The flags are saved in tables imported from Virtuoso, and represent
unhandled features.  The only purpose of these flags is to regurgitate
the needed keywords when a Cadence technology file is produced with
the {\cb !dumpcds} command.  The flags are not documented, but the
least significant bit is actually an ``ignore'' flag used only by
{\Xic}.  The main thing to be aware of is that the spacing table will
only be active if the flags integer is 0.  If not zero, the table will
be carried with the rule, but will not be used in analysis.  The
default spacing, given in the first number, will apply in any case.

The fourth number is a positive integer giving the number of rows in
the table.  Each ``row'' consists of two or three floating-point
numbers, for one and two dimensional tables.  The row data follow.

The first number in each row is the {\it width} parameter.  In {\Xic},
this parameter is obtained from the object whose edges are currently
being evaluated for {\et MinSpace} or {\et MinSpaceTo} violations.  If
the object is a rectangle, the {\it width} is the smaller of the
rectangle width and height.  If the object is a wire, the {\it width}
is the wire's width.  If the object is a non-rectangular polygon, the
{\it width} is the smaller of the bounding box width and height.

In two-dimensional tables, the second parameter ({\it length\/}) is
the parallel run length of the two edges normal to the spacing
direction being tested.

The remaining parameter is a spacing value that applies for the given
{\it width\/}, and {\it length} in two-dimensionsl tables.

\subsection{Spacing Table Evaluation}

Spacing tables are used only for Manhattan (horizontal or vertical)
edges.  Non-Manhattan edges will use the {\et Diagional} spacing if
given, or the default spacing.  There is presently no provision for
size-dependent spacing of non-Manhattan edges.

The {\it minspace} dimension will be found in the row where the
measured {\it width} and {\it length} are greater than or equal to the
row {\it width} and {\it length\/}, with the largest spacing value. 
The evaluation is actually iterative, and follows this logic:

\begin{quote}
  Compute the {\it width} parameter knowing the object being tested.\\
  Loop over each object edge $\{$\\
  \begin{quote}
    Take the initial {\it length} to be the total edge length.\\
    Evaluate the spacing table, find the initial {\it minspace\/}.\\
    Loop $\{$\\
    \begin{quote}
      Construct a test region along and outside of the edge being tested,
      with width given by the {\it minspace\/}.\\
      Test this region for the presence of target material.\\
      if (none found)
      \begin{quote}
        Break, edge test is clean.
      \end{quote}
      Measure the length of each intersection region and sum.  This
      provides a new {\it length}.\\
      Evaluate the spacing table with the new {\it length\/}.\\
      if (the new and old {\it minspace} are equal)
      \begin{quote}
        Break, test indicates violation.
      \end{quote}
      The new {\it minspace} will be smaller, check again.
    \end{quote}
    $\}$
  \end{quote}
  $\}$
\end{quote}


% -----------------------------------------------------------------------------
% userrules 061908
\section{User-Defined Design Rules}
\label{udefrules}

This section describes the facility for defining and referencing
user-specified design rules.  These allow complex tests to be
implemented.  User-defined rules are defined in separate blocks ahead
of the physical layer specification blocks in the technology file. 
The rules are referenced from the layer blocks.  A user defined rule
definition has the following general form:

\begin{quote}
{\vt DrcTest} {\it testname arg1 arg2} ...\\
{\vt Edge Outside|Inside} {\it expression}\\
{\vt MinEdge} {\it dimension}\\
{\vt MaxEdge} {\it dimension}\\
{\vt Test Outside|Inside} {\it dimension expression}\\
{\vt TestCornerOverlap} {\it dimension}\\
{\vt Evaluate} {\it logical\_expression}\\
{\vt [} {\it script lines} {\vt ]}\\
{\vt End}
\end{quote}

The first line of the block starts with the keyword {\et DrcTest}. 
This is followed by a name for the test, which must be unique among
the keywords recognized in the technology file.  This is the name by
which the test will be referenced.  Following the name are zero or
more argument tokens.  These can be any alphanumeric text strings,
which represent parameter names.  These are the formal arguments to
the rule, and appear in the lines that follow in the form ``{\vt
\%}{\it token}{\vt \%}'', which will be replaced by the actual arguments
given in the references to the rule.

The rule is evaluated at each edge of the source.  Each edge is
divided into segments, depending on specifications.  For each segment,
a rectangle is constructed, extending either into or out of the
source figure.  Tests are applied to these regions,

The {\et Edge} keyword indicates an edge specification.  There can be
zero or more edge specifications.  Following the {\et Edge} keyword is
one of the keywords {\et Outside} or {\et Inside} followed by a layer
expression.  When the edge is evaluated the regions of the edge where
the expression is true are found, either just inside or just outside
of the figure.  The default edge is the set of regions where there is
no source figure just outside the edge, which means that there is no
source-compatible adjacent figure.  The results from each {\et Edge}
specification are anded together with the default edge to determine
the segments where tests are performed.  The expression part of the
{\et Edge} specification can contain argument substitutions.

For example:
\begin{quote}\vt
Edge Inside M2
\end{quote}
This will include the parts of the figure boundary that 1) do not
touch or overlap another figure of the same source (the default edge),
and 2) have layer {\vt M2} present on the inside side of the boundary. 
The default edge is always implicitly included in the conjunction.

The {\et MinEdge} and {\et MaxEdge} lines, which are optional, allow
setting limits on the segments used for testing.  If given, an edge
segment used for testing would have length greater or equal to the
{\et MinEdge} dimension, and less than or equal to the {\et MaxEdge}
dimension.  The dimensions appearing after the keywords can contain
argument substitutions.

There must be one of more lines given which start with the keyword
{\et Test}.  These specify the tests which are applied to regions
constructed from the edge segments.  Following {\et Test} is one of
the keywords {\et Outside} or {\et Inside}, which determines whether
the test area extends outside or inside the source figure.  The
following token, which can contain an argument substitution, sets the
length by which the test area extends out of or into the source
figure.  The rest of the line contains a layer expression, which can
contain argument substitutions, which is evaluated in the test area. 

The expression will be evaluated within the test area by one of the
evaluation functions described below.  If using the most common {\vt
DRCuserTest} evaluation function, The test is true if the expression
is true somewhere in the test area, meaning that there is a non-zero
area where the logical expression would be ``dark''.

For example:
\begin{quote}\vt
Test Outside 0.5 !M2
\end{quote}
This test will be ``true'' if within the rectangle extending out of
the figure from the edge by 0.5 microns, there is some point where
layer {\vt M2} is not present, if using {\vt DRCuserTest}.

The optional {\et TestCornerOverlap} is a special supplemental test
when evaluating ``{\vt MinWidth}''.  This measures the mutual edge or
overlap of adjacent compatible figures.  The width of the mutual edge
must be greater than the dimension (which can contain argument
substitutions).

The final line, which begins with the keyword {\et Evaluate},
specifies a logical expression or script.  There are two forms for the
{\et Evaluate} construct.  In the first form, the expression must be
cast as an assignment to a variable named ``{\vt fail}'', and if set
true the entire rule fails.  Argument substitutions are allowed in the
expression.  The assignment must appear on the same line following
{\et Evaluate}.

In the second form, there can be no additional text on the line
following {\et Evaluate}.  The following lines contain a script, in
the format understood by the script parser.  This is terminated with
the keyword {\et EndScript}.  Argument substitutions are allowed in
these lines.  The script can contain any of the constructs described
in the manual section on the script parser, with the exception of the
``preprocessing'' directives; any line with a leading `\#' is ignored. 
The script should set a variable named ``{\vt fail}'' to signal a DRC
violation.

There are several functions which can appear in the {\et Evaluate}
lines.  Each of these functions takes a single integer argument.  This
is a zero-based integer index corresponding to the {\et Test} lines,
in order of their appearance.  Each function returns a value obtained
from the corresponding test.

The functions currently available are the following:

\begin{description}
\item{(int) {\vt DRCuserTest}({\it index\/})}\\
The return value is 1 if the test region is not empty, 0 otherwise.

\item{(int) {\vt DRCuserEmpty}({\it index\/})}\\
The return value is 1 if the test region is empty, 0 otherwise.

\item{(int) {\vt DRCuserFull}({\it index\/})}\\
The return value is 1 if the test region is completely covered, 0
otherwise.

\item{(zoidlist) {\vt DRCuserZlist}({\it index\/})}\\
The return value is a list of trapezoids clipped from the test region. 
The list can be used with script functions that operate with this data
type.

\item{(int) {\vt DRCuserEdgeLength}({\it index\/})}\\
The return value is the length along the edge of the test region. 
This is the value that is filtered by {\et MinEdge} and {\et MaxEdge}. 
Filtered edges will not be seen by this function.
\end{description}

The functions specified are called for each test region for each edge
and corner.  The return value can be used to set the {\vt fail}
variable.  Once the {\vt fail} variable has been set nonzero, testing
of the object terminates for the present rule.

For example:
\begin{quote}\vt
Test Outside 0.5 !M2\\
Test Inside 0.5 !M2\\
Evaluate fail = DRCuserTest(0) $|$ DRCuserTest(1)
\end{quote}
Here, the test fails if {\vt M2} does not completely cover the area
0.5 microns on either side of the edge.  The arguments to the {\vt
DRCuserTest} function refer to the {\vt Test} lines:  0 is the first
{\vt Test} line in the rule, 1 the second, and so on.

The multi-line variation of the {\et Evaluate} clause has the form
\begin{quote}
{\tt Evaluate}\\
{\it script line}\\
...\\
{\tt EndScript}
\end{quote}

Within the script, there are a number of predefined variables
available.  With the exception of {\vt fail}, these all start with
an underscore.

\begin{description}
\item{\vt \_ObjType}\\
The type of object which is undergoing DRC.  Values are 'p', 'w', or
'b', for polygons, wires, and boxes.

\item{\vt \_ObjNumEdges}\\
This is the number of vertices in the figure being tested.  Boxes and
wires are converted to polygons for testing, so this makes sense for
all objects.  The first and last vertices are the same, and all are
counted, so that the number of vertices in a box is five.

\item{\vt \_CurEdge}\\
This is the zero-based index of the edge or vertex currently being
tested.  If the original object is a box, the zeroth vertex is the
lower-left corner, and the zeroth edge is the left edge.  For
polygons, the zeroth vertex is the first vertex in the polygon's
coordinate list, and the zeroth edge extends from this vertex to the
next.  This index will cycle through the values from 0 to {\et
\_ObjNumEdges}-1.  Values may be skipped of there is no testable area
at the edge or corner.

If a test is identified as a ``MinWidth'' type, i.e., an inside
test with the target the same as the source, at most two edges are
tested if the figure is a box.

\item{\vt \_CurTest}\\
This gives the following values:  0 if the test is a standard edge
test, 1 if the test if a corner test, and 2 if the test is the {\et
CornerOverlap} test.

\item{\vt \_CurX1, \_CurY1, \_CurX2, \_CurY2}\\
These four variables provide the starting and ending coordinates of
the edge segment being tested, in microns.
\end{description}

Variables defined within the script remain in scope forever, they do
not change between calls.

When an object is DRC tested, the {\et Overlap} tests, if any, are
first applied to the source region.  This is followed by the {\et
Area} tests, then the edge tests, which include any user-defined
tests.  During the edge tests, each edge is evaluated in sequence. 
The test may be applied several times for different regions along the
edge or not at all, depending on the geometry and the {\et Edge}
specification.

Edge segments are evaluated in the order crossed by a point following
the boundary starting at the first vertex (lower left corner for
boxes).  Boxes and wires always have clockwise winding, though
polygons can have either clockwise or counterclockwise winding.

Associated with the edge test are the corner tests.  For a box, the
order of tests is given below.  The corner test is applied at each
vertex (if indicated by the angle) after the previous adjacent side
has been tested.  The test area is a polygonal shape designed to
``fill in'' gaps between the rectangular areas associated with the
sides.

\begin{tabular}{|l|l|l|} \hline
\et \_CurEdge & \et \_CurTest & which\\ \hline \hline
0 &         0 &         left edge\\ \hline
1 &         1 &         upper left corner\\ \hline
1 &         0 &         top edge\\ \hline
2 &         1 &         upper right corner\\ \hline
2 &         0 &         right edge\\ \hline
3 &         1 &         lower right corner\\ \hline
3 &         0 &         bottom edge\\ \hline
0 &         1 &         lower left corner\\ \hline
\end{tabular}

A rule is implemented by adding a reference to the rule in the
layer block of a physical layer.  The format is

\begin{quote}
    {\it testname} [{\tt Region} {\it region\_expr\/}] [{\it arg1
        arg2} ...] [{\it string\/}]
\end{quote}

The {\it testname} is the keyword defined in one of the rule
definitions, as described above.  This is followed by an optional
source specification, and the actual arguments, which must correspond
in number to the rule arguments.  These are followed by an optional
{\it string}, which is arbitrary explanatory text.

As initial examples, below are implementations of the built-in
rules which involve edge evaluation.

These are the rule definitions, and by convention they appear in the
technology file after the electrical layer definitions and ahead of
the physical layer definitions.

\begin{quote}
\begin{verbatim}
# In the first two rules, lyr is the same as the source
#
DrcTest myMinWidth dim lyr
Test Inside %dim% !%lyr%
TestCornerOverlap %dim%
Evaluate fail = DRCuserTest(0)
End

DrcTest myMinSpace dim lyr
Test Outside %dim% %lyr%
Evaluate fail = DRCuserTest(0)
End

# In the remaining rules, lyr is different from the source
#
DrcTest myMinSpaceTo dim lyr
Edge Inside !%lyr%
Test Outside %dim% %lyr%
Evaluate fail = DRCuserTest(0)
End

DrcTest myMinSpaceFrom dim lyr
Edge Inside %lyr%
Test Outside %dim% !%lyr%
Evaluate fail = DRCuserTest(0)
End

DrcTest myMinOverlap dim lyr
Edge Inside %lyr%
Test Inside %dim% !%lyr%
Evaluate fail = DRCuserTest(0)
End

DrcTest myMinNoOverlap dim lyr
Edge Inside !%lyr%
Test Inside %dim% %lyr%
Evaluate fail = DRCuserTest(0)
End
\end{verbatim}
\end{quote}

To implement the rules, references are added to the layer definitions:

\begin{quote}\vt
Layer M1\\
...\\
myMinWidth  3.0 M1\\
myMinSpace  2.0 M1\\
myMinSpaceTo 1.0 M2\\
...
\end{quote}

Here are some examples of more complicated rules:

\begin{description}
\item{{\bf Rule}:  Objects on M3 smaller that 10 microns must be
separated by .5 microns or more, Objects larger than 10 microns must
be separated by .75 microns or more.}
\end{description}

\begin{quote}\rr\vt
DrcTest myMinSp1 lyr\\
\# Fail if spacing $<$ 0.5\\
Test Outside .5 \%lyr\%\\
Evaluate fail = DRCuserTest(0)\\
End

DrcTest myMinSp2 lyr\\
\# Fail if spacing $<$ 0.75 and width $>=$ 10\\
MinEdge 10\\
Test Outside .75 \%lyr\%\\
Test Inside 10 !\%lyr\%\\
Evaluate fail = DRCuserTest(0) \& !DRCuserTest(1)\\
End
\end{quote}

\begin{quote}\rr\vt
Layer M3\\
...\\
myMinSp1 M3\\
myMinSp2 M3\\
...\\
\end{quote}

Note that we did not need to use substitution here, as the rule only
applies to M3.

\begin{description}
\item{{\bf Rule}:  Objects on M3 must be larger than 1 micron, unless over
I1 in which case the width must be 1.25 microns.}
\end{description}

\begin{quote}\rr\vt
DrcTest myMinW1 lyr\\
\# Fail if width $<$ 1.0\\
Test Inside 1 !\%lyr\%\\
TestCornerOverlap 1\\
Evaluate fail = DRCuserTest(0)\\
End

DrcTest myMinW2 lyr\\
\# Fail if width $<$ 1.25 and I1 present\\
Test Inside 1.25 !\%lyr\%\\
Test Inside 1.25 I1\\
TestCornerOverlap 1.25\\
Evaluate fail = DRCuserTest(0) \& DRCuserTest(1)\\
End
\end{quote}

\begin{quote}\rr\vt
Layer M3\\
...\\
myMinW1 M3\\
myMinW2 M3\\
...\\
\end{quote}

\begin{description}
\item{{\bf Rule}:  The overlap of M1 surrounding Via must be .5 microns or
greater.  Only two sides maximum can have an overlap of less than 1
micron, the other sides must have 1 micron of overlap or more.}
\end{description}

In the script below, two arrays are defined, to hold the test results. 
We assume that only boxes are used for vias, and ignore the corner
tests.  When the final edge (\_CurEdge = 3) is reached, the results
saved in the arrays are evaluated, and the fail flag is set if an
error is indicated.

\begin{quote}
\begin{verbatim}
DrcTest vtest
Test Outside 1 !M1
Test Outside .5 !M1
Evaluate
tl[4]
ts[4]
if (_ObjType == 'b' & _CurTest == 0)
    tl[_CurEdge] = DRCuserTest(0)
    ts[_CurEdge] = DRCuserTest(1)
    if (_CurEdge == 3)
        if (tl[0] + tl[1] + tl[2] + tl[3] > 2)
            fail = 1
        end
        if (ts[0] + ts[1] + ts[2] + ts[3] > 0)
            fail = 1
        end
    end
end
EndScript
End
\end{verbatim}
\end{quote}

The test is implemented in the Via layer block.  Just the keyword is
needed, since no arguments are passed.

\begin{quote}\rr\vt
Layer Via\\
...\\
vtest\\
\end{quote}


% -----------------------------------------------------------------------------
% drc:assign 061908
\section{Assigning Design Rules}
\index{design rules!assignment}

Design rules can be added to the technology file by hand with a text
editor, or from within {\Xic} using the {\cb Edit Rules} pop-up panel in the
{\cb DRC Menu}.  Note that if macros or the {\et eval} construct are to be
used in design rules, the text must be inserted with a text editor, as
these constructs are unknown to the {\cb Edit Rules} pop-up.

\index{design rules!limitations of tests}
{\Xic} supports a set of design rule primitives which should cover the vast
majority of cases encountered in process technology specifications. 
In addition, more specialized tests can be developed through use of
user-defined design rules, described in \ref{udefrules}.

Most simple specifications translate directly into a rule keyword, in
particular, the setting of {\et MinWidth} and {\et MinSpace} are
usually straightforward.  {\et MinWidth} is generally the smallest
feature size allowable on the layer, and {\et MinSpace} is the
smallest gap allowed between features on the layer.  Note that if one
feature touches another on the same layer, the tests are applied such
that the combined features are measured.  Thus it is legitimate to
have subdimensional features, as long as they are directly adjacent to
other features so that the combined dimensions satisfy the {\et
MinWidth} test.

There are six rules which flag overlapping of layers {\et Overlap},
{\et IfOverlap}, {\et NoOverlap}, {\et AnyOverlap}, {\et PartOverlap},
and {\et AnyNoOverlap}.  Of these, the first three are by far the most
commonly used.  If objects on layer A should always be over/under
layer B, the {\et Overlap} rule should be added to layer A.  If
objects on layer A should never intersect layer B, the {\et NoOverlap}
rule should be applied to layer A.  The case of coincident layer A and
B edges of adjacent objects will not produce an error, unless an
additional {\et MinSpaceTo} test is applied.  If objects on layer A
should either be entirely covered by layer B, or not intersect layer B
at all, the {\et IfOverlap} rule should be added to layer A.  In this
test, if an object on layer A partially intersects layer B, an error
is generated.  This is useful for ensuring that a feature does no
cross an underlying edge, for example.

In reciprocal rules, such as {\et MinSpaceTo}, which specifies the
minimum distance between objects on two different layers, it is often
questioned whether the rule should be specified in each layer.  The
answer is no, although no real harm is done if it is specified in both
layers, though both specifications had better provide the same
dimension.  In testing of a newly created object (interactive DRC),
first the object is tested with respect to rules defined on the
object's layer.  If there are no errors, all nearby objects which have
a rule target of the object's layer are tested, and any errors are
flagged on the new object.  For example if a box on layer A is created
too close to a box on layer B, and B contains a {\et MinSpaceTo} rule
with respect to layer A, first the A box is tested (result: ok) then
the B box is tested, (result: failure due to proximity to A).  The A
box is marked and the error region is indicated.  In batch mode
testing, only the rules for a given object are evaluated.  Typically,
all objects in the region are tested, so the error will be caught.  If
there were specifications on each layer, there would be two error
messages produced, as two separate but redundant tests would be
performed.  In the {\et MinSpaceTo} test, the condition where edges
are coincident is flagged as an error, however if the two objects
are actually intersecting with nonzero area, no error is generated
from the {\et MinSpaceTo} test.

\index{design rules!overlap definition}
\index{design rules!vias}
The word ``overlap'' is confusingly used in two contexts.  In process
specifications, the ``overlap'' is often taken as the width of
material surrounding a feature, such as a via.  In the {\Xic}
documentation, ``overlap'' often refers to an area of mutual
intersection of two (or more) different layers.  As an important
example, a process specification might read ``overlap of M1 around VIA
1.0 micron''.  This implies that layer M1 must extend 1.0 microns or
more outside of the VIA feature.  One way to test this condition is
with the {\et MinNoOverlap} keyword as a rule on M1:  ``{\vt
MinNoOverlap VIA 1.0}''.  This specifies that a region along the
outside edge of M1 1 micron in width toward the inside of the M1
feature will be checked for the presence of VIA, and an error will
occur if any VIA material is found intersecting with this region.  The
{\et MinNoOverlap} test will flag as an error the case where the edges
of the two intersecting objects are coincident, however if the VIA
area actually encloses M1, no error is generated.  The {\et Overlap}
and {\et IfOverlap} keywords can be used to detect this circumstance. 
Often, the process specification will list such a rule with the
interior feature layer (VIA), in which case it makes more sense to use
the {\et MinSpaceFrom} test as in ``{\vt MinSpaceFrom M1 1.0}''
applied to the VIA layer.  This specifies that a region projecting
outward from the VIA feature by 1 micron should be entirely covered by
M1.  This is almost equivalent to the {\et MinNoOverlap} test, however
the treatment of the corners is different.  This is illustrated in
Figure \ref{viatest}.

\begin{figure}
\caption{\label{viatest}The {\et MinSpaceFrom} and {\et MinNoOverlap}
tests differ in the treatment of the corner regions projecting outward
from the central feature, as shown.}
\vspace{1.5ex}
\begin{center}
\epsfbox{images/viatest.eps}
\end{center}
\end{figure}

In the case of coincident vias, where the order is not important but
the concentric spacing must be greater than some value, mutual {\et
MinNoOverlap} rules can exist in each layer.  In the case where one
ordering is prohibited, the {\et Overlap} or {\et IfOverlap} keywords
can be used in the inner layer.  For example, suppose VIA1 and VIA2
can be concentric, but VIA1 must be outside of (larger than) VIA2. 
Layer VIA1 would contain a ``{\vt MinNoOverlap VIA2}'' directive,
layer VIA2 would contain an ``{\vt IfOverlap VIA1}'' directive if VIA2
can exist independently of VIA1, or an ``{\vt Overlap VIA1}''
directive otherwise.  Then, if VIA2 is larger than VIA1, the partial
intersection will trigger an error.

The {\et MinOverlap} test is used to determine whether the
intersection width of two layers is larger than some minimum.  It is
usually used of conjunction with certain types of contacts or vias, to
ensure that the contacting area is sufficiently large.  The {\et MinArea}
and {\et MaxArea} tests are also useful is this regard.  In particular,
to test that a via has an exact size (square), a {\et MinWidth} and
a {\et MaxArea} test are both applied.  A {\et MinEdgeLength} test is
used in the circumstance where the edge-crossing width of a layer is
larger than the layer's minimum width.


% -----------------------------------------------------------------------------
% xic:limit 021615
\section{The {\cb Setup} Button: Set DRC Limits}
\index{Setup button}
\index{design rules!limits}
\index{design rules!setup}
The {\cb Setup} button in the {\cb DRC Menu} brings up the {\cb DRC
Parameter Setup} panel, which allows the user to set limits and other
parameters used in design rule checking.

The top third of the panel provides control of layer and rule
filtering.  It is sometimes useful to perform design rule checking
using only a subset of rules, on only a subset of layers.  It may also
be useful at times to skip particular rules or layers.  The user has
this flexibility through the entries in this panel.  One also has the
ability to inhibit rules individually with the {\cb Design Rule
Editor} panel from the {\cb Edit Rules} button in the {\cb DRC Menu}.

At the top of the panel are {\cb Check listed layers only} and {\cb
Skip listed layers} check boxes.  If either is checked (it is not
possible to select both) then the text entry area just below the check
boxes becomes un-grayed, and the user is expected to enter a list of
layer names, separated by space.  Rules on the listed layers will
either be used exclusively or ignored during checking, depending on
which of the boxes is checked.

The layer filtering entries control the status of two variables.  The
filtering can also be set up by setting the values of the variables
directly.

\begin{description}
\item{\et DrcLayerList}\\
This variable is set to a space-separated list of layer names, as
shown in the text entry area.  The variable exists only if there is
text shown in the entry area.

\item{\et DrcUseLayerList}\\
If this variable is not set, then the {\et DrcLayerList} variable will
be ignored if it exists, and DRC testing will use rules defined on all
layers.  If the variable is set to a word that starts with `{\vt n}'
(case-insensitive) or just the letter itself, then the {\et
DrcLayerList} will be used, if it exists, to provide a list of layers
whose rules will be skipped during DRC testing.  If {\et
DrcUseLayerList} is set to something else, including to nothing (set
as a boolean), the {\et DrcLayerList}, if it exists, will supply a
list of layers whose rules will be used during DRC testing.  Rules on
unlisted layers will not be tested in this case.
\end{description}

Below the layer list entry are {\cb Check listed rules only} and {\cb
Skip listed rules} check boxes.  These, and the initially grayed text
entry area just below, provide an analogous filtering capability based
on rule names.  The rule names are the names (keywords) of the
built-in tests, or the name assigned to a user-defined rule.  If ether
box is checked (it is possible to check at most one of the boxes),
then the text entry area becomes un-grayed and the user should enter a
space-separated list of rule names.  The name matching is
case-insensitive.  The listed rules will either be checked exclusively
(unlisted rules ignored) or skipped during DRC testing, depending on
which box is checked.

The rule filtering entries control the status of two variables.  Rule
filtering can also be set up by setting the values of the variables
directly.

\begin{description}
\item{\et DrcRuleList}\\
This variable is set to a space-separated list of rule names, as shown
in the text entry area.  The variable exists only if there is text
shown in the entry area.

\item{\et DrcUseRuleList}\\
If this variable is not set, then the {\et DrcRuleList} variable will
be ignored if it exists, and DRC testing will use all rules that have
been defined, and have not been inhibited.  If the variable is set to
a word that starts with `{\vt n}' (case-insensitive) or just the
letter itself, then the {\et DrcRuleList} will be used, if it exists,
to provide a list of rules that will be skipped during DRC testing. 
If {\et DrcUseRuleList} is set to something else, including to nothing
(set as a boolean), the {\et DrcRuleList}, if it exists, will supply a
list of rules that will be used during DRC testing.  Unlisted rules
will not be tested in this case.
\end{description}

Below the layer and rule filtering group is the limit values group. 
These provide numeric limit values that are observed while testing. 
Each of these controls has a corresponding tracking variable (see
\ref{drcvars}).

The first limit is on the number of violations reported in batch mode
checking.  These are runs initiated from the {\cb DRC Run Control}
panel obtained from the {\cb Batch Check} button in the {\cb DRC
Menu}.  If this limit is reached, the checking terminates.  Setting
this limit (or any of the limits) to zero will inhibit the limiting.

The remaining limits pertain to interactive mode (the {\cb Enable
Interactive} button in the {\cb DRC Menu} is active).  When enabled,
these checks are performed after every operation which modifies the
physical geometry in the database.  Often, the pause can be quite
substantial, and it is preferable to minimize the delay, at the
expense of thorough testing.  Testing can be performed at a later time
using batch mode.  The interactive time can be limited in two ways: 
by limiting the number of objects checked, and by actually setting a
time limit.  The checking will also terminate when a maximum error
count is reached.  Of course, interactive testing can be switched off
entirely with the {\cb Enable Interactive} button.

The object count limit specifies the maximum number of objects checked
per test cycle.  The time limit, specified in milliseconds, will
terminate testing when the time limit is reached.  The error count
limit, if nonzero, will terminate testing when the count is reached.

The final choice is a yes/no as to whether to test subcells that are
moved, copied, or placed.  This is often very time consuming, as all
objects in the subcell and its descendents are checked.  If the
subcell has been checked previously, most of the checking is redundant
and can be skipped.

The remaining buttons allow selection of the violation recording
level.  The default is to record only one violation per object.  With
many violations, this can cut evaluation time, and may be useful for a
first pass.  The second choice outputs a maximum of one violation of
each type (i.e., corresponding to each rule name keyword) per object. 
The third choice will output all violations found.  This can lead to
redundancy, as certain violations may be reported for each {\it edge}
of the offending object.


% -----------------------------------------------------------------------------
% xic:sflag 063014
\section{The {\cb Set Flags} Button: Set Skip Flags}
\index{Set Flags button}
\index{design rules!skip objects}
The {\cb Set Flags} button in the {\cb DRC Menu} enables the ``skip
drc'' flag to be set or cleared on objects in the current cell.  When
the flag is set, the object is ignored by the drc tests.  Note that
this can cause other tests to fail, for example if a subdimensional
object is adjacent to another object on the same layer with its skip
flag set, the error will be reported.  Objects with the skip flag set
are shown as selected.  The selected objects can be deselected, or
other objects selected, in the usual way.  In any case, the selected
status when the command exits will be represented in the objects' skip
flags.

If the layer has the {\et NoDrcDatatype} attribute set in the
technology file or with the {\cb Edit Tech Params} button in the {\cb
Attributes Menu}, objects with the skip flag set will be written with
the given datatype rather than the default datatype set in the {\et
StreamOut} specification, in GDSII and OASIS files.

\index{NDRC layer}
Objects which intersect a layer named ``NDRC'' are also skipped during
DRC testing.  Defining an NDRC layer is an easy way to avoid testing
logos, process test features, and other objects which would ordinarily
produce many errors.


% -----------------------------------------------------------------------------
% xic:intr 021815
\section{The {\cb Enable Interactive} Button: Set Interactive Checking}
\index{Set Interactive button}
\index{design rules!interactive}
\index{interactive rule checking}
When th {\cb Enable Interactive} button in the {\cb DRC Menu} is
active, design rule checking is performed on new objects as created,
or objects modified, during editing.  A violating object is marked,
and the error highlighted.  A pop-up window explains the violation,
unless this has been suppressed with the {\cb No Pop Up Errors}
button.  The object is included in the database, and the user must
decide whether to fix or defer the violation.

This tracks the state of the {\et Drc} variable.


% -----------------------------------------------------------------------------
% xic:nopop 021815
\section{The {\cb No Pop Up Errors} Button: Suppress Error Report}
\index{No Pop Up errors button}
When the {\cb No Pop Up Errors} toggle button in the {\cb DRC Menu} is
set, violations found in interactive DRC do not cause messages to
appear in a pop-up window.  The error indication is still drawn
on-screen, however.  The {\cb Query Errors} command can be used to get
the error string, or the {\cb Dump Error File} command can be used to
obtain a complete report.

This tracks the state of the {\et DrcNoPopup} variable.


% -----------------------------------------------------------------------------
% xic:check 010615
\section{The {\cb Batch Check} Button:  Initiate Rule Check}
\index{Batch Check button}
\index{keyboard!Ctrl-c}
\index{design rules!check}

The {\cb Batch Check} button in the {\cb DRC Menu} provides the {\cb
DRC Run Control} panel.  This panel allows initiation of a batch DRC
job, running either in the foreground or background.  By ``batch'', it
is meant that the job is not intended to be interactive.  Such jobs
may take a long time to run.

The panel has two pages, tabbed {\cb Run} and {\cb Jobs}.  The {\cb
Run} page is generally of most interest and is the default page.

The top two entries in the {\cb Run} page allow a Cell Hierarchy
Digest (CHD) to specify the source cells for the DRC run.  A CHD is a
small database of cell offsets into a large layout file, which allows
access to the content of the file without reading it into {\Xic}. 
With limited memory, this allows huge files to be accessed, that would
otherwise fail to load due to memory limitation.  The first line
contains a text entry area into which the user enters the CHD name. 
This will be ignored unless the {\cb Use} button, to the left of the
text entry, is pressed.  The second line is optional, and may contain
the name of a cell referenced by the CHD.  This will be taken as the
top-level cell in design rule checking.  If no entry is given, the
default top-level cell of the CHD is used.

These entry areas mirror the values of the {\et DrcChdName} and {\et
DrcChdCell} variables.  The variables are set when the corresponding
entry area contains text, unset otherwise.  The variables can be set
directly, however in any case the {\cb Use} button must be pressed for
the values to have any effect during the DRC run.

In order to gain any memory-saving benefit from using a CHD, a
partition grid should generally be used.  This is set in the third row
of the {\cb Run} page.  When the partition grid is enabled, the area
to test is divided into a grid of the specified size.  The DRC testing
is performed sequentially for each grid area.  In the case of CHD
input, only the geometry needed to represent the current grid area is
in memory, which should be a small fraction of the geometry of the
total test area (if the test area is very small, partitioning is not
needed).

To set up a partition grid, un-press the button with the {\cb None}
label.  This will un-gray the text entry area to the right.  This area
should be set to the side length in microns of the square grid cell. 
The size should be small enough so that the geometry needed to
represent the area will easily fit in memory, but not so small that
the overhead inherent in the gridding increases run time appreciably. 
The best value is very dependent on the technology, and the user
should experiment.

The partition setting entry and button control, and are controlled by,
the {\et DrcPartitionSize} variable.  When this variable is set to a
number, that number is taken as the partition grid spacing.  The
partition size can be set and the use of partitioning enabled by
setting this variable directly.

The partition grid also applies when the current cell is the target of
the design rule checking.  It is not clear at present that the
partition grid provides any advantage in this case.  Some operations
may be performed faster when gridded as opposed to processing the
entire layout, due to scaling properties.  The use of the partition
grid provides something for the user to experiment with.

By default, a DRC test run will test the entire area of the target
cell (either the current cell, or the cell implied from the CHD).  The
group of controls below the {\cb Partition grid size} entries allows
the testing area to be set to an arbitrary rectangular window.  Of
course, the window coordinates should overlap the cell coordinates, or
no testing will be done.

When the {\cb Set} button is pressed, a command is active where if the
user drags, or clicks twice to define the corners of a rectangle,
those values will set the numerical entries on the panel.  This can be
used to visually set the test area to an area of interest in the
displayed layout.  This works whether or not the window is actually
used, i.e., whether or not the numeric coordinate entry areas are
grayed.

The window will be ignored unless the {\cb Use Window} check box is
checked.  When checked, the numerical coordinate entry areas become
un-grayed, and the user can manually enter the window coordinates.

The {\cb Flatten} check box is un-grayed only when the {\cb Use} (use
CHD) button is pressed.  When checked, as geometry is being read into
memory with the CHD, it will be flattened into a single cell.  Thus,
DRC tests will be applied to a flat cell, which can be more efficient
than processing a hierarchy.  However, there is overhead in
flattening, and the flat representation can take much more memory than
a hierarchical representation.  This should generally be employed only
when using a partition grid or small window.  The feature is rather
experimental and obscure.

Near the bottom of the {\cb Run} page are large {\cb Check} and {\cb
Check in Background} buttons.  These will launch a DRC run in the
foreground or background.  The run will observe the other settings in
the panel (and in the {\cb DRC Parameter Setup} panel).

When a job is started in the foreground with the {\cb Check} button,
the button remains pressed until the job completes.  If the user
un-presses the button, the job will be paused, and can be terminated
by the user.  The job can also be paused by pressing {\kb Ctrl-c} when
{\Xic} has keyboard focus.  Other operations are locked out while DRC
is running.  Violations are recorded in a file named {\vt
drcerror.log.}{\it cellname} which is written in the current
directory.  Additionally, if not using a CHD, violating objects are
marked, and the error region highlighted.

When a foreground job is running, {\Xic} is busy and unusable.  When a
job is started in the background, however, {\Xic} is available for
other tasks.  There can be multiple spawned processes executing
concurrently.  A pop-up window will appear alerting the user that a
job has completed.

Unlike the foreground run, violations are not marked on-screen.  The
{\cb Update Highlighting} button can be used to generate the
highlighting after a background run completes.  If the {\cb Show
Errors} mode is active, and the current cell is the same as that being
checked, when a background job terminates, the error display window is
popped down and the mode terminates.

The spawned process is set to ignore the {\vt SIGHUP} signal, so that
the process will continue to run if the user's shell is destroyed
and/or the user logs out.  This is the preferred method by which
large, batch DRC jobs can be performed.

This process will create an errors file in the current directory named
{\vt drcerror.log.}{\it cellname\/}{\vt .}{\it PID} where {\it PID} is
the process id of the spawned process.

Under Windows, this works by executing a batch-mode {\Xic} process in
the background.  Presently, this doesn't allow background jobs to use
a CHD or partitioning.

The {\cb Jobs} page provides a list of background jobs currently
running.  Jobs can be selected by clicking on the text.  When a job is
selected, the {\cb Abort job} button becomes un-grayed.  Pressing this
button will halt the selected job.  Be aware that there is no
confirmation, and it is not possible to restart a job that is halted
in this manner.  The spawned process can also be stopped or killed
using the job control functionality of the user's shell.


% -----------------------------------------------------------------------------
% xic:point 061908
\section{The {\cb Check In Region} Button: Check Objects}
\index{Check In Region button}
\index{design rules!check in region}
When the {\cb Check In Region} button in the {\cb DRC Menu} is active,
design rule checking is performed on objects the user clicks on or
drags over.  The method of selecting a region to check is the same as
for the {\cb Check In Foreground} command, however the {\kb Enter} key
is ignored.  Violating objects are marked, the error region
highlighted, and a pop-up explains the error.  No file is produced.  A
maximum of 15 errors are accumulated for each region --- the check
terminates at this error count.  The {\cb Check In Region} command
button remains active until explicitly terminated, unlike the {\cb
Check In Foreground} command.


% -----------------------------------------------------------------------------
% xic:clear 061908
\section{The {\cb Clear Errors} Button: Clear Error List}
\index{Clear Errors button}
\index{design rules!clear errors}
Pressing the {\cb Clear Errors} button in the {\cb DRC Menu} will
delete the internal list of error-producing objects, and consequently
clear the display of highlighting and error boxes associated with
violations.  This does not affect to objects in the database.


% -----------------------------------------------------------------------------
% xic:query 061908
\section{The {\cb Query Errors} Button: Print Error Text}
\index{Query Errors button}
\index{design rules!print error}
When the {\cb Query Errors} button in the {\cb DRC Menu} is active,
clicking on the highlighted error region (not the object, but the
highlighted figure which indicates the location of the error) will
display the text of the error message for that error on the prompt
line.


% -----------------------------------------------------------------------------
% xic:erdmp 091509
\section{The {\cb Dump Error File} Button: Save Errors to File}
\index{Dump Error File button}
The {\cb Dump Error File} button in the {\cb DRC Menu} allows the user
to dump a file containing the error records for the currently visible
(as highlighting) errors.

The user is first given the chance to provide the file name, which
should begin with ``{\vt drcerror.log}'' to be recognized as a DRC
errors file for subsequent reading into {\Xic}.  After the file is
created, the user is given the option to view the file in a {\cb File
Browser} window.  If no file name is given, the file will be written
to a temporary file which is erased on program exit.  This may be
convenient if the user only wants a quick view of the text.

Tha {\cb Update Highlighting} command button provides the reverse
operation, recreating the highlighting from an existing error log
file.


% -----------------------------------------------------------------------------
% xic:erupd 010615
\section{The {\cb Update Highlighting} Button: Create Highlighting from File}
\index{Update Highlighting button}
The {\cb Update Highlighting} button in the {\cb DRC Menu} will delete
the internal list of DRC error highlighting indicators, and rebuild
the list from a DRC error log file.  The error log file must exist in
the current directory, have a file name beginning with ``{\vt
drcerror.log}'', and apply to the current cell.  If there are multiple
files found, a listing will appear, allowing the user to make a
choice.  After selecting an entry, pressing the {\cb Apply} button on
the list pop-up will continue the operation.

DRC error files are produced by the batch mode checking operations
initiated from the {\cb DRC Run Control} panel.  In the foreground
check, the highlighting list is generated along with the file, however
no highlighting is produced in background checking, so this command
can be used to visualize the errors in that case.  It can also be used
to bring back the highlighting that was cleared with the {\cb Clear
Errors} command, if there is a corresponding error log file.

The {\cb Dump Error File} command performs the reverse operation,
creating an error log file from the internal highlighting list.

The {\cb !errs} prompt line command performs the same operations as
this button.


% -----------------------------------------------------------------------------
% xic:next 010615
\section{The {\cb Show Errors} Button: Show Next Error}
\index{Show Errors button}
\index{design rules!browsing errors}
\index{keyboard!Page Up}
\index{keyboard!Page Down}
\index{keyboard!Ctrl-f}
\index{keyboard!Ctrl-b}
\index{keyboard!Ctrl-p}
After batch rule checking (using the operations initiated from the
{\cb DRC Run Control} panel) is performed, or in any case when a
compatible DRC error log file is present in the current directory,
errors from the file may be graphically viewed sequentially with the
{\cb Show Errors} button in the {\cb DRC Menu}. 

When the {\cb Show Errors} button is pressed, if there is only one
error log file for the current cell, it is loaded, otherwise a list of
files is presented and the user must make a selection, then press the
{\cb Apply} button.  If a file is successfully loaded, the {\cb Show
Errors} button in the menu will be shown active, and a message will
appear in the prompt area.  The search for error files extends only to
the current directory, and only to files with a name beginning with
``{\vt drcerror.log}''.  The file must have been generated from a cell
with the same name as the current cell.

This sets a mode where pressing the {\kb PageDown} key will display
the first and subsequent errors in a sub-window.  The {\kb PageUp} key
can be used to view previously displayed errors.  The {\kb Ctrl-f} key
performs the same operation as {\kb PageDown}, and the {\kb Ctrl-b}
and {\kb Ctrl-p} keys are equivalent to {\kb PageUp}.

The {\kb PageDown} or {\kb Ctrl-f} keys can be used to access the
errors randomly, by number.  Entering a number followed by {\kb
PageDown} or {\kb Ctrl-f} will display the corresponding error.  One
can also enter {\kb $+$} or {\kb $-$} ahead of the number, in which
case {\kb PageDown} and {\kb Ctrl-f} will move backward or forward in
the list by the number.

The functionality is maintained until the {\cb Show Errors} button is
selected a second time, making it inactive, or the sub-window is
dismissed.  The mode {\it cannot} be exited with the {\kb Esc} key. 
Any command can be executed when the {\cb Show Errors} button is
active, making it possible to interactively fix the errors without
leaving {\cb Show Errors} mode. 

If a DRC background run terminates when the {\cb Show Errors} mode is
active, and the checked cell is the same as the current cell, the
error display window will be popped down, and the mode exited.  The
mode can be restarted to view the errors from the new file. 

Note that in the sub-window, only the current error is highlighted,
whereas in other windows, all errors may be highlighted, if a
highlighting list exists.  The highlighting list can be created or
rebuilt from the file with the {\cb Update Highlighting} button.

{\cb Show Errors} mode is terminated if a new cell is opened for
editing, including {\cb Push} and {\cb Pop}, and upon switching to
electrical mode.


% -----------------------------------------------------------------------------
% xic:erlyr 091509
\section{The {\cb Create Layer} Button: Create Error Region Layer}
\index{Create Layer button}
The {\cb Create Layer} button in the {\cb DRC Menu} will create
objects on a given layer corresponding to the error regions in the
current highlighting list.  These are the actual error regions with
solid outline highlighting, and not the ``bad'' objects which are also
marked but with a dashed outline.  This operation can be useful for
adding the errors to a design file for subsequent processing, and for
other purposes.

The {\cb Update Highlighting} command button can be used to generate a
highlighting list from an existing DRC error log file.

The user is first prompted for a layer name.  Any suitable layer name
can be given.  A new layer will be created if the name does not match
an existing name.

The layer will be cleared before the operation starts.  Objects
(database polygons and boxes) will be created only in the current
cell.

A second prompt allows the user to provide an integer property value. 
If the user supplies a value larger than 0, a property will be applied
to each object with the given number, containing a string with the
text of the corresponding error message.  The {\cb Show Phys
Properties} mode, available from the {\cb Main Window} sub-menu of the
{\cb Attributes Menu} and the {\cb Attributes} menu of sub-windows,
can be used to display these messages.  If a positive integer is not
given, no property will be stored with the new objects.

The {\cb !errlayer} prompt line command performs an identical
operation.


% -----------------------------------------------------------------------------
% xic:dredt 040112
\section{The {\cb Edit Rules} Button: Rule Editor Panel}
\index{Edit Rules button}
The {\cb Edit Rules} button in the {\cb DRC Menu} brings up the {\cb
Design Rule Editor} panel.  The editor contains a listing of design
rules for the current layer.  The rules for any layer can be displayed
by clicking in the layer menu and selecting a new layer.  Design rules
for the current layer can be added, deleted, modified, or disabled. 
The {\cb Save Tech} command in the {\cb Attributes Menu} can be used
to write a new technology file in the current directory that reflects
the changes made.

The rules are listed one per line, using the same syntax as the
specification in the technology file.  Rules are shown after any
technology file macros have been expanded, and macros can not be used
in new rules entered from the {\cb Design Rule Editor} panel. 
Clicking with button 1 on a rule will cause it to become selected (or
deselected if it was already selected).  Selected rules are acted on by
the {\cb Edit}, {\cb Delete}, and {\cb Inhibit} commands in the {\cb
Edit} menu of the {\cb Design Rule Editor} panel.  The selected rule
is shown highlighted.

The {\cb Quit} button in the {\cb Design Rule Editor} panel {\cb Edit}
menu retires the rules panel.  This can also be accomplished by
pressing the {\cb Edit Rules} button in the {\cb DRC Menu} a second
time.

If a rule is selected, pressing the {\cb Edit} button in the {\cb
Edit} menu will cause the {\cb Design Rule Parameters} entry panel to
appear if not already visible, from which the rule parameters can be
modified.  Once parameters are modified, the {\cb Apply} button will
make the changes and update the listing, and dismiss the panel.  The
rule most recently edited can be reverted to the previous parameters
with the {\cb Undo} button in the {\cb Edit} menu of the {\cb Design
Rule Editor} panel.

If a rule is selected, pressing the {\cb Delete} button deletes the
rule from the current layer.  The most recently deleted rule can be
restored with the {\cb Undo} button.  Deleted rules are really gone,
and will not be written to the technology file during update.

The {\cb Inhibit} button toggles the inhibited status of the rules. 
An inhibited rule is listed with an `I' in the first column, and is
not applied when checking is performed.  It is useful on occasion to
temporarily disable a rule.  The {\cb Save Tech} command will write
all rules present to the technology file, inhibited or not.  The
inhibited status is active only for the current {\Xic} session.

If a rule is selected, pressing the {\cb Inhibit} button will change the
inhibited state of the selected rule, and deselect the rule.

The {\cb Undo} button undoes the last edit, addition or delete
operation.  A second press will redo the undo.

The {\cb Rules} menu bar item produces a drop-down list containing the
names of the built-in design rules.  Selecting a button will cause the
{\cb Design Rule Parameters} entry panel to appear if not already
visible, from which the rule parameters can be entered.  Once
parameters are entered, the {\cb Apply} button will add the rule and
update the listing, and dismiss the panel.  A new rule will replace an
existing rule of the same type and target layer.  There is also an
entry which allows references to user-defined rules to be created.  If
user-defined rules have been defined, the entry produces a sub-menu of
the defined rules.  Selecting one allows instantiation on the current
layer.

The {\cb Rule Block} button produces a drop-down menu containing the
names of existing user-defined rules, plus entries {\cb New}, {\cb
Delete}, and {\cb Undelete}.  Selecting one of the rule entries brings
up a text editor window loaded with the rule block text.  The text can
be modified, and when saved the internal rule will be updated.  This
will be reflected in the technology file created with the {\cb Save
Tech} button in the {\cb Attributes Menu}.  Selecting the {\cb New}
entry will open an empty editing window, into which the text of a new
rule can be inserted.  Saving the text adds the new rule to the
internal list.

To delete a user-defined rule, press the {\cb Delete} button in the
{\cb Rule Block} menu, then select a rule from the same menu.  That
rule will be removed from the menu.  The rule can be restored with the
{\cb Undelete} menu entry, but only one deletion is remembered.  When
a rule block is deleted, all instances of the rule (in the layers) are
inhibited, but not deleted.  They are cleared when the internal backup
copy of the deleted rule is deleted, which happens on the next rule
deletion or when the pop-up is dismissed.  If a rule is undeleted, its
instances are uninhibited.

When a user-defined rule is edited and saved, the instances of the old
rule (of the same name) are inhibited, but are not cleared.  The old
rule instances are left as an indication of where the previous rule
was applied and what arguments it takes.  To apply the new rule, the
old instances should be deleted by hand, and a new instance created. 
If the inhibited rules are uninhibited from the menu, the old rule
will be used, not the new one.  If a technology file is created with
the {\cb Save Tech} command, the inhibited rules will be included, so
that it is important to delete these if the call to the new rule is
different from the call to the old.


% xic:ruleedit 010815
\subsection{The {\cb Design Rule Parameters} Panel}

This panel, which is polymorphic and specific for each design rule
type, appears when a design rule is edited or a new rule is being
created from the {\cb Design Rule Editor} panel.  It provides the
appropriate entry areas for rule parameters.  If the target rule is
changed while the panel is visible, the panel will reconfigure itself
to provide the entries for the new rule.

There are entries that are common to multiple rules.  All rules have
an entry labeled ``{\cb Decsription string}'', which contains optional
arbitrary text which explains the rule or provides a reference.  This
text will appear in violation messages.  All rules but {\et Exist}
contain an entry labeled ``{\cb Layer expression to AND with source
figures on current layer (optional)}''.  This is the optional {\et
Region} specification.  In addition, the ``edge'' rules contain two
entries:  ``{\cb Layer expression to AND at inside edges when forming
test areas (optional)}'' and similar for outside edges.  These can
provide values for the optional {\et Inside} and {\et Outside}
keywords.

The entry areas for the rules are briefly described below.  See
the rule descriptions for more information.

\begin{description}
\item{\vt User Defined Rule}\\
\begin{description}
\item{\cb User-defined rule arguments ({\it n} required)}\\
An entry area where the rule arguments are entered, separated by
space.  The label prints the number of arguments required for the
rule, extra arguments are ignored.
\end{description}

\item{\vt Connected}\\
No additional entries.

\item{\vt NoHoles}\\
\begin{description}
\item{\cb Minimum area (square microns)}\\
If larger than 0.0, holes with an area smaller than this value will
trigger an error.

\item{\cb Minimum width (microns)}\\
If larger than 0.0, holes with a width less than this value will
trigger an error.
\end{description}
If both of these parameters are 0.0, any hole will trigger an error.

\item{\vt Exist}\\
No additional entries.

\item{\vt \parbox{1in}{Overlap\\
IfOverlap\\
NoOverlap\\
AnyOverlap\\
PartOverlap\\
AnyNoOverlap}}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.
\end{description}

\item{\vt MinArea}\\
\begin{description}
\item{\cb Minimum area (square microns)}\\
This specifies the minimum area for the rule.
\end{description}

\item{\vt MaxArea}\\
\begin{description}
\item{\cb Maximum area (square microns)}\\
This specifies the maximum area for the rule.
\end{description}

\item{\vt MinEdgeLength}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.

\item{\cb Minimum edge length (microns)}\\
This specifies the minimum edge length for the rule.
\end{description}

\item{\vt MaxWidth}\\
\begin{description}
\item{\cb Maximum width (microns)}\\
This specifies the maximum width for the rule.
\end{description}

\item{\vt MinWidth}\\
\begin{description}
\item{\cb Minimum width (microns)}\\
This specifies the minimum width for the rule.

\item{\cb Non-Manhattan "diagonal" width}\\
If nonzero, this value will be used instead when the measurement
direction is not parallel to the x or y axis.
\end{description}

\item{\vt MinSpace}\\
\begin{description}
\item{\cb Default minimum spacing (microns)}\\
This specifies the default minimum space for the rule.

\item{\cb Non-Manhattan "diagonal" spacing}\\
If nonzero, this value will be used instead when the measurement
direction is not parallel to the x or y axis.

\item{\cb Same-Net spacing}\\
If nonzero, this value will be used instead when the measurement
is between objects in the same wire net.  {\bf This is currently not
implemented.}

\item{\cb Use spacing table}\\
When checked, a spacing table (see \ref{spacetab}) will be used.  This
provides minimum space based on the source width and running parallel
overlap length.  The table is consulted for Manhattan edges only.  The
table can be created or edited with the {\cb Edit Table} button, which
brings up a text editor window containing any existing table.
\end{description}

\item{\vt MinSpaceTo}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.

\item{\cb Default minimum spacing (microns)}\\
This specifies the default minimum space for the rule.

\item{\cb Non-Manhattan "diagonal" spacing}\\
If nonzero, this value will be used instead when the measurement
direction is not parallel to the x or y axis.

\item{\cb Same-Net spacing}\\
If nonzero, this value will be used instead when the measurement
is between objects in the same wire net.  {\bf This is currently not
implemented.}

\item{\cb Use spacing table}\\
When checked, a spacing table (see \ref{spacetab}) will be used.  This
provides minimum space based on the source width and running parallel
overlap length.  The table is consulted for Manhattan edges only.  The
table can be created or edited with the {\cb Edit Table} button, which
brings up a text editor window containing any existing table.
\end{description}

\item{\vt MinSpaceFrom}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.

\item{\cb Minimum dimension (microns)}\\
This specifies the minimum projection for the rule.

\item{\cb Dimension when target objects are fully enclosed}\\
If nonzero, this value will be used to test objects that
are fully surrounded.

\item{\cb Opposite side dimensions}\\
If at least one of the two numbers is nonzero, these will be used to
test fully enclosed boxes.  Two opposite sides must be enclosed by at
least one value, and the other two sides must be enclosed by at least
the other value.
\end{description}

\item{\vt MinOverlap}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.

\item{\cb Minimum dimension (microns)}\\
This specifies the minimum overlap width for the rule.
\end{description}

\item{\vt MinNoOverlap}\\
\begin{description}
\item{\cb Target layer name or expression}\\
This is the name of a layer, or a layer expression, which is the
target for the rule.  An entry is mandatory.

\item{\cb Minimum dimension (microns)}\\
This specifies the minimum projection for the rule.
\end{description}

\end{description}

