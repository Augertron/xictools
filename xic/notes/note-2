
Variables defined in script functions are now automatic by default.
Previously, they were static.  The term "automatic" means that every
call of the function provides a fresh and unique variable.
A static variable retains its contents between calls, and the same
variable storage is used in all calls.  One can explicitly assign
a variable to be static using the (new) "static" keyword.  This construct
can appear anywhere, but makes sense only in functions.  The syntax is

    static var1 [= val] var2 ...

The var1, etc are variables used in the function that are to have static
storage.  They can optionally be initialized by including an assignment.
If an assignment is used, it should consist of constants and variables
that have already been assigned to the left, or in a previous static line (
there can be more than 1).
  Array variables should have an initial integer specified in square
brackets.  The terms can be separated by white space and/or commas.

The static lines *must* appear in function calls ahead of any other lines.

Example:
    function myfunc(a, b, c)
    static callcnt = 0, x[32]
    ...
    callcnt = callcnt = 1
    Print("myfunc has been called", callcnt, "times")
    endfunc


Fixed bug: A coincident instance warning was issued if only the top left
coordinate matched.  Now both top left and bottom right coordinates must
match, and the transforms must match.

Interactive DRC testing is now limited by default to 1000 objects or 5
seconds, whichever comes first.  Previously there was no limit.

The time limit function for interactive DRC was not working, fixed.

The "pseudo-flat" generator used in DRC created a linked list of search
generators, one for each subcell instance in the hierarchy that overlaps
the search area.  For very large databases, this list would comsume too
much memory.  A new approach was taken that does not require a long
list, and is therefore much more conservative of memory.

Added some look-ahead to the pseudo-flat search which hugely speeds up
traversal when the search layer is sparsely distributed.

Previously, array sizes were limited to 1,000,000.  This limit has been
removed.  Note that the datum is 8 bytes, so a length of 1 million
requires 8MB of memory.

// (int) FreeArray(array)
//
// This function will delete the memory used in the array, and
// reallocate the size to 1.  This function may be useful when memory
// is tight.  It is not possible to free an array it there are
// variables that point to it.  This function returns 1 on success, 0
// otherwise.
//

// (real) CoreSize()
//
// This returns the total size of dynamically allocated memory used by
// Xic, in kilobytes.
//
static boolean
IFcoreSize(Variable *res, Variable *args)
{
    res->type = TYP_SCALAR;
    res->content.value = coresize();
    return (OK);
}

The "pretty" mode of the logo command was not finding the default font,
causing a system crash unless a font was set with !logofont.
----------------------------------------------------------------

Putting instances of empty cells in the database at 0,0 caused a performance
problem if there are large numbers of these (in db_check_block()).  The
BB of an empty instance is now set to the point given by the translation.

this pointer problem, check ms (OK)

There is a new pop-up panel which handles the situation when a file has
empty subcells.  Previously, after a file was opened for editing, if
empty cells were found, the user would be prompted for whether or not
to delete them.  Now, the pop-up appears.  The pop-up is similar in appearance
to the Merge Control pop-up, which appears when a cell in memory may be overwritten.
A list of the empty cells is shown, each followed by "yes" or "no", where
"yes" implies that the cell will be deleted.  Initially, all listings
will be "no", but these can be changed by clicking on them.  The Delete All
button sets all entries to "yes", and the Skip All button sets all entries
to "no".  Pressing Apply will actually p[erform the deletions.

If all the listed cells are deleted, Xic will search again for empty cells,
and update the pop-up if any are found.  New cells may now be empty due to
the deletions.

This pop-up can be brought up with the new !empties command, at any time.

New variable:
  NoCheckEmpties (boolean)
When set (with the !set command) the pop-up that normally appears when a
file is opened for editing if there are empty symbols in the hierarchy is
suppressed.  An "empty symbol" is a symbol that contains no physical or
electrical objects or subcells.  It is possible to check for empty symbols
at any time with the !empties command.

reorganized the !set variables internally and in help/preferences

reorganized the ! commands in help and internally

(Windows only) The File Browser pop-up had text edit mode enabled.  This has
been disabled.

(Windows only)
I finally figured out how to obtain the memory used by the program, so that
the CoreSize() script function now works.  The Memory Manager pop-up
now contains a line giving the memory used.  For the curious, there is an
"undocumented" !vmem function that prints the virtual memory map of the
application.

** Removing a subfunc will cause havoc: parsetree.cc line 1047

This function was changed.  It now returns the previous status.

// (int) SetLayerSpecific(state)
//
// This function will set layer-specific selection mode if the
// argument is nonzero, or normal mode otherwise.  The return value is
// 1 or 0 representing the previous layer-specific mode status.
//

return value logic was reversed

// (int) Replace(cellname, add_xform)
//
// This will replace all selected subcells with cellname.  The same
// transformation applied to the previous instance is applied to the
// replacing instance.  In addition, if add_xform is nonzero, the
// current transform will be added.  The function returns 1 if
// successful, 0 if the new cell could not be opened.


Fixed core leak in script interpreter.

Changed default return of script functions to 1.

New keyword in scripts: elif

This is optionally used after "if".

The full syntax for the if construct is given below.

    if (statement1)
        commands1
    elif statement2
        commands2
      ...
    elif statementN
       commandsN
    else
       commands
    end

The only parts that are mandatory are "if", statements1, and "end", all other
clauses are optional.  The statements are expressions which resolve to a
logical value, with nonzero indicating true.  The commands are blocks
of script lines.
  If statements1 evaluates nonzero, commands1 is
executed, otherwise if statements2 is nonzero, commands2 is executed, and
so on for each elif clause present.  If none of the statements evaluate
to a nonzero value, the commands block (following "else") is executed.

Note that "elif" is *not* the same as "else if" as "else if".  The following
two blocks are equivalent:

   if (a == 1)
       Print(1)
   elif (a == 2)
       Print(2)
   else
       Print("?");

   if (a == 1)
       Print(1)
   else
       if (a == 2)
           Print(2)
       else
           Print("?")
       end
   end

In particular, a common error is the following:

    if (a == 1)
        Print(1)
    else if (a == 2)
        Print(2)
    else
        Print("?")
    end

This is missing an "end" statement (see the second form above).  

// (int)GetDims(array, aret)
//
// This returns the number of dimensions used in the array, and the
// size of each dimension in the aret array.  The size of aret must be
// MAXDIMS (3) or larger.  If the first argument is not an array, zero
// is returned.
//

Multi-D array stuff

array pointer <- 0 to reset refcnt

load_cb in gtkdebug.cc

Multi-dimensional arrays are now suported.
Xic provides arrays with up to three dimensions.  The indices are specified
as comma-separated expressions enclosed in square brackets which follow
the variable name, as in x[c,d] for a two dimensional array.  The higher
dimensions appear to the right, so that "c" in the example is the "fast"
index.

Declaring and defining arrays

Arrays must be declared either by initial assignment, or by a line consisting
of the array name followed by square-bracketed indices representing the
maximum index in each dimension.  In each case, the number of comma-separated
indices sets the dimensionality of the array.  The indices must be integers
and not expressions in the definition.

Examples
    x[2, 4]
    # This defines an array x: five blocks of three values

    x[2, 4] = some_expression.
    # This likewise defines the array, and additionally sets the highest
    # index to the result of an expression

Once an array has been defined, subsequent use allows expressions as the
the index values.

Dynamic resizing

In an assignment, if an index is given that is "too large", the array
will be reconfigured so that the new data point will be included.  The
existing data in the array will remain.

Example
    x[2, 4]
    x[3, 0] = 2
    # The array is now sized as if declared with "x[3,4]"

After the assignment, the maximum index for each dimension will be the
larger of the previous index and the assigning index.

When assigning values to an array, dimensional indices that are omitted
are taken as zero, though at least one value must be supplied.

Example
    x[2, 4]
    x[1] = 3
    # this is equivalent to x[1,0] = 3

This treatment of missing indices only applies in assignment, and *not*
in general references, as will be seen below.

There is one important restriction on dynamic resizing: arrays that have
pointer variables pointing at them can not be resized, and arrays can not
be resized through a pointer.  Pointers are described below.

The GetDims() function can be used to obtain the current dimensions of
an array.

Pointers

A pointer to an array is a variable which points to the data of
an array, and behaves as an array itself but does not contain its
own data.  Pointers can point to the array itself, or to a sub-array
of an array with multiple dimensions, or to an offset into the data of
a single dimensional array.

The simplest case is a direct assignment to an array.
    x[2, 4]
    y = x

In this case, the data (held in x) can be accessed through y or x
equivalently.

A more interesting case is provided through use of the overloaded
'+' operator.  For example
    x[2, 4]
    y = x + 1

In this construct, the offset is into the highest dimension of x, and
the return value is the sub-array found at this offset.  In the example,
y is a "y[2]" which is located at the address of x[0,1], i.e.,
y[0] = x[0, 1], y[1] = x[1, 1], y[2] = x[2, 1].

If x is a single dimensional array, y would also be a single dimensional
array, but accessing the data through the offset.  For example
    x[32]
    y = x + 10

Then y[0] = x[10], y[1] = x[11], etc.

In general references, but *not* assignments, supplying a smaller number
of dimensions to an array will return a sub-array.  For example,
    x[2, 4]
    y = x[1]

This is equivalent to "y = x + 1", and y will point to a "y[2]" at the
location of x[0,1].
    x[2,4,5]
    y = x[2]
    z = x[3,4]

The variable y is a "y[2,4]" located at x[0,0,2].  The variable z is
a "z[2]" located at x[0,3,4].

When a pointer is defined, a reference count is incremented in the pointed-to
array.  When this reference count is nonzero, the array can not be resized
through the dynamic resizing mechanism.  The pointers to an array must be
reassigned or undefined to allow resizing of the array.  Pointers can be
reassigned simply by changing them to point to a different array.  This
can be done arbitrarily.
    x[2, 4]
    y[32]
    z = x + 1
    # can't resize x here
    z = y
    # now ok to resize x

One can undefine a pointer by setting it to 0.  Once this is done, the pointer
variable has no type, and can actually be reused as another type of variable.
It is *not* an integer unless it is assigned to an integer.
    x[2, 4]
    y = x + 1
    # can't resize x here
    y = 0
    # now ok to resize x
    Print(y)
    # will give "y", y has no type and acts like a string
    y = 0
    Print(y)
    # will give "0", y is now an integer

In our initial case,
    x[2, 4]
    y = x

where the pointer is simply a reference to the array, y is not strictly
speaking a pointer.  In particular, this has no limitation on resizing.
The array data can be resized through y or x.  Thus, arrays can be
resized from within function calls if the reference to the array itself
is passed to the function, and not a pointer (with an offset).

Fixed the Monitor panel in the script debugger to handle multi-dimensional
arrays.  When specifing an array variable, the variable name can be
followed by a range specification, enclosed in square brackets, as
follows:

    [rmin-rmax,dim1,dim2]

This is entirely optional, as are the individual entries.  The three comma
separated fields corresponds to the three dimensions (maximum) of the array.
The lowest dimension can be a range, where rmin and rmax set the range of
indices to print or set.  The remaining two fields are indices into the
higher dimensions.  These indices are taken as 0 if not given.
One of the range values can be omitted, with the following interpretations:
    [rmin, ...        Use the single index rmin
    [rmin-, ...       Use the range rmin to the length of the lowest dimension
    [-rmax, ...       Use the range 0 - rmax

White space can appear, and the commas are optional, except in the second
form above where a comma must follow the '-'.

A similar range specification can be applied to string variables.  In this
case, only the first field is relevant, and the range applies to character
positions.
-------------------------------------------------------

The HTML viewer and text editor pop-ups now respond to the mouse wheel
when the pointer is in the window by scrolling.


Fixed an internal logic problem in interactive DRC.  Under some
circumstances, an unrelated previous error, most notably a MinArea or
MaxArea violation, would be ascribed to an object just added.

note- FindPhysLayer() is used too much in DRC tree eval.
Since layers are never freed, put pointer in parse node somehow.

Fix msw BreakLoop member funcs

// (real) MilliSec()
//
// Return the elapsed time in milliseconds since midnight January 1,
// 1970 GMT.


// (int) Redraw(win)
//
// This function will redraw the window indicated by the argument,
// which is 0 for the main window or 1-4 for the sub-windows.  The
// function fails if the argument does not correspond to an existing
// window.

// (int) SetGrid(interval, snap, win)
//
// This function sets the grid parameters for the window indicated by
// the third argument, which is 0 for the main window or 1-4 for the
// sub-windows.  The interval argument sets the grid line spacing, in
// microns.  The snap number supplies the number of snap points
// per grid intervals if positive, or the number of grid intervals
// per snap point if negative.  Values from -10 - 10 are accepted
// for this parameter.  Values of 0.01 or larger are valid for the
// interval, if not 0.  Either argument can be 0, in which case the
// present parameter is retained.  The function fails if the window
// argument does not correspond to an existing window.
//
// The function does not redraw the window.  The Redraw() function
// can be called to redraw the window if necessary.

// (int) GetGridSnap(win)
//
// This function returns the snap number for the grid in the window
// specified by the argument, which is 0 for the main window or 1-4
// for the sub-windows.  The snap number determines the number of snap
// coordinates between grid intervals if positive, or grid intervals
// per snap coordinate if negative.  The function fails if the
// argument does not correspond to an existing window.

// (int) GetGridInterval(win)
//
// This function returns the grid interval in microns for the grid in
// the window indicated by the argument, which is 0 for the main
// window or 1-4 for the sub-windows.  The function fails if the
// argument does not correspond to an existing window.

// (real) ClipToGrid(coord, win)
//
// The first argument to this function is a coordinate in microns. 
// The return value is the coordinate, in microns, snapped to the
// nearest snap point of the grid of the window given in the second
// argument.  The second argument is 0 for the main window, or 1-4 for
// the sub-windows.  The function fails if the window argument does
// not correspond to an existing window.

// (int) GetKey()
//
// This function blocks until any key is pressed.  The return value is
// a key code, which is system dependent, but is generally the "keysym"
// of the key pressed.  If the value is less than 20, the value is an
// internal code.
//
// (handle) FlatObjGenLayers(l, b, r, t, depth, layers)
//
// This function is very similar to FlatObjGen(), however it returns
// objects from layers named in the layers string.  If the string is
// null or empty, objects on all layers will be returned.  Otherwise,
// the string is a space separated list of layer names.  The names are
// expected to match layers in the current display mode.  Names that
// do not match any layer are silently ignored, though the function
// fails if no layer can be recognized.

// (int) IsLayerConductor(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if the Conductor keyword is
// given or implied for the layer, 0 otherwise.
//
// (int) IsLayerRouting(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if the Routing keyword is
// given for the layer, 0 otherwise.
//
// (int) IsLayerGround(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if one of the GroundPlane
// keywords was given for the layer, 0 otherwise.
//
// (int) IsLayerContact(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function return 1 if the Contact keyword is
// given for the layer, 0 otherwise.
//
// (int) IsLayerVia(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if the Via keyword is given
// for the layer, 0 otherwise.
//
// (int) IsLayerDarkField(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if the DarkField keyword is
// given or implied for the layer, 0 otherwise.
//
// (int) getLayerVisible(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns 1 if the layer is currently
// visible, 0 otherwise.
//
// (int) SetLayerVisible(lname)
//
// The first argument is a string giving the name of a layer in the
// current display mode.  If the string is empty or null, the current
// layer is understood.  The function will fail if a name is given
// which is not a layer name.  The second argument will set the layer
// visibility, visible if nonzero, invisible otherwise.  The previous
// visibility status is returned.
//
// (int) GetLayerMinDimension(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The return value is the minimum dimension in microns
// for the layer.  This is obtained from the applied design rules.
//
// (int) GetLayerWireWidth(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the default wire width for the
// layer.
//
// (int) GetLayerThickness(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the value of the Thickness
// parameter given for the layer, if any.
//
// (int) GetLayerRho(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the resistivity of the layer as
// given by the Rho or Sigma parameters, if given.
//
// (int) GetLayerEps(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the relative dielectric constant
// for the layer, as given by the EpsRel parameter if applied.
//
// (int) GetLayerLambda(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the value of the Lambda
// parameter for the layer, if given.
//
// (int) GetLayerResis(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the value of the Resistance
// parameter for the layer, if given.
//
// (int) GetLayerCap(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the per-area capacitance for the
// layer, if given.
//
// (int) GetLayerCapPerim(lname)
//
// The argument is a string giving the name of a layer in the current
// display mode.  If the string is empty or null, the current layer is
// understood.  The function will fail if a name is given which is not
// a layer name.  The function returns the per-perimeter capacitance
// for the layer, if given.

// (int) NumHandles()
//
// This returns the number of handles currently in the hash table.  It
// can be used as a check to make sure handles are being properly
// closed in the user's scripts.
//

file hhh1

check msw dynamic_cast returns

Major code audit to add the "const" modifier where appropriate.

Fixed a core leak in the DRC generator functions.

Fixed data alignment problem in Solaris server-mode interface.

Reorganized the script function interface, xicfuncs.cc -> xicf1.cc/xicf2.cc
-----

changed, used to always return 0, unless a file handle and the system
close() call fails.
// (int) Close(handle)
//
// This function deletes and frees the handle.  It can be used to free
// up resources when a handle is no longer in use.  In particular, for
// file handles, the underlying file descriptor is closed by calling
// this function.  The return value is 1 if the handle is closed
// successfully, 0 if the handle is not found in the internal hash
// table or some other error occurrs.
//
----------------------------------------------------------------

The script parser now accepts forms where there is no space between
a keyword and the rest of the line, for example if(...)  and while(...).

If a break line had a semicolon, as in
    if (xxx)
        break;
    end
it would not be recognized, and there was no error message.  Although a
semicolon does not belong here, it may be habitual for C programmers.
This is now "safe".


// (object_handle) FlatOverlapList(object_handle, touch_ok, depth, layers)
//
// This function returns a handle to a list of objects that touch or
// overlap the object referenced by the object_handle argument.  If
// touch_ok is nonzero, objects that touch but have zero overlap area
// will be included; if touch_ok is zero these objects will be
// skipped.  The depth argument is the depth to search in the
// hierarchy.  This can be a number 0 or larger (0 represents the
// current cell only), or a string beginning with the letter 'a' which
// indicates to search all cells.  If depth is not 0, the objects
// returned are transformed copies, otherwise the actual objects are
// returned.  The copies have restrictions as described in the
// description of the FlatObjList() function.  The layer argument is a
// string containing space-separated layer names of the layers to
// search for objects.  If this is empty or null, all layers will be
// searched.  The function fails if the handle argument is not a
// handle to an object list.  The return value is a handle to a list
// of objects, or 0 if no overlapping or touching objects are found.
//
// Only boxes, polygons, and wires are returned.  The reference object
// can be any object.  If the reference object is a subcell, objects
// from within the cell will be returned if depth is nonzero.
//
// (object_handle) FlatGenNext(handle)
// 
// This function takes as an argument the handle returned from
// FlatObjGen() or FlatObjGenLayers(), and returns an object handle

*** replace all text for these functions

FlatObjList second para
// The return value is a list of box, polygon, and wire objects found
// in the given region on the current layer.  Label and subcell   
// objects are never returned.  If depth is 0, the actual object 
// pointers area returned in the list, and all of the object
// manipulation functions are available.  Otherwise, the list
// references copies of the actual objects.  A list of copies behaves
// in most respects like an ordinary object list, except that the
// objects can not be modified.  The functions that modify objects
// will fail quietly (returning 0).  The ObjectCopy() function can be
// used to create a new database object from a returned copy.  The 
// returned copies can be used in the first argument to the clipping 
// functions such as ClipTo(), but not the second.  The handle
// manuipulation functions such as HandleCat() work, but lists of
// copies can not be mixed with lists of database objects, HandleCat()
// will fail quietly if this is attempted.  Copies can not be
// selected.

FlatObjGen add third para
// If depth is 0, the object pointers returned from FlatGenNext()
// represent the actual object, and all object manipulation functions
// are available.  Otherwise, transformed copies of the actual objects
// are returned, and there are restrictions on the operations that can
// be performed.  See the description of the FlatObjList() function
// for more information.

FlatGenNext first para
// This function takes as an argument the handle returned from
// FlatObjGen() or FlatObjGenLayers(), and returns an object handle
// which contains a single object returned from the generator.  If the
// depth argument passed to these functions was nonzero, The object is
// a copy, and the comments regarding object copies the description of
// the FlatObjList() function apply.  The returned handles should be
// closed after use by calling Close(), or by calling an iterating   
// function such as HandleNext() or ObjectNext().



Under Linux and Windows, the FPU is now operated in "double precision"
mode, rather than "extended precision mode".  This should not have any
visible effect, but ensures that numerical results are the same for
all supported platforms.  See www.wrcad.com/linux_numerics.txt for more
information.

// (int) DupArray(dest_array, src_array)
// 
// This function duplicates the src_array into the dest_array.  The
// dest_array argument must be an unreferenced array.  Upon successful
// return, the dest_array will be a copy of the src_array, and the
// return value is 1.  If the dest_array can not be resized due to its
// being referenced by a pointer, 0 is returned.  The function will
// fail if either argument is not an array.


Fixed two core leaks in scripts
1)  In functions, if an interface function is called that returns a string, the return
    string was not being freed when the function returns.
2)  Forms like  s = 1 + func_returning_string() would produce a core leak.

Fixed problems with the return from functions using the "return" statement.
Previously, it was possible to return a pointer to a local object in the
function, which would likely cause a segmentation fault if used.  There is
no problem with returning scalars.  Any string can be returned, local
strings will be copied.  An array pointer return must point at one of the
function arguments, or to a local static array, otherwise a run-time error
is reported.
--------------------------------------------------------------------------

Xic now has an interface to Tcl/Tk.  Tcl (Tool control language) is a
popular open source scripting language, and Tk ia a graphical package
addition.  Since this capability is dynamically loaded, Xic can use this
capability if it has been installed, but does not require the installation.

If the Tcl/Tk libraries are installed in the standard location
(/usr/local/lib), the libraries should be found automatically.  If
these libraries are installed elsewhere, the following variables
should be set to indicate the locations to Xic.

    !set TclLibrary path_to_tcl
    !set TlLibrary path_to_tk

The path_to... are the pull paths to the libraries.  These can be added to
a .xicstart file, or to the technology file.

The !tk command is used to execute a Tcl/Tk script.  The language syntax
is provided in documentation supplied with Tcl/Tk, and is descriptd in

   Tcl and the Tk Toolkit, John K. Ousterhout, Addison-Wesley

The command syntax is

    !tk script_path arguments...

where script_path is a path to a file containing the script, and any
arguments follow.  The script will be executed as if by the wish shell
supplied with Tcl/Tk.

The startup file, which can be used to set defaults, is named
".xic-wishrc" in the user's home directory.  The contents is analogous
to the .wishrc file normally used with Tcl/Tk.

The interface functions for Xic scripts are available in Tcl/Tk in the
form
     xic function arguments...

The xic function is a Tcl function which loads the script function given
in the second argument.  The arguments to the function follow, and should
match the arguments expected by the function.  Argument typing is set by
the argument:

   a numeric value is taken as a scalar
   a token of the form &arrayname() is taken as an array
   anything else is taken as a string (a double-quoted number is a string)
***  need \

Arrays passed to interface functions must use "0", "1", etc as
indices, and are ordered accordingly (in Tcl, array indices are
generally any text token and have no natural order).  The "0" element
(at least) must be set before the array can be passed to a function. 
If the array is dynamically expanded, new Tcl elements will be
created.  The initial size of the array is implied by the largest
contiguous index assigned.  Thus, for example, if the interface
function requires an array of size 4, the following Tcl code could be
used

    set array(0) 0
    set array(1) 0
    set array(2) 0
    set array(3) 0
    xic Function &array()

When the function returns, the array values will be updated.

The TextCmd() script function can be used to launch a Tcl/Tk script.
At present, Tcl/Tk scripts are not recognized in the script path, so
one can use a native language wrapper to include Tck/Tk scripts in the
User Menu.

***** FlatGenCount()    

Only 1d arrays supported.

HandleDup and HandleDupNitems now work for generator handles.


// (int) FlatGenCount(handle)
//
// This function returns the number of objects that can be generated
// with the generator handle passed, which must be returned from
// FlatObjGen() or FlatObjGenLayers().  Generator handles do not cache
// an internal list of objects, so that the number of objects is
// unknown, which is why HandleContent() returns 1 for generator
// handles.  This function duplicates the generator context and
// iterates through the loop, counting returned objects.  This can be   
// an expensive operation.
//

New keyword in scripts: global

The global keyword is used to declare a variable that is global in scope,
i.e., it is accessible in all functions where it has been declared.
The syntax is similar to the static keyword syntax, and similarly declaration
must appear at the top of a function.

   global var1 [= value] var2 ...

A global variable must be declared in each function where it is to be
accessed.  Assignments can be applied in the declarations in the main
procedure.  It is an error to declare a global with assignment more than
once.

  Example:

  function myfunc()
    global gvar
    Print(gvar)
    gvar = gvar + 1
  endfunc

  global gvar = 1
  myfunc()
  Print(gvar)
  # output is:
  # 1
  # 2


// (string) TypeOf(variable)
// 
// This function returns a string which indicates the type of variable
// passed as an argument.  The possible returns are
//  "none"       variable has no type
//  "scalar"     variable is a number
//  "string"     variable is a string
//  "array"      variable is an array
//
// (int) ArrayDims(out_array, array)
//
// This function returns to dimensions of an array.  The out_array is
// an array of length at least three which receives the dimensions of
// the array.  Unused dimensions are returned as zero.  The size of
// the array (number of storage locations) is returned by the
// function.
//

// (file_handle) Sopen(host, port)
// 
// This function opens a "socket" which is a communications channel to
// the given host and port.  If the host string is null or empty, the
// local host is assumed.  The port must be provided, there is no
// default.  If the open is successful, the return value is larger
// than zero and is a handle that can be used in any of the read/write
// functions that accept a file handle.  The Close() function should
// be called on the handle when the interaction is complete.  If the
// connection fails, a negative number is returned.  The function
// fails if there is a major error, such as no BSD sockets support.

Fixed bug: in scripts, the break statement logic was not right when
breaking out of a a loop with the following form:

    while (...)
       if (...)
           break
       end
       statement
    end

The while block is top level.  The statement would be executed, incorrectly,
after the break was in scope.

in ReadLine and ReadChar, if there is a read error, such as from a closed
socket, the functions now return a null string and EOF (-1) respectively.
Previously, a run-time error was generated, which terminates the script.
Similarly, WriteLine and WriteChar will return 0 rather that generate a
run-time error is the write fails.

win_id in !display can be hex (0x...), octal (0...) or decimal.

Window now returns 1/0
Redraw ditto
SetGrid
GetGrid
GetGridSnap

// (int) GetWindowView(window, array)
//
// This function returns the view area (visible cell coordinates) of
// the given window, which is an integer 0-4 where 0 is the main
// window and 1-4 represent subwindows.  The view coordinates, in
// microns, are returned in the array, in order l, b, r, t.  On
// success, 1 is returned, otherwise 0 is returned and the array is
// untouched.
//
// (int) GetWindowMode(window)
//
// This function returns the display mode of the given window, 0 for
// physical mode, 1 for electrical, or -1 if the window does not
// exist.  The argument is an integer 0-4, where 0 represents the main
// window and 1-4 indicate subwindows.  The return for window 0 (the
// main window) is the same as the return from CurMode().
//
// (int) Seed(value)
// 
// This function applies a seed to the random number generators.  This
// can be used to ensure that successive runs using random numbers
// choose different values.  The seed value is converted to an integer.
//
// (real) Random()
//
// This returns a random value in the range [0-1), which can
// optionally be seeded with the Seed() function.  The numbers
// generated have a uniform distribution.
//
// (real) Gauss()
//
// This returns Gaussian random numbers with zero mean and unit deviation.
//

text change - Display()

free handles adter !tk, other cleanup issues?

All GR functions - see xicf1.cc
--------------------------------------------------------------------------

To get dlopen() to work for xic-linux under FreeBSD emulation for !tk,
  setenv LD_LIBRARY_PATH /lib

In Set Grid pop-up, there is now a radio button group to set the
presentation style of the axes in physical mode.  The choices are
No Axes, Plain Axes, and Mark Origin.  The Mark Origin choice is
the default, and corresponds to the fixed presentation style of
previous releases.  The Plain Axes choice does away with the small
box at the origin, showing the axes as simple lines.  The No Axes
choice suppresses the axes entirely.  In electrical mode, the
axes are always suppressed.

New Techfile keywords
   Axes [ Plain | Mark | None ]
   AltAxes [ Plain | Mark | None ]

This determines the presentation style for the exes in physical mode.
The default is Mark, where the origin is marked with a small box.  If
Plain is given, the axes are simple lines.  If None is given, the axes
will not be drawn.

The Imlib hard copy driver has changed.  Previously, the size of the
image produced was somewhat arbitrary.  Now, the size must be specified
explicitly (100 pixels/inch), and the image will have this size.  The
Landscape and Best Fit functions are now available.

Audited the code for auto height/width in hard copy mode, fixed some
tiny bugs.  Some of the driver default values have changed, so it is
recommended that the driver blocks in custom technology files be updated.
This can be done with a text editor: replace the driver blocks at the end of
the tech file with those from one the distributed tech files.

// The following functions provide an interface for plot and graphical
// file output.  This is completely outside of the normal printing
// interface.

// (stringlist_handle) HCdrivers()
//
// This function returns a handle to a list of available printer
// drivers.  The returned handle can be processed by any of the
// functions that operate on stringlist handles.
//
// (int) HCsetDriver(driver)
//
// This function will set the current print driver to the name passed
// (as a string).  The name must be one of the internal driver names
// as returned from HCdrivers().  If the operation succeeds, the
// function returns 1, otherwise 0 is returned.
//
// (string) HCgetDriver()
//
// This function returns the internal name of the current driver.  If
// no driver has been set, a null string is returned.
//
// (int) HCsetResol(resol)
//
// This function will set the resolution of the current driver to the
// value passed.  The scalar argument should be one of the values
// supported by the driver, as returned from HCgetResols().  If the
// resolution is set successfully, 1 is returned.  If no driver has
// been set, or the driver does not support the given resolution, 0 is
// returned.
//
// (int) HCgetResol()
//
// This function returns the resolution set for the current driver, or
// 0 if no driver has been set or the driver does not provide settable
// resolutions.
//
// (int) HCgetResols(array)
//
// This function sets the array values to the resolutions supported by
// the current driver.  The array must have size 8 or larger.  The
// return value is the number of resolutions supported.  If no driver
// has been set, or the driver has fixed resolution, 0 is returned.
//
// (int) HCsetBestFit(best_fit)
//
// This function will set or reset the "best fit" flag for the current
// driver.  In best fit mode, the image will be rotated 90 degrees if
// this is a better match to the aspect ratio of the rendering area. 
// If the operation succeeds, 1 is returned.  If there is no driver
// set or the driver does not allow best fit mode, 0 is returned.  If
// the argument is nonzero, best fit mode will be set if possible,
// otherwise the mode is unset.
//
// (int) HCgetBestFit()
//
// This function returns 1 if the current driver is in "best fit"
// mode, 0 otherwise.
//
// (int) HCsetLegend(legend)
//
// This function will set or reset the "legend" flag for the current
// driver.  If set, a legend will be shown with the rendered image. 
// If the operation succeeds, 1 is returned.  If there is no driver
// set or the driver does not allow a legend, 0 is returned.  If the
// argument is nonzero, the legend mode will be set if possible,
// otherwise the mode is unset.
//
// (int) HCgetLegend()
//
// This function returns 1 if the current driver has the "legend" mode
// set, 0 otherwise.
//
// (int) HCsetLandscape(landscape)
//
// This function will set or reset the "landscape" flag for the
// current driver.  If set, the image will be rotated 90 degrees.  If
// the operation succeeds, 1 is returned.  If there is no driver set
// or the driver does not allow landscape mode, 0 is returned.  If the
// argument is nonzero, the landscape mode will be set if possible,
// otherwise the mode is unset.
//
// (int) HCgetLandscape()
//
// This function returns 1 if the current driver has the "landscape"
// mode set, 0 otherwise.
//
// (int) HCsetMetric(metric)
//
// This function sets a flag in the current driver which indicates
// that the rendering area is given in millimeters.  If not set, the
// values are taken in inches.  This pertains to the values passed to
// the HCsetSize() function.  If the operation succeeds, 1 is
// returned.  If there is no driver set, 0 is returned.  If the
// argument is nonzero, the metric mode will be set if possible,
// otherwise the mode is unset.
//
// (int) HCgetMetric()
//
// This function returns 1 if the current driver has the "metric"
// mode set, 0 otherwise.
//
// (int) HCsetSize(x, y, w, h)
//
// This function sets the size and offset of the rendering area.  The
// numbers correspond to the entries in the Print panel.  The values
// are scalars, in inches unless metric mode is in effect (with
// HCsetMetric()) in which case the values are in millimeters.  The
// values are clipped to the limits provided in the technology file. 
// Most drivers accept 0 for one of w, h, indicating auto dimensioning
// mode.  The function returns 1 on success, 0 if no driver has been
// set.  Not all drivers use all four parameters, unused parameters
// are ignored.
//
// (int) HCgetSize(array)
//
// This function returns the rendering area parameters for the current
// driver.  The array argument must have size 4 or larger.  The values
// are returned in the order x, y, w, h.  If the function succeeds,
// that values are set in the array and 1 is returned.  Otherwise, 0
// is returned.
//
// (int) HCdump(l, b, r, t, filename, command)
//
// This is the function which actually generates a plot or graphics
// file.  The first four arguments set the area in microns in current
// cell coordinates to render.  If these values are all 0, a full view
// of the current cell will be rendered.  The next argument is the
// name of the file to use for the graphical output.  If this string
// is null or empty, a temporary file will be used.  The last argument
// is a command string that will be executed to generate a plot.  If
// this argument is null or empty, the plot file will be generated,
// but no further action will be taken.  In the command string, the
// character sequence "%s" will be replaced by the file name.  If the
// sequence does not appear, the file name will be appended.  If
// successful, 1 is returned, otherwise 0 is returned, and an error
// message can be obtained with HCerrorString().
//
// HCerrorString()
//
// This function returns a string indicating the error generated by
// HCdump().  If there were no errors, a null string is returned.
//

Updated the internal functions that provide X-windows access capability,
which includes the exported graphics interface, and the imlib print driver.
The imlib driver is now available when Xic is in non-graphics (server or
batch) mode.

// (stringlist_handle) ListDirectory(directory, filter)
//
// This function returns a handle to a list of names of files and/or
// directories in the given directory.  If the directory argument is
// null or empty, the current directory is searched.  If the filter
// string is null or empty, all files and subdirectories will be
// listed.  Otherwise the filter string can be "f" in which case only
// regular files will be listed, or "d" in which case only directories
// will be listed.  If the directory does not exist or can't be read,
// 0 is returned, otherwise the retrun value is a handle to a list of
// strings.

// (stringlist_handle) HClistPrinters()
//
// Under Microsoft Windows, this function returns a handle to a list
// of printer names available from the current host.  The first name
// is the name of the default printer.  The remaining names,
// alphabetized, follow.  If there are no printers available, or if
// not running under Windows, the function returns 0.  The returned
// names can be supplied to the HCdump() function to initiate a print
// job.
//

// (int) ShowGrid(on, win)
// 
// This function sets whether or not the grid is shown in a window.
// If the first argument is nonzero, the grid will be shown, otherwise
// the grid will not be shown.  The second argument is an integer
// representing the drawing window:  0 for the main window, and 1-4
// for subwindows.  The change will not be visible until the window is
// redrawn (one can call Redraw()).  If success, 1 is returned, or 0
// is returned if the window does not exist.
//
// (int) ShowAxes(style, win)
//
// This function sets the axes presentation style in physical mode
// windows.  the first argument is an integer 0-2, where 0 suppresses
// drawing of axes, 1 indicates plain axes, and 2 (or anything else)
// indicates axes with a box at the origin.  The second argument is an
// integer representing the drawing window:  0 for the main window,
// 1-4 for subwindows.  Axes are never shown in electrical mode
// windows.  On success, 1 is returned.  If the window does not exist
// or is not showing a physical view, 0 is returned.  The change will
// not be visible until the window is redrawn (one can call Redraw()).
//
// (int) SetGridStyle(style, win)
//
// This function sets the line style used for grid rendering.  The
// first argument is an integer mask that defines the on-off pattern.
// The pattern starts at the most significant '1' bit and continues
// through the least significant bit, and repeats.  Set bits are
// rendered as the visible part of the pattern.  If the style is 0, a
// dot is shown at each grid point.  Passing -1 will give continuous
// lines.  The second argument is an integer representing the drawing
// window:  0 for the main window, 1-4 for subwindows.  The function
// returns 1 on success, 0 if the window does not exist.  The change
// will not be visible until the window is redrawn (one can call
// Redraw()).
//
// (int) GetGridStyle(win)
//
// This function returns the line style mask used for rendering the
// grid in the given window.  The mask has the interpretation
// described in the description of SetGridStyle().  The argument is an
// integer representing the window:  0 for the main window, and 1-4
// for subwindows.  If the window does not exist, 0 is returned.
//
// (int) SetGridOnTop(ontop, win)
//
// This function sets whether the grid is shown above or below
// rendered objects.  If the first argument is nonzero, the grid will
// be shown above rendered objects.  The second argument is an integer
// representing the drawing window:  0 for the main window and 1-4 for
// subwindows.  The function returns 1 on success, 0 if the window
// does not exist.  The change will not be visible until the window is
// redrawn (one can call Redraw()).
//
// (int) GetGridOnTop(win)
//
// This function returns 1 is the grid is shown on top of objects.
// The argument is an integer representing the drawing window:  0 for
// the main window and 1-4 for subwindows.  If the grid is shown below
// rendered objects, 0 is returned.  If the window does not exist, -1
// is returned.
//

// (int) SetButtonStatus(menu, button, set)
// 
// This command sets the status of the specified button in the given
// menu, which must be a toggle button.  If the third argument is
// nonzero, the button will be pressed if it is not already engaged.
// If the third argument is zero, the button will be depressed if it  
// is not already depressed.  The return value is 1 if the button
// state changed, 0 if the button state did not change, or -1 if the  
// button was not found.
//

SetButtonStatus(), etc, rewrite help

AskReal() parses hex numbers.

// (real) AskConsoleReal(prompt, default)
// 
// This function prompts the user for a number, in the console window.
// It is otherwise similar to the AskReal() function.
//
// (real) AskConsoleString(prompt, default)
//
// This function prompts the user for a string, in the console window.
// It is otherwise similar to the AskString() function.
//

MSW tinyb tooltip keyword

Added setsockopt(SO_REUSEADDR) call to aboid problem.  After running Xic
in server mode, one has to wait 60 seconds or so before running again,
while the system firgures out that the port address is no longer in use.
This should no longer happen.

// (stringlist_handle) ListFunctions()
// 
// This function will re-read all of the library files in the script
// search path, and returns a handle to a string list of the functions
// available from the libraries.
// 

check Solaris: server mode, calling nonexistant function, printing.

In server mode, the library files in the script path were not being read.
They are now read at program startup, and can be re-read with the
ListFunctions() script function.

(Windows Only)
The Windows Native driver can not be used in batch and server modes.

Giving the keyword "function" without a following name and arguments would
crash the program.

Clicking on the extension of a wire past the terminating vertex of
entended and rounded style wires would not select/deselect.
-----------------------------------------------------------------------
MSE mswnodmp.cc set sGroups = map

find_dev -> CDs::findInstance
set_dev_prpty ->sMain::SetDevicePrpty
get_dev_prpty ->sMain::GetDevicePrpty
set_mut  sMain::SetMutParam
get_mut  sMain::GetMutParam

fix mswnodmp.cc

// (int) DumpPhysNetlist(net, devs, spice, bdnet, depth, filename)
//
// This function dumps a netlist file extracted from the physical part
// of the database, much like the Dump Phys Netlist command in the
// Extract Menu.  The first four arguments are flags which determine
// the data fields included in the file.  If an argument is nonzero,
// the section will be included, otherwise not.  These correspond to
// the settings available in the Dump Phys Netlist command.  The depth
// argument specifies the depth of the hierarchy to process.  If an
// integer, 0 represents the current cell only, 1 includes the first
// level subcells, etc.  This argument can also be a string beginning
// with the letter 'a', which will process all levels of the
// hierarchy.  The final argument is a file name which will receive
// the output.  If null or empty, the file will be the base name of
// the current cell with ".physnet" appended.  If the function
// succeeds, 1 is returned, otherwise 0 is returned.
//
// (int) DumpElecNetlist(net, spice, bdnet, depth, filename)
//
// This function dumps a netlist file extracted from the electrical
// part of the database, much like the Dump Elec Netlist command in
// the Extract Menu.  The first three arguments are flags which
// determine the data fields included in the file.  If an argument is
// nonzero, the section will be included, otherwise not.  These
// correspond to the settings available in the Dump Elec Netlist
// command.  The depth argument specifies the depth of the hierarchy
// to process.  If an integer, 0 represents the current cell only, 1
// includes the first level subcells, etc.  This argument can also be
// a string beginning with the letter 'a', which will process all
// levels of the hierarchy.  The final argument is a file name which
// will receive the output.  If null or empty, the file will be the
// base name of the current cell with ".elecnet" appended.  If the
// function succeeds, 1 is returned, otherwise 0 is returned.
//
// (int) SourceSpice(alldevs, create, clear, filename)
//
// This function will parse a SPICE file, adding or updating the
// electrical part of the database with the devices and subcircuits
// found.  This is equivalent to the Source SPICE command in the
// Extract menu.  The first three arguments are flags corresponding to
// the modes described for the Source SPICE command:
//
//  all devs
//    If set, all devices in the cell which match a name in the SPICE  
//    file will be updated.  If not set, only the devices that have   
//    names that were set explicitly by the user (by applying a name   
//    property) are updated.
//
//  create
//    If set, devices specified in the SPICE file that are not found in
//    the schematic are created.  If not set, only the properties of
//    existing devices are updated.
//
//  clear
//    If set, the electrical part of a cell is cleared before reading
//    the SPICE input.  This implies 'create'.
//
// A nonzero argument implies that the corresponding flag is set.  The
// last argument is the name of the SPICE file to source.  If the
// operation succeeds, 1 is returned, otherwise 0 is returned.
//
// (int) ExtractAndSet(alldevs, create, clear, depth)
//
// This function performs extraction on the physical part of the
// database, updating the electrical part.  This is equivalent to the
// Source Physical command in the Extract Menu.  The first three
// arguments have the same intrpretation is for the SourceSpice()
// function.  The remaining argument indicates the depth of the
// hierarchy tor process.  This argument can be a non-negative integer
// (0 represents the current cell only), or a string beginning with
// the letter 'a' which means to process the full depth.  If the
// operation succeeds, 1 is returned, otherwise 0 is returned.
// This function does not redraw the windows.
//
// (int) Group()
//
// This function will run the grouping and device extraction algorithm
// on the current physical cell.  The grouping algorithm identifies
// the wire nets.  The returned value is the number of groups used, or
// 0 if an error occurrs.  The group index extends from 0 through the
// number returned minus one.  Group 0 is the ground group, if a
// ground plane layer has been defined.
//
// (int) GetGroupBB(group, array)
//
// This function returns the bounding box of the conductor group whose
// index is passed as the first argument.  The coordinates, in microns
// relative the the current physical cell origin, are returned in the
// array, which must have size 4 or larger.  If the function succeeds,
// 1 is returned, otherwise 0 is returned.
//
// (int) GetGroupNode(group)
//
// This function returns the node number from the electrical database
// which corresponds to the physical group index passed as the
// argument.  If the association failed, -1 is returned.
//
// (object_handle) ListGroupObjects(group)
//
// This function returns a handle to the list of objects in the
// current physical cell which constitute the group.  The argument is
// the group index.  The objects are copies, so can not be modified or
// selected.  The objects returned have been processed by the
// "Conductor Exclude" directive, so may not precisely correspond to
// the "real" objects in the database.  If an error occurs, 0 is
// returned.
//
// (dev_contact_handle) ListGroupDevContacts(group)
//
// This function returns a handle to the list of device contacts which
// are assigned to the conductor group whose index is passed as the
// argument.  If an error occurs, 0 is returned.
//
// (subc_contact_handle) ListGroupSubcContacts(group)
//
// This function returns a handle to a list of subcircuit contacts
// associated with the group index passed as the argument.  If an
// error occurs, 0 is returned.
//
// (stringlist_handle) ListGroupTerminals(group)
//
// This function returns a list of names of the formal terminals
// assigned to the conductor group whose index is passed as the
// argument.  If an error occurred, 0 is returned.  If the group
// contains no formal terminals, the list will be empty.
//
// (device_handle) ListPdevs(name, pref, index, l, b, r, t)
//
// This function returns a handle to a list of devices extracted from
// the physical part of the current cell.  The first two arguments are
// strings which match the Name and Prefix fields from the technology
// file Device block of the device to extract.  Either or both of
// these arguments can be null or empty, in which case no devices are
// excluded by the comparison.  The third argument is the device
// index, which can be used to select a particular device.  If this
// value is -1, any device index will be matched.  The remaining four
// arguments set the corners, in microns, of the rectangular area in
// the cell to search.  If all four values are zero, the entire cell
// is searched.  On succes, a handle is returned, otherwise 0 is
// returned.  The handle can be used in the functions that take a
// device handle as an argument.  This is *not* an object handle.  The
// returned device_handle can be manipulated with the generic handle
// functions, and like other handles should be iterated through or
// explicitly closed when no longer needed.
// 
// (string) GetPdevName(device_handle)
//
// This function returns a string containing the name of the device
// referenced by the handle.  The name string is composed of the Name
// field for the device (from the Device block), followed by an
// underscore, followed by the device index number.  If the handle is
// defunct or some other error occurs, a null string is returned.
//
// (int) GetPdevIndex(device_handle)
//
// This function returns the index of the device referenced by the
// handle passed as an argument.  The index is an integer which is
// unique among the devices of a given type.  If the handle is defunct
// or an error occurs, -1 is returned.
//
// (object_list) GetPdevDual(device_handle)
//
// The function returns an object_handle which references the dual
// device in the electrical database to the physical device referenced
// by the argument.  If association failed for the device, 0 is
// returned.  The dual device is a subcell obtained from the device
// library.
//
// (int) GetPdevBB(device_handle, array)
//
// This function obtains the bounding box of the device referenced by
// the first argument.  The coordinates, in microns using the origin
// of the current physical cell, are returned in the array, which must
// have size 4 or larger.  If the function succeeds, 1 is returned,
// otherwise the returned value is 0.  The saved order is L, B, R, T.
//
// (real) GetPdevMeasure(device_handle, mname)
//
// This function returns a device parameter corresponding to a Measure
// line given in the device block for the device referenced by the
// first argument.  The second argument is a string giving the name
// from a Measure line.  The returned value is the measured parameter,
// or 0 if there was an error.
//
// (stringlist_handle) ListPdevMeasures(device_handle)
//
// This function returns a string list handle corresponding to a list
// of the names associated with Measure lines in the Device block for
// the device referenced by the handle.  These are the names that can
// be passed to GetDevMeasure() to perform the measurement.  If an
// error occurs, 0 is returned.
//
// (dev_contact_handle) ListPdevContacts(device_handle)
//
// This function returns a handle to a list of contact descriptors for
// the device referenced by the argument.  The returned handle can be
// passed to the functions below to obtain information about the
// device contacts.  If there is an error, 0 is returned.  The
// returned handle can be manipulated with the generic handle
// functions, and like other handles should be iterated through or
// closed explicitly when no longer needed.
//
// (string) GetPdevContactName(dev_contact_handle)
//
// This function returns the name string of the contact referenced by
// the argument.  Contact names are assigned in the Device block for
// the device containing the contact.  If an error occurs, a null
// string is returned.
//
// (int) GetPdevContactBB(dev_contact_handle, array)
//
// This function returns the bounding box of the contact referenced by
// the first argument.  The coordinates, in microns relative to the
// origin of the physical current cell, are returned in the array,
// which numst have size 4 or larger.  If the operation is successful,
// 1 is returned, otherwise 0 is returned.
//
// (int) GetPdevContactGroup(dev_contact_handle)
//
// This function returns the conductor group index to which the
// contact referenced by the argument is assigned.  If there is an
// error, -1 is returned.
//
// (string) GetPdevContactLayer(dev_contact_handle)
//
// This furntion returns the name string of the layer to which the
// contact referenced by the argument is assigned.  All contacts are
// assigned to layers which have the Conductor attribute.  If there is
// an error, a null string is returned.
//
// (device_handle) GetPdevContactDev(dev_contact_handle)
//
// This function returns a handle to the device containing the contact
// referenced by the argument.  If an error occurs, 0 is returned. 
// The returned handle should be closed (for example, with the Close()
// function) when no longer needed.
//
// (subckt_handle) ListSubckts(name, index, l, b, r, t)
//
// This function returns a handle to a list of subcircuits from the
// physical part of the current cell.  Subcircuits are subcells which
// contain devices or sub-subcells that contain devices.  Subcells
// that contain only wire are typically not saved internally as
// subcircuits.  The first argument is a string name which will match
// the returned subcircuits.  If this argument is null or empty, then
// this test will not exclude any subcircuits to be returned.  The
// second argument is the index number of the subcircuit to be
// returned.  If the value is -1, subcells with any index will be
// returned.  The remaining four values define a rectangular area,
// given in microns relative the the current physical cell origin,
// where subcircuits will be searched for.  If all four values are 0,
// the entire cell will be searched.  The returned handle references
// subcircuits, and is distinct from device handles and object
// handles.  The handle can be passed to the generic handle functions,
// and like other handles should be iterated through or closed when no
// longer needed.  The function returns 0 if an error occurs.
//
// (string) GetSubcName(subckt_handle)
//
// This function returns the cell name corresponding to the subcircuit
// referenced by the handle.  if an error occurs, a null string is
// returned.
//
// (int) GetSubcIndex(subckt_handle)
//
// This function returns the index of the subcircuit referenced by the
// argument.  If an error occurs, -1 is returned.
//
// (object_handle) GetSubcDual(subckt_handle)
//
// This function returns an object handle which references the subcell
// in the electrical database which is the dual of the physical
// subcircuit referenced by the argument.  If the association fails, 0
// is returned.
//
// (int) GetSubcBB(subckt_handle, array)
//
// This function returns the bounding box of the subcircuit referenced
// by the first argument.  The coordinates, in microns relative to the
// origin of the current physical cell, are returned in the array,
// which must have size 4 or larger.  If the operation succeeds, 1 is
// returned, otherwise 0 is returned.
//
// (subc_contact_handle) ListSubcContacts(subckt_handle)
//
// This function returns a handle to a list of subcircuit contacts
// associated with the subcircuit referenced by the handle.  The
// returned handle is a distinct type, in particualr subcircuit
// contacts are different from device contacts.  The return handle can
// be used with the functions which query information about subcircuit
// contacts, or with the generic handle functions.  If an error
// occurs, this function returns 0.
//
// (int) GetSubcContactGroup(subc_contact_handle)
//
// This function returns the group index in the current cell
// corresponding to the subcircuit contact referenced by the argument. 
// If an error occurs, this function returns -1.
//
// (int) GetSubcContactSubcGroup(subc_contact_handle)
//
// This function returns the group index in the subcircuit associated
// with the subcircuit contact referenced by the argument.  On error,
// the function returns -1.
//
// (subckt_handle) GetSubcContactSubc(subc_contact_handle)
//
// This function returns a handle to the subcircuit which is
// associated with the subcircuit contact referenced by the argument. 
// On error, the function return 0.
//
// (int) EnableNodeMap(on)
//
// This function sets whether or not node name mapping is used in
// netlist output from the electrical database.  If the argument is
// nonzero, node mapping is set, and assigned node names will be used
// in output.  Otherwise, the node names will be the internally
// assigned node numbers.  This function returns 1 on success, 0
// otherwise.
//
// (int) SetNodeName(node, *name)
//
// This function associates the string name with the node number given
// in the first argument.  This effects the electrical database, and
// is equivalent to setting a node name with the node mapping facility
// available in the side menu in electrical mode.  When node mapping
// is enabled, netlist output will use the given string name rather
// than the node number.  Since the node number is set internally, it
// can vary, whereas the given name is fixed.  If the name given is
// null or empty, any existing given name is deleted, and netlist
// output will use the node number.  The function returns 1 on
// success, 0 otherwise.
//
// (string) GetNodeName(node)
//
// This function returns a string name for the given node number.  If
// a name has been given for that node, the name is returned,
// otherwise the string will consist of the node number.  This will
// return the mapped name whether or not node mapping is enabled.  If
// the operation failed, a null string is returned.
//
// (int) GetNodeNumber(string)
//
// This function returns the node number corresponding to the name
// string passed as an argument.  If no mapping to the string is
// found, -1 is returned.
//
// (int) GetNodeGroup(node)
//
// This function returns the group index in the physical cell that
// corresponds to the given node number.  On error, -1 is returned.
//
// (stringlist) ListNodeTerms(node)
//
// This function returns a string list of the terminal names tied to
// the given node number.  These come from the electrical database. 
// If an error occurs, 0 is returned.
//
// (stringlist_handle) ListEdevs(regex)
//
// This function returns a handle to a list of strings containing
// device names from the electrical database.  The names correspond to
// devices used in the current circuit.  The argument is a regular
// expression used to filter the device names.  If the argument is
// null or empty, all devices are listed.  This function returns 0 on
// error.
//
// (int) SetEdevProperty(devname, prpty, string)
//
// This function is used to set property values of electrical devices
// and mutual inductors.  It is equivalent to the Set() command, or
// the keyboard !set command, with the @devname.prpty syntax.  The
// first argument is the name of a device in the current circuit. 
// This is the value of a Name property for some device.  The second
// argument is a string giving the property type to set or modify. 
// The possible strings are "model", "value", "initc", "other". 
// Actually, only a prefix to these strings is required, so that "m",
// "v", etc.  are accepted.  If the string is unrecognized, thr
// property type defaults to "other".  If the device is a mutual
// inductor, only the "name" and "value" properties can be applied. 
// The final argument is a string containing the body of the property. 
// If the string is null or empty, the property is removed (or reset
// to the default in the case of the "name" property).  The function
// returns 1 on success, 0 otherwise.
//
// (string) GetEdevProperty(devname, prpty)
//
// This function returns a string containing the text of of the
// specified property for the given device.  The two arguments have
// the same format and interpretation as the first two arguments of
// SetDevproperty(), i.e., the device name and property name.  The
// return value is a string containing the text for that property.  If
// the device or property does not exist or some other error occurs, a
// null string is returned.
//
// (object_handle) GetEdevObj(name)
//
// This function returns a handle to the electrical subcell from the
// device library corresponding to the given device name.  If an error
// occurs, 0 is returned.
//

// (regex_handle) RegCompile(regex, case_insens)
//
// This function returns a handle to a compiled regular expression, as
// given in the first argument.  The handle can be use for string
// comparison in RegCompare(), and should be closed when no longer
// needed.  The second argument is a flag; if nonzero the regular
// expression is compiled such that comparisons will be
// case-insensitive.  If zero, the test will be case-sensitive.  If
// the compilation fails, this function returns 0, and an error
// message can be obtained from RegError().
//
// (int) RegCompare(regex_handle, string, array)
//
// This function compares the regular expression represented by the
// handle to the string given in the second argument.  If a match is
// found, the function returns 1, and the match location is set in the
// array argument, unless 0 is passed for this argument.  If an array
// is passed, it must have size 2 or larger.  The 0'th array element
// is set to the character index in the string where the match starts,
// and the next array location is set to the character index of the
// first character following the match.  This function returns 0 if
// there is no match, and -1 if an error occurs.  If -1 is returned,
// an error message can be obtained from RegError().
//
// (string) RegError(regex_handle)
//
// This function returns an error message string generated by the
// failure of RegCompile() or RegCompare().  It can be called after
// one of these functions returns an error value.  The argument is the
// handle value returned from RegCompile(), which will be 0 if
// RegCompile() fails.  A null string is returned if the handle is
// bogus.
//
changed----
// (int) PrptyAdd(object_handle, number, string)
// 
// This function will create a new property using the number and
// string provided, on the object referenced by the handle.  If the
// handle is 0, the property will be created in the current cell.  The
// object must be defined in the curent cell.  Acceptable property
// numbers are:
// Physical cell:     0 - 6999, 7198 (Args), 7199 (Script), 7300 or larger
// Electrical cell:   7198 (Args), 7199 (Script)
// Physical object:   0 - 6999, 7198 (Args), 7200 or larger
// Electrical object: 7198 (Args) only
// Adding an Args or Script property will automatically remove the old
// property, if any.  Note that pseudo-properties can be supplied, and
// will be applied to physical objects.  
//
// It is also possible to set the name, model, value, initc, and other
// properties if the handle references an electrical device, or the
// name property if the handle references an electrical subcell.  In
// this case, the number argument is a *string*, and should be a
// prefix of "name", "model", "value", "initc", or "other".  If the
// string is not recognized, "other" is assumed.
  The object must be
// defined in the current cell, thus the mode must be electrical.

//
// If the function succeeds, 1 is returned.  otherwise 0 is returned.
//

// (int) PrptyRemove(object_handle, number, string)
//
// This function will remove properties matching the given number and
// string from the object referenced by the handle.  If the string is
// null or empty, only the number is used for comparison, and all
// properties with that number will be removed.  Otherwise, if the
// string is a prefix of the property string and the numbers match,
// the property will be removed.  If the handle value is 0, properties
// will be removed from the physical part of the current cell.  
//
// The name, model, value, initc, and other properties can be removed
// from an electrical device in electrical mode, and the name property
// can be removed from an electrical subcell in electrical mode.  In
// this case, the number argument is a *string*, which should be a
// prefix to "name", "model", "value", "initc", or "other".  If the
// string is not recognized, "other" is assumed.  Except for "other",
// the string argument is ignored.  For "other" properties, the string
// is used as above to identify the property to delete.
//
// Objects must be defined in the current cell.  The function returns 
// the number of properties removed.  Property numbers in the range   
// 7000 - 7299 are reserved and corresponding properties will not be 
// removed.
//

// (int) AddProperty(number, string)
//
// This function adds the property number and string to all selected
// objects.  Acceptable property numbers are:
// Physical object:   0 - 6999, 7198 (Args), 7200 or larger
// Electrical object: 7198 (Args) only
// Note that pseudo-properties can be supplied, and will be applied to
// physical objects.  The number of properties added plus
// pseudo-properties given is returned.
//
// It is also possible to set the name, model, value, initc, and other
// properties on electrical devices, or the name property on       
// electrical subcells.  In this case, the number argument is a     
// *string*, and should be a prefix of "name", "model", "value",
// "initc", or "other".  If the string is not recognized, "other" is
// assumed.  The mode must be electrical.
// 

// (int) RemoveProperty(number, string)
//
// The string argument can be passed 0, in which case this function
// will remove all properties with the number given from all selected
// objects (only for physical mode).  If a string is given, then only
// those properties for which string is a prefix of the value string
// will be removed.  Property numbers in the range 7000 - 7299 are
// reserved and corresponding properties will not be removed.  The
// number of properties removed is returned.
//
// The name, model, value, initc, and other properties can be removed
// from an electrical device in electrical mode, and the name property
// can be removed from an electrical subcell in electrical mode.  In
// this case, the number argument is a *string*, which should be a
// prefix to "name", "model", "value", "initc", or "other".  If the
// string is not recognized, "other" is assumed.  Except for "other",
// the string argument is ignored.  For "other" properties, the string
// is used as above to identify the property to delete.
tring) GetPropertyString(object_handle, number)
// 
// This function returns the strings from properties or
// pseudo-properties for the object referenced by the handle, or from
// the current cell if the handle is 0.  The function will locate a
// property with the given number, and return its string.  If no
// property is found with that number, and a pseudo-property for the
// object matches the number, then the pseudo-property string is
// returned.  Note that pseudo-properties are currently defined for
// objects, not cells.  If no matching pseudo-property is found, a
// null string is returned.  The function will fail if a nonzero
// handle argument does not reference a list of objects.  Note:
// objects can be modified through setting pseudo-properties using
// the PrptyAdd() function.
//
// The number argument can also be a string, in which case it should 
// be a substring of one of "name", "model", "value", "initc", or
// "other".  If the string is not recognized, "other" is assumed.
// This input is appropriate for obtaining preperty values from
// electrical devices.
//
/
// (string) GetProperty(prpty_handle, number)
// 
// This function returns the string of the first property referenced
// by the handle that matches the number.  If the number argument is a
// substring of "all", then any property string will be returned.  The  
// number argument can also be a substring of "name", "model",
// "value", "initc" or "other", which is appropriate for electrical
// devices.  If the string is not recognized, "other" is assumed.  The
// handle is set to reference the next property in the reference list,
// following the one returned.  When there are no more properties,
// this function returns a null string.
//

// (prpty_handle) GetPrpHandle(number)
// 
// Since there can be arbitrarily many properties defined with the
// same number, a generator function is used to read properties one at
// a time.  This function returns a handle to a list of the properties
// that match the number (integer) passed.  This applies to the first
// object in the selection queue (the most recent object selected).
// The returned value is used by other functions to actually retrieve
// the property text.
// 
// If the number argument is a prefix of "all", then any property
// string will be returned.  The number argument can also be a
// substring of "name", "model", "value", "initc" or "other", which is
// appropriate for electrical devices.  If the string is not
// recognized, "other" is assumed.
//

Bug: redisplay of subcells was leaving out layers on occasion due to an
"optimization" added in 2.4.59.

all text windows now handle mouse wheel
Cells list now resets columns when resized
GTK file selection pop-up:
  1)  Files list now scrolls with mouse wheel events
  2)  If the window is resized, the text is drawn with recomputed columns
-------------------------------------------------------------------

The Source SPICE, Source Physical, Dump Phys Netlist, and Dump Elec Netlist
commands have new pop-ups.  The only difference is that the depth parameter
is on the pop-up, in the form of a menu which allows a choice of depth
0-5 and "all".  This avoids the prompting.

The Attributes Menu (in both the main window and subwindows)
has a new Cell Name True Orient entry.  This is sensitive
only when the Show Cell Names entry is selected.  When Cell Name True Orient
is active, the cell names shown in unexpanded instances will be rotated and
mirrored the same as the cell.  If unset, the names will always be in
legible orientation.  It is simetimes useful to have names transformed,
as one can see instantly which cells are mirrored, etc.  This replaces the
yes/no dialog that appeared after turning Show Cell Names on.

The transform cell labels function wasn't working.

There is a new Label True Orient command button in the Attributes Menu (both
main window and subwindows).
This in only sensitive when labels are being displayed.  When set, labels
will be shown in their true orientation, i.e., rotated, mirrored, etc.
If not set, labels will always be shown in a "legible" orientation.

In the Tevhnology file, the LabelAllInstances keyword is not an integer,
not a boolean.  The values are
  0             don't show labels
  2             show labels in true orientation
  anything else show labels legibly
These apply to the main window in both physical and electrical modes.

The LabelTrueOrient internal !set variable has been decomissioned.  Xic no
longer regognizes this variable.

*** fix preferences script

The Flatten command now has a pop-up that enables setting the depth to flatten
and whether of not to use "fast mode".  This avoids the prompting that was
used previously.

XXX depth 0
XXX toggle btn in menu

** add help btns


The Transform Menu is gone.  There is a new Current Transform button in the
Edit Menu which brings up a panel which allows the transform to be set.
This has buttons to set the mirror, an object for setting the angle, and
a spin button for setting the magnification.  There are five sets of
store/recall buttons allowing up to five transform settings to saved.
The Inentity Transform button clears the transform parameters, and the
Last Transform button sets the parameters to what they were before the
last recall or clear.

This may break scripts, sorry.  The SetTransform() script function should
replace script code that "presses" buttons in the old Transform Menu.

xic:transfmenu   xic:xform
xic:reflx        xic:xform#reflx
xic:refly        xic:xform#refly
xic:rotate       xic:xform#rotate
xic:magn       xic:xform#magn
xic:ident       xic:xform#ident
xic:reset       xic:xform#last

Pressing Shift while pressing numeric keypad +/- keys modifies the
zoom-in/zoom-out to 10% change.
IMPORTANT: If you have a xic_keymap.xxx file, you will need to delete it
and build a new one (with Attributes/Key Map) or the new binding will not
work.
---

The Set Limits and Set Level commands in the DRC Menu have been replaced by
a Set Defaults command.  The new command brings up a pop-up which allows the
following parameters to be set:
   The number of errors to allow in batch mode testing before aborting
   The maximum number of objects to test in interactive mode
   The time limit for interactive mode testing
   Whether or not to skip subcell testing in interactive mode
   The error recording level

Set Flags -> Set Skip Flags (tooltip change)
Set Interactive ->Enable Interactive (tooltip change)

Fixed types in variable names in preferences script
NoMapDataTypes -> NoMapDatatypes
NoGdsMapOK -> NoGdsMapOk
** check for more

scripts:
DRClevel -> DRCsetLevel

xic:level defunct

// (int) DRCsetLimits(batch_cnt, intr_cnt, intr_time, skip_cells)
//
// This function sets the limits used in design rule checking.  Each
// argument, if negative, will cause the related value to be unchanged
// by the function call.  For the first three arguments, the value "0"
// is interpreted as "no limit".
//
// batch_cnt:  This sets the maximum number of errors to record in
//   batch-mode error checking.  When this number is reached, the
//   checking is aborted.  Values 0 - 100000 are accepted.
//
// intr_cnt:  This sets the maximum number of objects tested in
//   interactive DRC.  The testing aborts when this count is reached. 
//   Values of 0 - 100000 are accepted.
//
// intr_time:  This sets the maximum time allowed for interactive DRC
//   testing.  The value given is in milliseconds, and values of 0 -
//   30000 are accepted.
//
// skip_cells:  If nonzero, testing of newly placed, moved, or copied
//   subcells is skipped in interactive DRC.  If zero, subcells will be
//   tested.  This can be a lengthly operation.
//
// This function always returns 1.  Out-of-range arguments are set to
// the maximum permissible values.
//
// (int) DRCgetLimits(array)
//
// This function fills the array, which must have size 4 or larger,
// with the current DRC limit values.  These are, in order,
//
//   [0]  The batch error count limit
//   [1]  The interactive object count limit
//   [2]  The interactive time limit in milliseconds
//   [3]  A flag which indicates interactive DRC is skipped for subcells
//
// The return value is always 1.  The function fails if the array
// argument is bad.
//
// (int) DRCsetLevel(level)
//
// This function sets the DRC error recording level to the argument. 
// The argument is interpreted as follows:
//
//  0 or negative      One error is reported per object
//  1                  One error of each type is reported per object
//  2 or larger        All errors are reported
//
// This function always succeeds, and the previous level (0, 1, 2) is
// returned.
//
// (int) DRCgetLevel()
//
// This function returns the current error reporting level for design
// rule checking.  Possible values are
//
//  0              One error is reported per object
//  1              One error of each type is reported per object
//  2              All errors are reported
//
// This function always succeeds.
//

// (int) SetTransform(angle, reflection, magnification)
//
reflection, about ->of

// (int) StoreTransform(register)
//
// This function will save the current transform settings into a
// register, which can be recalled with RecallTransform().  The
// argument is a register number 0-5.  These correspond to the "last"
// and registers 1-5 in the current transform pop-up.  This function
// returns 1 on success, 0 if the argument is out of range.
//
// (int) RecallTransform(register)
//
// This function will restore the transform settings previously saved
// with StoreTransform().  The argument is a register number 0-5. 
// These correspond to the "last" and registers 1-5 in the current
// transform pop-up.  This function returns 1 on success, 0 if the
// argument is out of range.
//

ModifyTerminals moved to extraction

// (int) SetStripForExport(state)
//
// This function sets the state of the Strip For Export flag.  When
// set, output from the conversion functions will contain physical
// information only.  This should be applied when generating output
// for mask fabrication.  See the Conversion - Export panel
// description for more information.  If the integer argument is
// nonzero, the state will be set active.  The return value is the
// previous state of the flag.
//
// (int) SetSkipInvisLayers(state)
//
// This function sets the state of a flag which controls how invisible
// layers are treated by the output conversion functions.  Layer
// visiblity is set by clicking in the layer table with mouse button
// 2.  When the flag is set, invisible layers will not be converted,
// otherwise invisible layers will be converted just as other layers. 
// If the integer argument is nonzero, the flag will be set.  The
// return value is the previous value of the flag.  Within Xic, The
// flag is set from the Conversion - Export panel.
//
// (int) SetMapGDSoutUpper(state)
//
// This function sets a flag which applies only when writing a GDSII
// file using the conversion function.  When set, cell names that are
// lower case in Xic will be mapped to upper case in the file.  If the
// integer argument is nonzero, the flag will be set.  The return
// value is the previous status of the flag.  Within Xic, the flag is
// set from the Conversion - Export panel.
//


// SetMergeInRead(state)
//
// This function controls the setting of an internal flag which
// enables merging of boxes and wires while a file is being read. 
// This flag is set from with Xic in the Conversions - Input panel. 
// If the integer argument is nonzero, the flag will be set.  The
// return value is the previous state of the flag.
//
// SetMapGDSinToLower
//
// This function controls the setting of an internal flag, which
// applies only while reading a GDSII file.  If the flag is set, upper
// case names in the file are mapped to lower case names in Xic.  If
// the integer argument is nonzero, the flag will be set.  The return
// value is the previous status of the flag.  Within Xic, the flag is
// set from the Conversion - Input panel.
//

The Convert Menu has changes radically, although the underlying functionality
has not changed.  There are three new pop-ups: Convert-Export, Convert-Import,
and Convert.  Most of the commands previously available in the Convert Menu
are now available in one of these new pop-ups.

help deletions
xic:strip   xic:exprt#strip
xic:invis   xic:exprt#invis
xic:omap    xic:exprt#omap
            xic:exprt#nogdsmapok
            xic:exprt#cifoutstyle
xic:toxic   xic:exprt#toxic
xic:tocif   xic:exprt#tocif
xic:togds   xic:exprt#togds
xic:toedf   xic:exprt#toedf
xic:tooct   xic:exprt#tooct

The Convert-Export pop-up

This panel is brought up with the Export Control button in the Convert Menu.
This panel allows various flags and variables to be set that ar specific
to converted output, and also allows initiation of actual conversions.
At the top of the panel are five buttons which set internal flags.

Strip For Export
   When active, converted output will contain physical data only.
   This applies only to output initiated with the explicit conversion
   functions (see below), and not when writing files from the Save As
   command in the Edit Menu.

Don't convert invisible layers
   When active, layers that are invisible (set with button 2 in the layer
   table) will not be converted.

GDSII: map lower case names to upper
   When active, lower-case cell names will be converted to upper case
   when writing a GDSII file.

These three buttons had direct counterparts in the Convert menu of previous
releases.  The remaining button and "option" menu are new, but they
correspond directly to "!set" variables which were available previously,
and are still available.

GDSII: skip layers without Xic to GDS layer mapping.
   This effectively sets or unsets the NoGdsMapOk "!set" variable.
   When set, layers without an explicit mapping to GDS layers in the
   technology file will not be converted.  When not set, a fatal error
   will occur if the mapping is not present.

CIF: cell name and label extension style (option menu)
   This has the effect of setting the CIFoutStyle variable, and controls
   the syntax of the file.

The remaining controls are for output generation, and replace the
To XXX buttons previously found in the Convert Menu.

Output Format (choice menu)
   This sets the output format for conversions.  The choices are Xic,
   CIF, GDSII, EDIF200, and OCT.

Conversion Scale Factor (entry area)
   This allows a scale factor to be applied during the conversion.

The conversion is actually initiated with the Convert button.  The name
of the output file will be prompted for on the prompt line.

The Dismiss button retires the panel.
 
new help
            xic:imprt#replace
xic:merge   xic:imprt#merge
            xic:imprt#skip
            xic:imprt#empties
xic:imap   xic:imprt#imap
            xic:imprt#dtypes

# NoMapDataTypes from Convert to Edit Menu  (preferences script)

XXX check each variable for applicability to
 1) Conversion-Output
 2) Conversion
 3) Save/SaveAs
 3) Edit

The Conversion - Input panel

This panel contains six buttons which control certain features used when
reading cell data files.

Always Replace existing cells in memory
  This has the effect of setting the NoAskOverwrite variable.  When set,
  any cell in memory with the same name as one being read will be overwritten
  with the new data.  If unset, a detected name clash will cause a pop-up
  to appear giving the user a choice of keeping the old data or overwriting
  with new data.

Merge boxes and wires while reading
  If set, boxes and wires will be merged with neighboring boxes and wires,
  if possible, while files are being read.  This corresponds to a button which
  previously existed in the Convert Menu.

Skip testing for badly formed polygons
  This effectively sets the NoPolyCheck variable.  When set, the checking for
  possibly troublesome polygons, normally done while files are read, is skipped.

Skip testing for empty symbols.
  This effectively sets the NoCheckEmpties variable.  When set, there is no
  report of empty symbols.  When not set, when empty symbols are detected,
  a pop-up appears that allows the user to delete empty symbols.

GDSII: map upper case cell names to lower
  When set, while reading GDSII input, upper-case cell names will be converted
  to lower case in Xic.  This corresponds to a button found previously in the
  Convert Menu.

GDSII: map all unmapped datatypes to same Xic layer
  This effectively sets the NoMapDatatyles variable.  When set, a new
  datatype encountered while reading a GDSII file, which does not have an
  explicit mapping but has a layer number already mapped, will map to the
  existing layer.  If not set, a new Xic layer would be created.

xic:frcif   xic:convt#frcif
xic:frgds   xic:convt#frgds
xic:fredf   xic:convt#fredf
xic:froct   xic:convt#froct
xic:gdstx   xic:convt#gdstx
xic:txgds   xic:convt#txgds
xic:scale

The Conversion panel

This panel is a front end to all of the From XXX commands previously
found in the Convert menu, and well as the GDSII To Text and Text To GDSII
commands.  These conversions are stand-alone, in the sense that the
existing database in memory is not affected.  Conversions can also be performed
by reading in a hierarchy and using the explicit output conversion in the
Convert - Output panel.

This panel contains a choice menu of conversions to perform.  The choices are
  CIF to Xic
  GDSII to Xic
  EDIF200 to Xic
  OCT to Xic
  GDSII to text
  text to GDSII

There is also n entry area which allows a scale factor for the conversion to
be entered.  The conversion is initiated with the Convert button.  The
necessary file names will be prompted for on the prompt line.  The Dismiss
button retires the panel without performing any conversion.
----

// (real) SetConvertScale(real)
//
// This sets the scale used for conversions, for both the ToXXX() and
// the FromXXX() functions.  The argument is a real value in the
// inclusive range 0.01 - 100.0.  The return value is the previous
// scale value.
//

The pop-up for the Expand command in the View Menu has been enhanced.
Rather than using a general text input dialog, a dedicated, specialized
pop-up is now used.  The pop-up contains a text entry area, a number of
buttons which push specific text into the entry area, an Apply button,
and a Dismiss button.  When the pop-up first appears, it is given the
keyboard focus.  Under most (if not all) window managers, one should be
able to type into the text area immediately.  The Enter key is equivalent
to pressing the Apply button.  Thus, one can now quickly change the expansion
status entirely with the keyboard accelerators (the change will apply to the
window containing the pointer).  For example

    Ctrl-X 0 Enter   will set the expansion level to 0, and
    Ctrl-X a Enter   will set the level to "all".

The buttons which push text into the entry area avoid the need for typing.
These are:
    +          set to '+' (there can be multiple +'s added)
    -          set to '-' (there can be multiple -'s added)
    All        set to 'all'
    0-5        set to '0' - '5'
    Peek Mode  set to 'p' (available from main window only)

Pressing the Apply button will pass the expansion string to the expansion
control function.

** mswdevs.cc - wd.attributes

Bug: reading a stripped gds file fouled up label sizes of script and
long-text labels.

The File Selection pop-up that appears when a file or directory is being
solicited from the prompt line now has the green "go" button.  Pressing this
has the same effect as pressing the Enter key, i.e., whatever text is on
the prompt line is passed to Xic.
----
listutil.cc, trim_undo_list() tweek

gtkmenu.cc, edit.cc   Edit calls InitCallback();

Opening a new cell with the File selector while in a "mode" command would
leave the state in that mode with the new cell.  This could cause problems
with the internal history used in some modes.  Now, Xic is returned to Idle
mode whenever a new cell is opened for editing.

// (int) GetWirePoly(object_handle, array)
//
// This function returns the polygon used for rendering a wire.  This
// will be different from the wire vertices, if the wire has nonzero  
// width.  The first argument is a handle to an object list which
// references a wire object.  The second argument is an array which
// will hold the polygon coordinates.  This argument can be 0, if the 
// polygon points are not needed.  The array will be resized if
// necessary (and possible).  The return value is the number of
// vertices required or used in the polygon.  If an error occurs, the
// return value is 0.  If an array is passed which can't be resized
// because it is referenced by a pointer, the return value is a
// negative value, the negative vertex count required.  The function   
// will fail if the first argument is not a handle to an object list,
// or the second argument is not an array or zero.  The coordinates 
// returned in the array are in microns, relative to the origin of the
// current cell.

// (int) SetWireToPoly(object_handle)
// 
// This function converts the wire object referenced by the handle to  
// a polygon object.  If the conversion is done, the handle will
// reference the new polygon object.  The conversion will be done only
// if the wire has nonzero width.  If the wire is not a copy, the wire
// object in the database will be converted to a polygon.  Otherwise,
// only the copy will be changed.  Upon success, the function returns
// 1, otherwise 0 is returned.  The function fails if the argument is
// not a handle to an object list.

// (object_handle) ClipAroundCopy(object_handle1, object_handle2)
//
// This function is similar to ClipAround(), however no new objects
// are created in the database, and neither of the lists passed as
// arguments is touched.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// object referenced by the second handle that do not intersect the
// object referenced by the first handle.  The returned list can be
// used just as any list of object copies, however they are not copies
// of "real" objects.  If no new object would be created by clipping,
// the function returns 0.  Unlike ClipAround(), the second handle can
// reference object copies.
//
// (int) ClipAroundAllCopy(object_handle1, object_handle2)
//
// This function is similar to ClipAroundAll(), however no new objects
// are created in the database, and neither of the lists passed as
// arguments is touched.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// objects referenced by the second handle that do not intersect the
// objects referenced by the first handle.  The returned list can be
// used just as any list of object copies, however they are not copies
// of "real" objects.  If no new object would be created by clipping,
// the function returns 0.  Unlike ClipAroundAll(), the second handle
// can reference object copies.
//
// (object_handle) ClipToCopy(object_handle1, object_handle2)
// 
// This function is similar to ClipTo(), however no new objects are
// created in the database, and neither of the lists passed as
// arguments is touched.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// object referenced by the second handle that intersect the object
// referenced by the first handle.  The returned list can be used just
// as any list of object copies, however they are not copies of "real"
// objects.  If no new object would be created by clipping, the
// function returns 0.  Unlike ClipTo(), the second handle can
// reference object copies.
//
// (object_handle) ClipToAllCopy(object_handle1, object_handle2)
//
// This function is similar to ClipToAll(), however no new objects are
// created in the database, and neither of the lists passed as
// arguments is touched.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// objects referenced by the second handle that intersect the objects
// referenced by the first handle.  The returned list can be used just
// as any list of object copies, however they are not copies of "real"
// objects.  If no new object would be created by clipping, the
// function returns 0.  Unlike ClipToAll(), the second handle can
// reference object copies.
//
-----------------------------------------

httpget -g was foobar, repaired

download in mozy caused seg fault, fixed

Improved positioning of target select window.  Added position setting
capability to httpget.
 -g option now -g[x:y]
where is httpget documented (add to help?)

Note *** not backward compatible, download will fail with httpget < 2.8

Add to docs, need httpget for download.

Error msgs in mozy now go to pop-up instead of console.

changed build script and makefile templates to avoid xmkmf

The ClipXXXCopy functions had a core leak.

// (object_handle) MakeObjectCopy(numpts, array)
//
// This function creates an object copy from the numpts coordinate
// pairs in the array.  The function returns an object list handle
// referencing the "copy", which can be used in the same manner as
// copies of "real" objects.  The coordinate list must be closed,
// i.e., the last coordinate pair must be the same as the first.  If  
// the coordinates represent a rectangle, a box object is created,
// otherwise the object is a polygon.  Coordinates are in microns,  
// relative to the origin of the current cell.  The object is
// associated with the current layer (but of course it really does not
// exist on that layer).

The "vl" Verilog simulator program is no longer included in the
Accessories distribution.  Instead, the program is being distributed as
free software (GPL) from the Whiteley Research web and ftp sites.

Windows Only
The File Browser, when popping up to display a log file if an error
occurred whil reading the file, could erroneously pop up the load file
dialog.

Fixed incomplete erasure problem around edges of the drawing windows.

(Windows Only)
Ack!  If a spice run takes longer than 5 seconds, "Connection broken"
would be reported in Xic.  The results could still be plotted, after the
run was really finished.

MOVE cif style setting to Import popup.

The cif parser can now handle cell names with parentheses.  Use of other
than the standard GDSII characters (alpha/numeric, &, ?, _) in cell
names is not recommended, but usually there is no harm.

If a cell hierarchy is in memory that was not read from native cells, and
an Xic cell was read in that has the same name as one of the hierarchy cells,
Xic would never overwrite the hierarchy cell.  Now, the user is given a
choice to iverwrite or not.  But this only happens when a path is given
as part of the native cell name, i.e.,
    "./noname"  will potentially overwrite an existing "noname" symbol,
    "noname" will not.

Revised the handling of various dialects when parsing and writing CIF files.
This affects the CIFoutStyle variable, then the Conversion pop-ups.
The CIF parser has been upgraded to automatically parse all of the following
dialect possibilities.

CIF cell name extensions

Cell names are not part of the original CIF syntax specification.  Various
extensions have been used to supply cell names in a CIF file.  Each of these
extensions consists of command following the "DS ...;" command, in the
following forms:

cname_index  Historic Name   Format
0            IGS             9 cell_name;
1            Stanford/NCA    (cell_name);
2            Icarus          (9 cell_name);
3            Sif             (Name: cell_name);
4            none            no extension used

In Xic, any of the first four forms (indices 0-3) will be regognized
equivalently when reading CIF input.

CIF layer specification

Layers are specified in CIF in a command with syntax
    L token;
The the token can be interpreted in two ways; as the name of a layer, or
as an index into a layer table.  For the second interpretation, the token
must of course be an integer.

layer_index  Historic Name   Format
0            none            L layer_name;
1            NCA             L layer_index;

Of these, the first entry is most common.   Xic can handle both of these
interpretations (see below).


CIF label extensions

Text labels were not part of the original CIF syntax specification, so that
various extensions are used to pass label information.

label_index  Historic Name   Format
0            Xic             94 <<label>> x y orient_code width height;
1            KIC             94 label x y;
2            NCA             92 label x y layer_index;
3            Mextra          94 label x y layer_name;
4            none            no labels used

Unlike other extensions, the first extension listed above is unique to Xic.
If other formats are used, label size and orientation information will
be lost.  When reading CIF input, any of these forms will be accepted.

In the Output Conversion pop-up, the CIF style option menu has been replaced
by a field containing three option menus, for cell name extension, layer
interpretation, and label extension.  Each contains the choices discussed
above.  The choices selected will be reflected in the style of CIF generated
by Xic.

If the indexing is selected for layers, the index will be 1-based, and
correspond to the layers, left to right, in the layer table, i.e., the
leftmost (lowest) layer in the layer table is designated index 1.

In the Input Conversion pop-up, there is a new option menu for selecting
how layers are resolved when reading CIF input.  The default resolution
method ("Try Both") is as follows:

The parser reads "L token;".  If token matches an existing layer name
(as string comparison), that layer becomes the current layer.  If there is
no matching layer, and the token is an integer in the range of 1 through
a maximum number, and there is no leading 0, the token is tested as an index.
if a layer exists with that 1-based index, that layer becomes the current
layer.

If the layer still has not been resolved, a new layer is created in the
layer table, which becomes the current layer.

The option menu gives two additional chioces.  The "By Name" choice will
skip the index test.  If the string match fails with all existing layers,
a new layer will be created.  If the "By Index" choice is selected, the
layer tokens are assumed to be integers.  The string match test is skipped.
If the index test fails, an error is reported and the conversion aborts.
Now layers are never created in this mode.  The layer tokens must be positive
integers with no leading zeros that have a corresponding layer table entry.

The final change involves the CIFoutStyle variable.  When set, this variable
will determine the CIF output style.  Changing the option menu choices in
the Output Conversion pop-up will update the value of CIFoutStyle, but only
if the variable is already set.  If the variable is not set, reading in a
CIF file will set the internal style parameters, so that if the file is
written, it will have the same style.  Before writing, the style can be
changed from the Output Conversion pop-up.

The CIFoutStyle variable can be set to the following values, which will
set the CIF output style as indicated.

"a"  Stanford
    cname_index 1
    layer_index 0
    label_index 1

"b"  NCA
    cname_index 1
    layer_index 1
    label_index 2

"i"  Icarus
    cname_index 2
    layer_index 0
    label_index 1

"s"  Sif
    cname_index 3
    layer_index 0
    label_index 1

"m"  Mextra
    cname_index 0
    layer_index 0
    label_index 3

"n"  none
    cname_index 4
    layer_index 0
    label_index 4

"x"  Xic
    cname_index 0
    layer_index 0
    label_index 0

"cn:la:lb"
    cname_index cn
    layer_index la
    label_index ln

The final form consists of three colon-separated integers which are
interpreted as indices into the option lists as implied above.  If the
style parameters are changed in the Output Conversion pop-up while
CIFoutStyle is set, the value of CIFoutStyle will have this form.

----

New feature or bug (I'm not sure yet)

Native symbols can call GDS/CIF hieraarchies as subcells.  At present,
this requires some text editing to implement.  Suppose that one has a
GDSII hierarchy in file stream.gds, and a native file with lines

    (SymbolCall stream.gds);
    9 stream.gds;
    C 0 T -51000 9500;

The stream file will be opened, the top-level symbol will be renamed to
"stream.gds", and the hierarchy will be located in the native symbol at
-561000, 9500.

When the native symbol is saved, only that symbol is updated to disk, i.e.,
the hierarchy remains in GDSII format and is untouched.

The !polycheck command, which is called internally when a new cell is opened
for editing, will now repair certain "bad" polygons rather than reporting
an error.  The repair capabilities are
1) If a reentrancy condition can be avoided by moving a vertex by one
   database unit, the vertex will be moved.
2) If a "needle" vertex is found, it will be removed.  a needle vertex is
   a vertex where the path doubles back on itself, as in po ->p1 ->pneedle
   ->p1 ->p2.

The !join command, which is used internally in the !layer command, was
producing degenerate polygons (double-wound or figure-8) on occasion.
This should not happen now.
-------------------------------------------------------------

It is now possible to assign alternate names for the device.lib file,
the model.lib file, and the models subdirectory name.  Previously these
were hard-coded to these values.  In the present release, there are three
new technology file keywords which can be used to specify alternate
names.  Thus, these files can be technology-specific, and all can reside
happily in the library search path.

The following keywords can appear in the technology file.  Although they
can appear anywhere in the file outside of block definitions, it is
recommended for stylistic reasons that they appear near the top of the
file.

DeviceLibrary  libname

The libname is the name of a "device.lib" file which provides device
models for use in schematics.  If not given, the name defaults to
"device.lib".  This should be a file name, without any directory path.
A file by that name should be found in the library search path on program
startup.

ModelLibrary libname

The libname is the name of a "model.lib" file which provides SPICE models
for use in SPICE output.  If not given, the name defaults to "model.lib".
A file by that name should be found in the library search path on program
startup.

ModelSubdir dirname

The dirname is the name of a subdirectory of the directories of the
library search path, in which are found SPICE model files.  All directories
of this name found in the library path will be searched for SPICE models.
If not given, the name defaults to "models".

Fixed bug
If a formal terminal was internally linked to an object, and the object
was deleted, the program would crash if the link was followed.
e.g. !set UndoListLength 1
Edit Terminals   ( move terminal to object )
delete the object
delete some other object (orig object now destroyed)
save cell ( seg faults )

A round of updates and bug fixes in extraction/association.  The situation
where contact is made to a subcell by a formal terminal only is now
handled.

In the Edit Terminals command, SHIFT-clicking over a terminal will
bring up a new pop-up which allows the terminal name and layer binding
to be edited.  Also, terminals can now be moved by dragging.

Fixed bug: While rendering hardcopies, the "peek" expansion status
was ignored.  The expansion status is now displayed correctly.

If "Strip For Export" was active, cell magnifications would be silently
stripped from the CIF output.  Traditional CIF does not support cell
magnification.  Now, this situation generates a fatal error, i.e., the
conversion will abort.

Fixed a memory bug that seemed to affect only Linux systems.  The bug
caused crashes when executing scripts.

Fixed a long-standing interprocess communications problem with WRspice,
which was most obvious but not exclusive to Linux.  If the SPICE simulation
completed too quickly, Xic would never see the termination event, and hang.

Fixed a bug in Intel X86 releases.  The port number given with the -S
option was ignored, and the daemon would start on an internally selected port. 

--
The file selector was badly broken on at least Linux 6.0.  The readdir()
library function does not set the flag that indicates the file type, so
that no subdirs were listed in the left panel, but were listed as files
in the right panel.

The help windows were not responding to button 2/3 events.  It is now
possible to bring up a new help window by clicking on a link with button
2 again.
-------------------------------

Fixed another handle used-after-freed bug in the HandleNext() script
function.

Fixed some minor core leaks in the script string list and object list
functions.
--

The symbol table class, which is used throughout Xic, now has an adaptive
width hashing function.  This should improve speed when the table has
many entries.

New generator classes were added for traversing hierarchies.  These are
faster than the recursive methods previously used.

Fixed a condition that would cause a seg fault if the Apply button of
the Expand pop up was pressed, and then the popup was dismissed with
the window manager before drawing was complete.

Enabled a separate license validation for server/batch modes.

The "global" properties, such as the grid, were not being written in GDS
output.  Also, properties with numbers larger than 128 were not being written.
Old GDS rules limited property values to 0-128.  This is now relaxed, except
when the Strip For Export button is active.

Added tests so that the strictly internal properties and pseudo-properties
are never written to output files or read from input files.

Fixed (again) a bug involving terminal attachments causing a crash if the
attached-to object is deleted (see xic-2.4.66 notes).  The new fix
uses an internal property to maintain the association.

In physical mode when using the Properties Editor, assigning a pseudo-
property that causes the object to disappear (such as if merged) would
lead to seg faults.  This has been cleaned up.

Fixed bugs in Flatten command.  1) Ctrl-C was being ignored, now it aborts
after confirmation, 2) instance count in progress monitor was not quite right,
3) redraws are now deferred until finished, 4) undo was funny, required
pressing Tab twice.

The Copy command in the Edit Menu has changed.  Initially, the user is
prompted for a replication count.  This can be any positive integer.
When the copy is performed, the replication specifies the number of copies
made, with the translation incremented for each new copy.  Thus, this
facilitates creating many equally-spaced structures.  If the replication
count is greater than one, the command exits after the operation.  If
the replication count is one, the command operates as before.

Xic now checks for identical, coincident objects when reading input
files, and prints a warning message in the log file if such objects are
found.  If the Merge On Read button in the Convert Menu Input Control
panel is set, duplicate objects will be deleted and no warning is issued.

Xic no longer enforces a length limit of 32 characters for cell names.
The GDSII release 3 spec specifies this limit.

Replaced global CD variables with local variables in converters


The OCT read/write functions were basically broken, but should work
again now.  They are not expected to be useful until/unless the
Whiteley research version of the OCT tool set is made available.

When writing OCT files, if the environment variable OCT_ASCII_FORMAT
is set, the files will use an ascii representation rather than the
default binary representation.  The reader will read either type of
file.

The boolean Xic variable OctAsciiFormat will also force ascii output.

// (int) FromCIF(cif_file, destination_dir)
//
// The FromCIF function will convert a CIF file cif_file to Xic symbol
// files.  The symbols are not read into the database.  The second
// argument is the directory where the Xic files will be created.  If
// this argument is a null or empty string or zero, the Xic files will
// be created in the curent directory.
//

// (int) FromEDIF(edif_file, destination_dir)
// 
// The FromEDIF function will convert an EDIF-200 file edif_file to 
// Xic symbol files.  The symbols are not read into the database.  The 
// second argument is the directory where the Xic files will be
// created.  If this argument is a null or empty string or zero, the  
// Xic files will be created in the curent directory.
// 

// (int) FromGDS(gds_file, destination_dir)
//
// The FromGDS function will convert a GDSII file gds_file to Xic
// symbol files.  The symbols are not read into the database.  The
// second argument is the directory where the Xic files will be
// created.  If this argument is a null or empty string or zero, the
// Xic files will be created in the curent directory.
//

// (int) ToXIC(distination_dir)
// 
// The ToXIC command will write the current cell hierarchy to disk
// files in native format, no questions asked.  The argument is the
// directory where the Xic files will be created.  If this argument is
// a null or empty string or zero, the Xic files will be created in
// the curent directory.
//

// (int) ToOCT(destination_dir)
// 
// This function will write the current cell hierarchy to OCT files on
// disk.  The argument is the name of the directory where the files   
// will be created.  If this is NULL or the empty string, files will
// be saved in the current directory.
//

// (int) FromOCT(oct_file, destination_dir)
//
// The FromOCT function will convert an OCT file oct_file to Xic
// symbol files.  The symbols are not read into the database.  The
// second argument is the directory where the Xic files will be
// created.  If this argument is a null or empty string or zero, the
// Xic files will be created in the curent directory.
//

Calling the ToXIC script function no longer causes the destination
directory dialog to appear.  The (new) argument supplies this.

New '!' command:  !dups
This checks the current cell for identical objects placed on top of one
another.  The duplicate objects are selected.  This command initially
deselects anything previously selected.


The CIFtoXIC conversion function was broken if a destination directory was
given.  Also, the layer translation was not quite right, in particular,
if a layer found in the CIF file was not already in the Xic layer table,
it would be ignored, and all geometry on that layer would be on some other
layer in the Xic files.  This is no longer true - the layers are copied
directly, unless the Layer Specification choice in the Export Control
pop-up is set to "By Index", in which case the layers in the CIF file
are expected to be integers that map into the Xic layer table.  In this
case, the Xic files will have the corresponding layer names.

The FromXXX functions now create backup Xic files, i.e., when writing
over a Xic file, the previous file is given a ".bak" extension and
saved.

The Clear function in the Cells Listing pop-up now reverts to the
default "noname" cell after the operation if the current cell is
cleared.  Previously it would revert to a selected cell in the File Selector,
the next command line cell, etc.

Added a memory allocation monitor debugging tool.

Found/fixed various core leaks.

Fixed a bug in the Clear function of the Cells Listing pop-up.
   1) in physical mode, read in a cell with electrical data that contains
      a plot/iplot global property
   2) switch to electrical mode.
   3) bring up the Cells Listing and clear the cell just read, get a
      seg fault.

//  ClearAll()
//
// This will clear all symbols from the present symbol table, clear
// and delete any other symbol tables that may be defined, and reset
// the layer tables to their original state as defined in the
// technology file, deleting any layers created sybsequently.  This
// function does NOT automatically open a new symbol.  This is for
// server mode, to give the system a good scrubbing between jobs.
//

The close directive in the server protocol now calls ClearAll().
------------------------------------------------------------------

Finished update to the license server and security interface.

The new interface is backwards compatible, but allows some new
capabilities.

The error message printed when access fails is now much more
imformative.

Is Ctrl-x mapped to Expand? if so, update help.

Import Control
   Merge boxes and coincident objects while reading

   Skip testing for coincident objects (new)

Rearranged !set variable documentation for Edit/Convert

new variable: MergeInput (boolean)
When set, and reading input, boxes that overlap other boxes on the same
layer will be merged so that no boxes overlap.  Objects (not subcells)
that are identical to and coincident with another object will be deleted.
This variable corresponds to the MergeOnInput keyword in the technology
file, and can also be set with the Conversion - Import panel

new variable:  NoCoincCheck (boolean)
When set, the test for identical, coincident objects is skipped when
reading input.  The test is still performed for subcells, however.
If MergeInput is set, coincident objects (not subcells) are deleted
whether or not NoCoincCheck is set.  This variable can also be set
through the Conversion - Import panel.

new variable: GdsInToLower (boolean)
When set, cell names in a GDSII file that are entirely upper case will be
converted to lower case when the file is read into Xic.  Mixed-case names
are not changed.  This can also be set from the Conversion - Import
panel.

new variable: GdsTwoPass (boolean)
When set, the GDSII read will use two passes through the file, which was
the normal behavior for Xic releases prior to this one.  The present
release requires only one pass.

new variable: CifTwoPass (boolean)
This variable is unused at present.

new variable: StripForExport (boolean)
When set, output ....

new variable: SkipInvisible (boolean)

new variable: GdsOutToUpper (boolean)

vew variable: OctAsciiFormat (boolean)

* msw - mswconv.cc check carefully

new variable: GdsSkeletal

Skeleton mode: XXXXX

new variable: LockMode

// (int) SkelSetDataWin(l, b, r, t)
//
// This function sets the clipping box used when processing data that
// have beem read in "skeleton" mode.  The coordinates specify the box
// corners, in microns, in the coordinates of the current cell. 
// Geometry that does not overlap this region with nonzero
// intersection area will be ignored.  The function returns 1 if the
// clipping box is set, 0 if the given box has no area.  The
// clipping box is "cleared" by seting values to INFINITY.  The
// clipping box is automatically cleared if the Clear() function is
// called on the current cell, if that cell was read in skeleton mode,
// or if the ClearAll() function is called.  The clipping only applies
// to cells read in skeleton mode (the GdsSkeletal variable is set).
//

// (int) SkelClearGeom()
//
// This function clears the cache of geometry read in during
// processing in "skeleton" mode (when the GdsSkeletal is set).  This
// frees the memory space used for the cached objects.  This should be
// called when changing the clipping window with SkelSetDataWin().
//

The Rotate() command now takes angles in degrees, as stated in the
documentation.  Previously, the angle was assumed to be in radians.

The Mode() script function was broken, fixed.

// (int) Mode(window, mode)
//
// This function switches Xic between physical and electrical modes,
// or switches subwindows between the two viewing modes.  The first
// argument is an integer 0-4, where 0 represents the main window, in
// which case the application mode is set, and 1-4 represent the
// subwindows, in which case the viewing mode of that subwindow is
// set.  The subwindow number is the same number as shown in the
// window title bar.  The second argument is 0 for physical mode,
// nonzero for electrical mode.  The return value is the new mode
// setting (0 or 1) or -1 if the indicated subwindow is not active.
//
// (int) CurMode(window)
//
// This function returns the current mode (physical or electrical) of
// the main window or subwindows.  The argument is an integer 0-4
// where 0 represents the main window (and the application mode) and
// 1-4 represent subwindow viewing modes.  The return value is 0 for
// physical mode, 1 for electrical mode, or -1 if the indicated
// subwindow does not exist.
//

Made some minor changes to the core database structures and functions to
reduce memory use and to improve speed.

The !bincnt diagnostic now displays only the bins actually allocated.

The HTML viewer (help window) now responds to up and down arrow,
Page Up and Page Down, Home and End keys by scrolling.

Fixed bug (Unix/Linux only).  If the Ctrl key is pressed with the pointer
over a drawing window, then released when over a HTML viewer window,
the keyboard grab remains in effect and all key events go to Xic.
This may be specific to certain window managers.

----
The !setflag command documentation category was moved from DRC to
Diagnostics

Skel mode:  don't use gz file
            no labels

Fixed an ancient problem: When writing archive files such as GDSII and CIF,
if the top-level cell in the hierarchy contains no electrical information,
Xic assumes that there is no electrical info anywhere in the hierarchy, so
none is exported.  This is no longer true - all the information is now
exported.

Fixed ancient problem:  It was possible that the functions that directly
convert an archive file to Xic cells would write bad Xic cells.  This
could happen to cells in the file that were present in the electrical
hierarchy but not in the physical hierarchy.  The "dummy" physical block
in the cells would be missing, and when Xic would read the file, the
electrical data would be inserted into the physical database.  The converters
should no longer generate this type of output, and Xic should be smart
enough now to not read electrical data into the physical database.
---

Labels were not being added correctly to CIF output.

Fixed some bugs in the EDIF to Xic files translator.  Property labels
were broken.
------------------------------------------------------------------

Fixed bug:  If an electrical design was opened in physical mode, and if
there was a cell around with the same name as a library device, that
cell would be opened rather than the library device.  This is no longer
true.  Xic files with the same name as a library device will never be
opened.  Cells in files being imported that clash with device library
names will be aliased to a new name.

The hard copy panel now remembers the settings ot the portrait, landscape,
best fit, ans legend buttons on a per-driver basis.

The following new keywords can be used in driver blocks in the
technology file

HardCopyLegend n
   This sets the default status of the Legend button in the Print panel
   when the driver is active.  Values can be 0, 1, or 2:
     0   Legend button is off
     1   Legend button is on
     2   Legend button is grayed and inactive

HardCopyOrient n
   This sets the default status of the Portrait, Landscapem and Best Fit
   buttons in the Print panel while the driver is active.  Values are
   0-3:
    bit 0:  Status of Landscape/Portrait buttons
      set:  Landscape on, Portrait off
      unset: Landscape off, Portrait on
    bit 1:  Status of Best Fit button

While in hardcopy mode (i.e., the Print panel is up), the screen is now
drawn using backing store.  Proviously, backing store was turned off
in hardcopy mode.

More fine-tuning HTML viewer, to get text to wrap around images correctly.

The hierarchy traversal code used in the Flat... script functions and DRC
was broken in skeleton mode.

Skeleton mode was broken for gzipped files.

CIF write might have been broken

If CIF/GDSII files were not ordered bottom-up, Xic would not set the instance
bounding boxes correctly causing some cells to be invisible.  This is a
long-standing bug, but not discovered since these files are generally
ordered.
-----

The imsave driver now produces correct colors in 256-color display modes.

Spurrious error messages in imsave and the window dump function have been
eliminated.

Fixed a bug: a coincident object in a symbolic cell would generate an
error message that would cause a seg fault (bug introduced in 2.4.67)

Fixed 256-color mode problems
  There is no longer a cascade of console error messages due to Xic trying
to change the value of a read-only colormap entry.
  It is now possible to change the colors of layers that have read-only
colors, by skipping between existing colors that are close to the
desired value.  Note that blicking does not work for such layers.

Changed to hard copy attribute switching functions to avoid potential
problems with layers created or other layer table changes while in
hard copy mode.

The Grid pop-up, if visible, is now updated when the grid changes,
for example by changing the display mode.

New tech file keywords
AltGridSpacing
AltPhysGridSpacing
AltElecGridSpacing

Improved internal logic for storing grid parameters.

The subwindows now remember their grid parameters across a display mode
change and back.

Altered core data structures to reduce memory overhead.

In blinking mode in the Paths/Quick Paths command with 256-color mode,
only the path highlighting blinks.  Previously all highlighting would
blink.

In 256-color mode, the selected terminal now blinks, as it should.
---

In 256-color mode, the color selection pop-up now has a sample area where
the large empty space was.

The layer names in the layer table are now white, for visibility.

Fixed a bug in the HTML viewer that broke the Proferences script.
---------------------------------------------

GetPropertyString() would crash the program if passed an empty or bad
handle.

Fixed a bug in skeleton mode that caused program crashes.

Fixed a bug in skeleton mode that allowed objects outside of the current
clipping box to be returned from the generator.

Previously, if Xic crashes, it executes a script named "gdbexec" found
in the Xic startup directory.  Now, this script is generated when needed
by Xic, and placed in the log directory.  The gdbexec file in the startup
directory is no longer part of the distribution and should be deleted.

// (int) Flatten(depth, fast)
//
// The selected subcells are flattened into the current cell,
// recursively to depth.  The depth is an integer representing the
// depth into the hierarchy to flatten:  0 for top-level subcells
// only.  This argument can also be a string starting with 'a' to
// signify flattening all levels.  A negative depth also signifies
// flattening all levels.  If fast is nonzero, "fast mode" is used,
// i.e., there will be no undo capability.  This provides
// functionality similar to the Flatten button in the Edit Menu.
//
TODO: make -1 -> "all" for all such functions.

FlatOverlapList() would take a nonzero integer depth argument as 1.

The coincident-object merging was broken, and would likely lead to
program crashes if enabled.

TODO
   generator handle problems after database modified
    SkelClearGeom()
    Flatten(...,1)

Tore out the code for skeleton mode and recoded this properly.  The
skeletal database can now be edited, i.e., it is no longer read-only.
One obviously does not want to use skeleton mode for general editing,
but it is often important to be able to make changes, such as to remove
duplicate objects, even if the cells are only being analyzed rather than
synthesized.  Note that anything added to a cell may disappear when
the cache is updated.

The attribute that saved the grid in GDSII files prevented those files
from being read by some other applications.  Users ofter forget to use
the Strip For Export button, and the normal GDSII output is otherwise
quite portable.  The grid is now hidden away in the library name field,
which does not use a syntax entension.

Tore the geometry manipulation and supporting functions out of the drc
system.
TODO DRC.variables ?

Added an accounting system for generator functions, to avoid the problem
of objects being deleted while a generator is active crashing the program.

For example:

h = FlatObjGen(l, b, r, t, "a")
Select(l, b, r, t, "c")
Flatten(-1, 1);
while ((oh = FlatGenNext(h)) != 0)
...

This would crash the program, since the references cached with the handle
h are deleted (note the "undoable" option) by the Flatten command, and
using the handle would reference bad data.  In the present release,
the open generator handles are stored in a table, and references are purged
when objects are deleted.

TODO: set gPointer on first call to CDg::next()
TODO: make drc errors blink
TODO: monitor allocation counts of generator tables

The depth argument of the following functions now takes the same format:
non-negative integer sets depth
string starting with 'a' sets maximum depth
negative integer sets maximum depth
// (object_handle) FlatObjList(l, b, r, t, depth)
// (handle) FlatObjGen(l, b, r, t, depth)
// (handle) FlatObjGenLayers(l, b, r, t, depth, layers)
// (object_handle) FlatOverlapList(object_handle, touch_ok, depth, layers)
// (int) Flatten(depth, fast)
// Layer(string, depth, flat)
// (int) DumpPhysNetlist(net, devs, spice, bdnet, depth, filename)
// (int) DumpElecNetlist(net, spice, bdnet, depth, filename)
// (int) ExtractAndSet(alldevs, create, clear, depth)
xicf1.cc
// (stringlist_handle) CellsHandle(cellname, depth)

// (int) SkelReadGeom(depth)
//
// This function will read into memory all of the geometry for the
// current cell, which is expected to have been opened in skeleton
// mode (i.e., with the GdsSkeletal variable set).  Only geometry
// which is within the current data window will be read.  The argument
// is the depth in the hierarchy to read.  This can be an integer,
// with 0 representing the current cell only, 1 will include its
// subcells, and so on.  A negative value will read the entire
// hierarchy.  This argument can also be a string starting with 'a' to
// indicate reading of the entire hierarchy.
//
// Although while in skeleton mode data are always available when
// needed, in some scripts better performance might be achieved by
// initially reading all data into memory with this function.
-----

Lots of tweeks and bug fixes to the HTML viewer, mostly for web access.

Skeleton mode editing: no undo

Skeleton mode has changed.  In the new version, geometry must be read
into memory explicitly with the SkelReadGeom() script function.  No
reading takes place during processing.  This approach gets around the
problem of the previous approach, where a purge/read could take place
at any time, potentially leaving bad memory references scattered
throughout the program.  The new approach means that most if not all
operations will behave sanely in skeleton mode, and in particular won't
crash the program.

The following sequence should appear in scripts to change the skeleton
mode data window.

SkelClearGeom()
SkelSetDataWin()
SkelReadGeom()

Virtually all of the time these three functions will be used together
in the sequence shown.  Following this sequence, all operations are
available, though the hierarchy contains only the objects which
reflect into the data window in the coordinate system of the top-level
cell.  Although objects can be added/edited in the normal manner,
the changes will be lost when the data window changes and the file
data is re-read.  A disk file can be generated from skeleton mode,
but be careful to not clobber the original file with a file with
partial content.  The original file will be saved with a ".bak"
entension *once*.

SkelClearGeom() And SkelReadGeom() do not redraw the screen.

The parameter extraction for parallel devices was broken.
This has been recoded, and there are some changes.

The syntax for the Merge keyword in technology file device blocks has
changed.  The old syntax should not cause problems.  The new syntax is
as follows:

  [ Merge ] [ argument ]

If the Merge keyword does not appear or the argument to the keyword
is given and starts with 'n' or 'N', the device type will not be
merged, i.e., parallel devices of this type will remain distinct in
netlists and SPICE output.

If the Merge keyword appears with no argument or with an argument that
does not start with 'n' or 'N', parallel devices of this type will be
merged into a single device in netlists and SPICE output.

The way the merging is computed is now determined by the Measure keyword.
Parallel resistance is computed as Rtot = 1/Sum(1/Rn).

Keyword                         Action
-------                         ------
BodyArea                        Sum
BodyPerim                       Sum
CArea                           Sum*
CPerim                          Sum*
CWidth                          Fixed (assumed same for each device)
CNWidth                         Sum
CBWidth                         Fixed (assumed same for each device)
CBNWidth                        Sum
Resistance                      parallel resistance
Inductance                      parallel resistance
Mutual_Inductance               not implemented
Capacitance                     Sum

* Note: if devices of the same type share a contact, the contact area
  and perimeter are divided equally between the devices.

New Measure keyword: Sections

This retruns to number of components of the device, which will be greater
than one of the device is an aggregate of several parallel-connected devices.

The "Merge M" feature is gone.  This would average the parameters
of parallel-connected mos devices, and automatically add the "M="
(multiplier) parameter to the SPICE output line.  Now, the merging behavior
is as described above, and no multiplier is automatically added to the
SPICE line.  The Sections keyword can be used to explicitly format the
SPICE output to use the multiplier parameter, if desired.

The placement of the File Selection pop-up no longer moves across the
screen, unless there are multiple File Selection pop-ups present.
------------------------------------------------------------------

Found a way to hugely increase the speed of combining large collections
of trapezoids into polygons.

In the Quick Paths command, Ctrl-C would stop computation, but giving
'y' to abort would not actually abort to operation.

Added buffering pixmap to prompt line to reduce flicker.

Fixed a subtle problem.  In the Quick Paths command and probably others,
entering the following set of key presses would crash the program:
Esc Esc Ctrl-C

Added App->ClearSavedEvents();

There is now a choice of algorithms for inverting the ground plane when
this is used, i.e., the keyword sequence "GroundPlandClear MultiNet" is
given for some layer in the technology file.  The algorithm is selected
by providing an integer 0-2 following "MultiNet" separated by space, so the
official syntax is now

    GroundPlaneClear [MultiNet] [0|1|2]

0 (the default, and previous algorithm)
   The inverted layer is created for each cell in the hierarchy by computing
   $GPI = !GP & !$$, i.e., for each cell the ground plane is inverted and
   the areas over subcells are removed (recall that "$$" is a pseudo-layer
   representing subcell boundaries).

1
   The inverted layer is created only in the top cell in the hierarchy, and
   is the inverse of a flat representation of the ground plane layer
   from all cells in the hierarchy.  The extraction algorithm will add
   virtual contacts from this layer to the appropriate places in the subcells.

2
   The inverted layer is created in each cell of the hierarchy by creating
   a flat inverse of all of the ground plane found in the cell or lower in
   the hierarchy.

The default (0) method is the most efficient computationally, but the method
will probably fail if sibling subcells overlap.  In general, it is good
practice to avoid cell overlap.

Method 1 will work if subcells overlap.  However, since there is no local
ground plane in the subcells, generating a netlist while in a Push will
not yield correct results.

Method 2 is the least efficient computationally, but each cell has a local
ground plane.

If the MultiNet keyword does not appear, then all areas outside of the
layer geometry are assumed to connect to ground.  VIAs and CONTACTs that
have been speciified for the ground plane layer will make contact to
ground in the *absence* of the ground plane layer.  Although this sometimes
works for simple cells, it can lead to trouble.  Suppose that an island
of ground plane metal is used as part of the metalization for the chip pads.
This would appear as a hole in the displayed representation of the ground
plane.  Then each pad will be extracted as shorted to ground!

The same layer inversion method is used for the Quick Paths command.

New variable: GroundPlaneMethod (integer 0-2)
This sets the method used to invert the ground plane fro grouping and
extraction, if the MultiNet keyword has bee applied to a
GroundPlaneClear layer in the technology file.  The possible values are
integers 0-2, which have the same meaning as the integer that optionally
follows MultiNet in the technology file.

Variable HandleTermDefault name changed to GroundPlaneMulti

New variables:
    NoMergeParallel
    NoMergeSeries

TODO reorder Extract set vars, update preferences script
mswextrc set_extracted -> InvalidateExtract

The extraction system can now merge series devices.
applies only to two-terminal permutable devices

Merge [arg]
  no arg        parallel
  "s"           parallel and serial
  "n"           no merge
  "ns" or "sn"  serial

Fixed bug:  changes made when editing a Device Block from the Extraction
Parameter Editor were updating correctly.

New variable:  QpathGroundPlane (integer 0-2)
This variable controls how the Quick Paths command uses the inverted ground
plane.  An inverted ground plane is created while grouping under extraction,
If enabled.  The choices are
0   Use the inverted ground plane is available
1   Create the inverted ground plane if necessary, and use it
2   Never use the inverted ground plane

The default behavior is to use the inverted ground plane if it already
exists, as for "0", if the variable is unset.

Check out adelp ground plane change
mswextrc.cc changes

Xic can now handle multi-contact resistors.  A multi-contact resistor
is replaced internally by a networ of two-terminal resistors, which are
used in the netlist output.

To enable multi-contact resistor support, the second contact specification
in the resistor device block should end with "...", for example

Contact + M2 I1B&R2
Contact - M2 I1B&R2 ...

This specifies that as many of the second type of contact as can be found
will be extracted.  Without the "..." only two contacts would be extracted,
as was the previous behavior.  The elipses can not occur on the first
contact line, but may occur on other than the second, and may occur more
than once, though no standard devices use this feature presently.  In general,
this implements device extraction with arbitrary numbers of certain
contacts.

Internally, a conductivity matrix is computed from the body and contact
geometry, and this is used to compute the effective values of the two-terminal
resistors that are used to implement the multi-contact resistor.  Resistors
that would have very high values (larger than 100 times the smallest value)
are not added, so that linear multi-contact resistors decompose as one
would expect.

The decomposition occurs before the serial/parallel merging, so that the
components of the decomposition are candidates for merging, if merging
is enabled.
---

Fixed bug: The "$$" layer, which is a pseudo-layer representing the subcell
areas for use in layer expressions, was not delineating arrays correctly.
The area assumed for an array was the area of a single cell.

Fixed bug, prompt line would be munged by previously "erased" message.

FIX MS hytext
remove register_tmpfile_delete from mswinterf.h

Fixed some inconsistencies in the undo system which could lead to bad
memory references and program crashes.  These mostly involve the use of the
!layer command, combined with Push/Pop.

Fixed long-standing bug:  If button 1 pressed in a drawing window, held,
and released outside of the drawing windows, no more selections can be
made until Esc is pressed.

New variable:  SelectTime (integer 100-1000)
This sets the time in milliseconds that the pointer must remain motionless
before it "picks up" a selected object.  The default is 250 mSec.
----------------------------------------------------------------------------

Added build support for XicII

If there are no DRC errors recorded, the Show Errors command could get into
an infinite loop or otherwise misbehave.

Fixed a bug which could crash the program if an electrical cell was
overwritten (responding to the prompt when reading a new hierarchy).

The Edit() script function now returns a status integer.
// The return value is one of the following integers, representing
// the command status:
//  -2      The function call was reentered.  This is not likely to
//          happen in scripts.
//  -1      The user aborted the operation.
//   0      The open failed: bad file name, parse error, etc.
//   1      The operation succeeded.
//   2      The read was successful on an archive with multiple top-
//          level symbols but the symbol to edit can't be determined.
//          The current cell has not been set, but the cells are in
//          memory.  The second argument could have been used to
//          resolve the ambiguity.
//   3      The cell name was the name of the device.lib or model.lib
//          file, which has been opened for text editing (in graphic
//          mode only).
//

add to ToXXX descriptions
// The file is written according to the settings of
// the controls in the Convert - Exports panel, and/or the related
// variables.

new function
// (int) ToGdsLibrary(gds_name, symbol_list)
//
// This function will create a GDSII file from a list of cells in
// memory.  The first argument is the name of the GDSII file to
// create.  The second argument is a string consisting of
// space-separated cell names.  The cells must be in memory, in the
// current symbol table.  Both arguments must provide values as there
// are no defaults.  The GDSII file will contain the hierarchy under
// each symbol given, but any cell is added once only.  The resulting
// file will in general contain multiple top-level symbols.  The file
// is written according to the settings of the controls in the Convert
// - Exports panel, and/or the related variables.
//

Fixed a bug related to gtk themes.  If the gtk theme engine is installed
on the system, then all gtk-based applications, including WRspice and
Xic, should respond to the setting of different themes, meaning that the
visual appearance can be changed.  Only Linux provides the gtk theme
engine.  This can be installed by the user on Solaris and FreeBSD systems.

This capability was not working, but should now work with the present
release.
-----------------------------------------------------------------------

// (int) AddLayerGdsOutMap(layer_name, layer_num, datatype)
//
// This function will add a mapping from the layer named in the first
// argument (a string) to the given GDSII layer number and data type. 
// The layer number and data type are integers which define the layer
// in the GDSII world.  When a GDSII file is written, the present
// layer will appear on the given layer number and data type in the
// GDSII file.  It is possible to have multiple mappings of the layer,
// in which case the geometry from the present layer will appear on
// each layer number/data type given.
//
// The function returns 1 on success, or 0 if an error occurred, in
// which case no mapping has been created.  If the layer name is not
// found in the layer table for the present mode (physical or
// electrical), or the layer number or data type number is out of
// range, 0 is returned.  The acceptable range for the layer number
// and data type is [0 - 255].
//

// (int) RemoveLayerGdsOutMap(layer_name, layer_num, datatype)
//
// This function will remove a GDSII output layer mapping for the
// layer named in the first argument (a string).  The mapping may have
// been applied in the technology file, with the Conversion Parameter
// Editor, panel, or by calling the AddLayerGdsOutMap() function.  The
// mappings removed match the given layer number and data type
// integers provided.  These are in the range [-1 - 255], where the
// value '-1' indicates a wild-card which will match all layer numbers
// or data types.
//
// The return value is -1 if the layer name can't be found in the
// layer table for the present mode (physical or electrical), or if
// the layer number or data type is out of range.  Otherwise, the
// return value is the number of mappings removed.
//

// (int) AddLayerGdsInMap(layer_name, string)
//
// This function adds a GDSII input mapping record to the layer whose
// name is given as the first argument.  The second argument is a
// string listing the layer numbers and data types which will map to
// the named layer, in the same syntax as used in the technology file. 
// This is "l1 l2-l3 ..., d1 d2-d3 ...", where there are two comma
// separated fields.  the left field consists of individual layer
// numbers and/or ranges of layer numbers, similarly the right field
// consists of individual data types and/or ranges of data types. 
// Each field can have an arbitrary number of space-separated terms. 
// For each layer listed or in a range, all of the data types listed
// or in a range will map to the named layer.  There can be multiple
// input mappings applied to the named layer.
//
// The function returns 0 if there was a syntax or other error,
// including the named layer not being found in the layer table for
// the current mode (physical or electrical).  The function returns 1
// if the mapping is successfully added.
//

// (int) ClearLayerGdsInMap(layer_name)
//
// This function deletes all of the GDSII input mappings applied to
// the layer named in the argument.  These mappings may have been
// applied through the technology file, added with the Conversion
// Parameter Editor, or added with the AddLayerGdsInMap() function. 
// This function returns 0 if the layer name does not exist in the
// symbol table for the current display mode (physical or electrical). 
// Otherwise, 1 is returned and the GDSII input mappings, if any, have
// been deleted.
//

// (int) SetLayerNoDRCdatatype(layer_name, datatype)
//
// This function assigns a data type to be used for objects with the
// DRC skip flag set.  The first argument is the name of the
// (physical) layer.  The second argument is the data type in the
// range [0 - 255], or -1.  If -1 is given, any previously defined
// data type is cleared.  The function returns 0 if the layer name
// can't be resolved, or the data type is out of range.  The value 1
// is returned on success.
//

changes to PopUpParamEditor MSW!
get_string_for()

Minor bug fixes to the Conversion Parameter Editor

Fixed bug in association that would cause faults for certain input.

Calling NewCurLayer() with no current symbol would crash the program.

The NewCurLayer() function will now create a new layer if there in no
current symbol.
----------------------------------------------------------------

The Ctrl-G (grid) command now gives an explanatory error message on bad
input, rather than silently ignoring it.

The Set Grid pop-up now does not allow a snap value of 0 to be entered.

When writing GDSII, a message is printed every 100K bytes, so that if
dumping a large flat file there is feedback.

It is now possible to interrupt and abort a GDSII write with Ctrl-C.

Fixed a problem with selections when using true-color (more than 256 colors)
displays.  When a large number of objects are selected, the time to
redraw the selections to effect the blinking can be excessive, causing
the interface to become unresponsive.  Now, if there are more than 
s certain number of selections, the selections will not blink.
In 256 color mode, this is not a problem since the color change is
produced through a color map modification and not by redrawing.

When copying/moving a large number of selected objects, if there more than
a certain number, the objects are not ghost-drawn individually, rather a
dotted bounding box of the aggregate is shown.

Presing Ctrl-C while reading in skeleton and responding 'y' to the
abort confirmation would crash the program.

Fixed some spurrious error messages that would appear when creating objects
with script functions in skeleton mode.

Deleting objects while in skeleton mode would cause memory corruption.

gtkplace.cc   free mitems

Revised the handling of cell name clashes when opening new cells.  The
previous behavior was inconsistent in server mode.

There are two new variables:
    NoOverwritePhys (boolean)
    MoOverwriteElec (boolean)
These control the default behavior when a cell from a file being read conflicts
with the name of a cell already in memory.  The default behavior is for the
cell from the file to overwrite the cell in memory.  If NoOverwritePhys is
set, the physical part of the cell in memory will not be overwritten, and the
physical part of the cell in the file will be ignored.  Similarly, if
NoOverwriteElec is set, the electrical part of the cell in memory will be
preserved, and the electrical part of the cell from the file will be
ignored.  These defaults can be changed from the Conversion - Import panel.

In graphical mode, when a name clash is detected while reading a file, the
Merge Control pop-up will appear.  This can be used to change the overwriting
behavior on a per-cell basis.  This pop-up is suppressed if the
NoAskOverwrite variable is set, in which case the overwriting will be
determined by the states of the NoOverwritePhys and NoOverwriteElec variables.
This is also the case in non-graphical (server or batch) mode.

*** test/fix setjmp in msw
--------------------------------------------------------------------

New button in the Attributes Menu, both in the main window and subwindows:
Freeze Display

When pressed, no cell structure is drawn in the window, only the grid
and the bounding box.  This is for use when working on a large, flat cell
when it is not necessary to see the structure and it is inconvenient to
wait for the display.  When active, "FROZEN" appears in the upper left
corner of the window.  The display is not automatically redrawn when the
Freeze Display button is unset, press Ctrl-R to do this.

New '!' commands

!bb

In physical mode, this prints the bounding box coordinates of the current
cell, in microns.

!origin x y | n|s|e|w|nw|ne|sw|se

In physical mode, this will move the cell origin.  This applies a translation
to every object in the cell, and rebuilds the database.  The operation is
more efficient than selecting everything and applying a move command, however
there is no automatic "undo", except by applying the reverse operation.

All instances of the cell will change position if the cell origin is changed.

If the arguments are a coordinate x,y pair, the origin is shifted to that
position (in microns) relative to the lower left corner of the cell's
bounding box.

Alternatively, the argument can be one of the following compass directions:
n   the origin is moved to the top of the bounding box, the left/right
    position does not change.
s   the origin is moved to the bottom of the bounding box, the left/right
    position does not change.
e   the origin is moved to the right side of the bounding box, the up/down
    position does not change.
w   the origin is moved to the left side of the bounding box, the up/down
    position does not change.
nw  the origin is moved to the upper left corner of the bounding box.
ne  the origin is moved to the upper right corner of the bounding box.
sw  the origin is moved to the lower left corner of the bounding box.
se  the origin is moved to the lower right corner of the bounding box.


!import cellname

In physical mode, this will move the contents of the physiocal part of
cellname into the physical part of the current cell (the electrical
parts are unchanged).  The physical part of cellname will be empty
after the operation.  The coordinates of the objects are the same
after the move, with respect to the origin of the current cell.  This
operation is not undoable.


// (int) Exec(script)
// The function returns the
// return status of the script, or 0 if the script was not found.

The return value of a script defaults to 1.  If the script terminated
with a return statement followed by an expression:

    return <expression>

Then the value of the expression is returned by the Exec function.

Fixed a potential core leak in script evaluation while in server mode.
if the script contains lines like
    string1 + string2
    Strcat(string1, string2)
i.e., an expression that returns a new string that is not assigned to a
variable, the string would never be freed.

The following new feature is available in Unix/Linux releases only.
Xic now has built-in memory management.  The built-in memory manager allows
Xic to use all available system memory, which is not true with the standard
memory manager supplied with the operating system.  The standard memory
manager allows Xic to use less than 1Gb of memory before an out-of-memory
error will halt the program.  The built-in memory manager will allow use of
more than this, assuming that it is available on the system.

If Xic is started with the XIC_SYSTEM_MALLOC environment variable set,
then Xic will use the standard memory manager provided by the operating
system, as in previous releases.

Windows Only:
The file listing in the File Manager and similar pop-ups was not sorted
if the files came from an (archaic) FCB-formatted partition.

Windows Only:
No more license server for Windows!  Yes, the annoying license server is
history.  You will still need a license, however, but the authentication
is now build into the programs.

You don't need to do anything.  The current releases of the programs
should start now without having to start the license server.  The
license server can be uninstalled.

The programs look in the following places for the LICENSE file:
1)  Along the Library Path.  Thus, the /usr/local/lib/xictools/xxx/startup
   directory is the "standard" location (where "xxx" is "xic" or "wrspice").
2)  The previous location: /usr/local/lib/xictools/license

If you have both Xic and WRspice, then your license file enables both
programs, and it *must* be located in the xictools/license subdirectory.
Actually, you could copy the LICENSE file to the startup directories
for each program, but this may be confusing should a new LICENSE file
be needed in the future.

If you have just one program, the LICENSE file can be moved to the startup
directory, and the license subdirectory can be deleted.

The new licensing scheme means that there are no user-limits or workgroup
server options directly available (such configurations can be provided
on a custom basis if there is a need, contact Whiteley Research).
-----

Added feedback when clearing cells, since this can take a long time if
the cells are huge.

Fixed bug:  Move a subcell, select it, and flatten in "fast mode".  The
undo list now contains a bad pointer, which can crash the program.

Updated the default function key mappings in the sample technology files.
F5-F7 didn't do anything since they were supposed to raise
pop-up menus which haven't existed since xic-2.4.0.  The mapping of course
can be changed to whatever you wish, but is supplied as

F1key box               Start "box" command (create a box)
F2key wire              Start "wire" command (create a wire)
F3key polyg             Start "polyg" command (create a polygon)
F4key label             Start "label" command (create a label)
F5key open              Pop up File Manager
F6key cells             Pop up Cells Listing
F7key prpty             Pop up Properties Editor
F8key desel             Deselect all selections

There was an error introduced in 2.4.70 which broke the FlatGenNext function.
Symptoms include missing objects and seg faults.

The "docking" of some pop-ups, such as the Device Menu in electrical mode,
into the main window has been removed.  Users found this annoying.
---------------------------------------------------------------------------

The Color Selection pop-up has been modified to allow far more colors to
be adjusted.  Many more of the attribute colors now can be different in
electrical and physical modes.

The Color Selection pop-up has a new pull-down menu plus a "radio group"
of three buttons.  The three buttons allow the pull down menu to contain
different sets of entries.  Each entry represents a color that can be
adjusted.

The three buttons provide the following sets of menu entries:
  Attributes
    These are the colors used in the drawing windows.  Most of these colors
    can be separately set while in electrical or physical mode.

    The entries are:
      Current Layer                     Current Layer color
      Background                        Drawing window background color
      Coarse Grid                       Color used for coarse grid lines
      Fine Grid                         Color used for fine grid lines
      Ghosting                          Color used for "sprites" attached to
                                        the mouse pointer
      Highlighting                      Color used for highlighting, such as
                                        for DRC errors
      Selection Color 1                 One of two alternating colors used
                                        for selections
      Selection Color 2                 One of two alternating colors used
                                        for selections
      Terminals                         Electrical terminals, electrical mode
                                        only
      Instance Boundary                 Boundary color of unexpanded instance
      Instance Name Text                Name text color in unexpanded instance
      Instance Size Text                Size text color in unexpanded instance,
                                        physaical mode only
     

  Prompt
    These are the colors used in the Prompt Line and Status Line.

    The entries are:
      Text                              Normal prompt line text
      Prompt Text                       Text color used for prompting
      Highlight Text                    Text color used for hypertext
                                        references
      Cursor                            Text cursor color
      Background                        Normal background color
      Edit Background                   Background color while editing

  Plot Marks
    These are the colors of the plot point marks used in electrical mode
    to indicate a node or current being plotted by WRspice.  The default
    colors are the same as the trace colors used by WRspice for plotting.

     The entries are:  Plot Mark 1 to Plot Mark 18

  The changes to the underlying object or attribute color can be made by
  moving the sliders, selecting a color from the Colors menu, etc.  The
  color change may or may not be immediately visible on screen.  In some
  cases, one may have to force a redraw to see the color change.  For
  example, if one of the Prompt colors is changed, one may have to move
  another window over the Prompt Line, then off, to send an Expose event
  to the Prompt Line window which will force a redraw.

  There are a number of new color keywords which can appear in the
  technology file.  In the case where there are "Elec" and "Phys"
  prefix variants, these will set the attribute color for the
  indicated mode.  The same keyword without the prefix will set the
  color for both modes.  If both a prefix and non-prefix version
  appear in the technology file, the last keyword will have precedence.

  Below is a list of the new keywords.  The attribute whose color is
  set by the keyword should be obvious, from the discussion above.
  The indented names are aliases.

  PromptEditBackgColor
    PromptEditBackg
    PromptEditBackground

  GhostColor
  ElecGhostColor
  PhysGhostColor

  ElecHighlightingColor
    ElecHighlighting
  PhysHighlightingColor
    PhysHighlighting

  ElecSelectColor1
  PhysSelectColor1

  ElecSelectColor2
  PhysSelectColor2

  ElecMarkerColor
  PhysMarkerColor

  ElecInstanceBBColor
    ElecInstanceBB
    ElecInstanceBox
  PhysInstanceBBColor
    PhysInstanceBB
    PhysInstanceBox

  ElecInstanceNameColor
    ElecInstanceName
  PhysInstanceNameColor
    PhysInstanceName

Fixed a subtle screen-mung from ghosting that could happen when windows
are raised/lowered with keyboard actions.

New command line option: -Hdirectory_path
Giving this option will cause Xic to start in the directory given by
directory_path.  Note that there is no space between H and the path
string.

Under WindowMaker 0.80, it was discovered that the File Selection and related
pop-ups would not receive any events, i.e., would never respond to mouse
buttons ore key presses.

Unix/Linux
The key press handling of all pop-ups has changed.  Now, any key event
that is not handled by the pop-up (assuming that the pop-up has the focus)
will propagate to the main window.  Thus, one can type normal text into
the prompt line even if a pop-up has the keyboard focus.  However, some
keys, such as Tab and the arrow keys, may be swallowed by the pop-up.
The main window must have the focus to receive these keys.

Previously, the behavior varied with the pop-up and the window manager.
Pop-ups would either propagate all key events, or swallow all key events.

The File Selection derivative that pops up with the Edit command now initially
lists the files under Unix/Linux.

The File Selection pop-up now separately prints the tree root directory
and the current directory in the label below the windows.

File Secletion geegaws: 1) folder icons in directory listing, 2) resize handle
between the two windows (Unix/Linux only).

Fixed a bug that would cause occasional crashes when using the Node
Mapping pop-up.

Fixed some html errors in the help text that break Microsoft's shitty
html parser in Internet Explorer, but were not evident under Unix/Linux.

Menu entries containing bitmaps are not disabled in Windows, to avoid the
ugly black square that is supposed to represent such an object.  The
"disabled" status is maintained at application-level.

There is no longer a hard limit (was 50) on the number of subcircuit
connections.

The functions that generate SPICE output now attempt to keep lines below
80 characters, and will add '+' continuations if necessary.

Found an error in the code that establishes connectivity in schematics.
Seems to have caused only inefficiency.

If the Text Editor was started with a filename without a path, the
File Selection pop-up from the Open button would come up empty.
---------------------------------------------------

If a plot point was set over a subcircuit, the program would crash.
---------------------------------------------------
test sLstr!!!!

The build system was revised.

Updated mingw.

Fixed a bug in stackdump.c that prevented mail from working.

fix clip/merge adjacent rects (really?)

Files Listing, cwd doesn't change.  Xic freeze? (Katsuno)

The handling of the fonts used by the various pop-ups has been consolidated
internally.

There is a new Set Font button in the Attributes menu.  This sets the
fixed-pitch font used in most of the pop-ups (any pop-up with a text
area that responds to button clicks, except for the text editor).
Selecting a font and pressing Apply will update the font in all open
windows that use the fixed-pitch font.

The Font button in the text editor now handles a font that is used
exclusively by the text editor.  Previously, this font was shared with
other pop-ups.  Both fixed and proportional pitch fonts are available.

Tech file keywords:
    FontName
    FixedFontName

Changing the current working directory from the File Manager now
updates the Path Files Listing (if the CWD is in the path).  Changing
the CWD with !cd now updates the File Manager.

THe Edit command can now work with paths that contain spaces if the
path is single or double quoted.

gettok, getqtok no have no fixed array size

New generator class for path parsing, handles quoted entries.

// Cwd(path)
//
// This function changes the current working directory to that given
// by the argument.  If path is null or empty, the change will be to
// the user's home directory.  A tilde character ('~') appearing in
// path is expanded to the user's home directory as in a UNIX shell.
// The return is 1 if the change succeeds, 0 otherwise.
//

Rewrote the string-handling functions that manipulate path and file
names, and parse tokens.  Huge amount of work.  The only visible change
should be that most commands accept quoted paths.  Also, there are no
more fixed-size internal arrays that can overrun.

leadint/trailing space clipped in expand_path()
global problem

// (int) RemovePath(path_name, dir)
//
// Remove dir from the path named in the first argument.  See above
// for an explanation of the first argument.  The function returns 1
// if the path is changed, 0 otherwise.
//

When writing a technology file, the order of scripts is no longer
the reverse of the original.

In server mode, command lines to define global variables would fail.

The cif parser can now handle more complex nesting of comments.

The server can now handle arbitrarily long messages.  Previously,
,essage length was limited to 256 bytes.

If in electrical mode, and one uses Create Symbol with terminals being
deisplayed, and the objects selected would cause one or more of the terminals
to be deleted, and the "replace selected objects with new cell" option
is chosen, thr program would likely crash during the redisplay.

In electrical mode, with terminals being shown, if one stretches a wire
or moves a wire vertex with the terminal attached, the terminal location
was not being updated on-screen.

free_talk() in xic.cc

Fixed a bug that would cause program crashes in the vertex editor mode
for wires, if a wire merge occurs, and the operation is undone and
then redone.

The Font panel in the HTML viewer has changed.  It now allows both the
normal and fixed font families to be changed.  The fixed font is used
for the typewriter and preformatted text.  This does not necessarily
have to be a fixed-pitch font, however the display of preformatted columns
 may not be correct unless a fixed-pitch font is chosen.  Pressing the
Apply buttons will update the font in the current help window, and will
update the .mozyrc file in the user's home directory if it exists.
The new mozyrc file, supplied with this release in the startup directory,
must be copied to your home directory or a fixed font change will not be
saved.
-------------------------------------------------------

todo, make all suffix comparisons case insensitive

Fixed logic bugs, incorrect test for empty search path.

avoid static path buffer in pathlist.cc/::files()  This also fixes bug,
extra / in rooted path

(Windows Only)
The Files Listing attempts to monitor the directories for changes, so that
while the listing is visible, if a file is added or removed from the
directory, the change will be shown in the listing.  This is not possible
under Win-95/98/ME, however the code to implement the monitor was being
executed anyway.  This is no longer true, as it is suspected that this
could cause problems (a hung program) under Win-95/98/ME.  Under 95/08/ME,
the listing can be refreshed by resizing the listing window, of by popping
it down then up again.


// (object_handle) JoinObjects(object_handle, lname)
//
// This function will combine the objects in the list passed as the
// first argument, if possible, into a new list of object copies,
// which is returned.  The new objects are placed on the layer with
// the name given in lname, which is created if it does not exist,
// independent of the originating layer of the objects.  If a null
// string or 0 is passed for lname, the target layer will be the layer
// of the first object found in the list passed as an argument.  The
// objects passed are untouched.  The ObjectDelete() function can be
// called to delete the old objects.  The ObjectCopy() function can be
// called on the returned objects to add them to the database.  This
// function returns a handle to the new list upon success, or 0 if
// there are no objects.  The function will fail if the first argument
// is not a handle to a list of objects or copies, or the lname
// argument is non-null and not a vaild layer name.
//
// (object_handle) SplitObjects(object_handle, lname)
//
// This function will split the objects in the list passed as the
// first argument into horizontal trapezoids (polygons or boxes) and
// return a list of the new objects.  The new objects are placed on
// the layer with the name given in lname, which is created if it does
// not exist, independent of the originating layer of the objects.  If
// a null string or 0 is passed for lname, the target layer will be
// the layer of the first object found in the list passed as an
// argument.  The objects passed are untouched.  The ObjectDelete()
// function can be called to delete the old objects.  The ObjectCopy()
// function can be called on the returned objects to add them to the
// database.  This function returns a handle to the new list upon
// success, or 0 if there are no objects.  The function will fail if
// the first argument is not a handle to a list of objects or copies,
// or the lname argument is non-null and not a vaild layer name.
//

The technology file keyword Via now implies DarkField.  This is used by the
Cross Section command.

The Cross Section command will now display layers using the "real"
layer thickness supplied with the Thickness keyword in layer blocks of
the technology file.  If the Thickness is not provided, the default
thickness will be used.  Note that now, the Via keyword in layer blocks
of the technology file implies DarkField, and in the cross section view
the vias will appear as holes, i.e., the polarity is reversed.  The
DarkField keyword should be applied to other layers which are printed
with reverse polarity, for the cross section to be accurate.

All file extension checking is now case-insensitive, e.g., .scr and .SCR
extensions would both be recognized as script files.

The Magn pseudo-property (7207) is now included in the listing for
subcells in the Properties editor (physical mode only).

Boxes that are changed with a pseudo-property assignment are no longer
merged, since 1) the box may have to be moved again, such as after a
magnification, which changes the position, and 2) merging confuses the
Properties Editor.

Last sentence added:
// (int) ObjectSelect(object_handle)
//
// This function will select the object referenced by the handle, if
// is is currently not selected, and the object is in the current
// cell.  The function returns 1 if the object was previously not
// selected and was selected, otherwise 0 is returned.  This function
// will fail if the handle passed is not a handle to an object list. 
// It is not possible to select object copies, 0 is returned if the
// passed handle represents copies.

// (int) ObjectMove(object_handle, refx, refy, x, y)
//
// This function is similar to the Move() function, however it
// operates on the object referenced by the handle only.  The object
// is moved such that the coordinate refx, refy is translated to x, y. 
// If UseTransform() is in effect, the current transform will be
// applied to the move.  The function returns the number of objects
// moved.  This function will fail if the handle passed is not a
// handle to an object list. 
//
// If the handle references an object copy, the copy is translated
// and possibly transformed as described above.  The handle will
// subsequently reference the modified object.
//
// (int) ObjectCopy(object_handle, refx, refy, x, y)
//
// This function is similar to the Copy() function, however it
// operates on the object referenced by the handle only.  The object
// is copied such that the coordinate refx, refy is translated to x,
// y.  If UseTransform() is in effect, the current transform will be
// applied to the copy.  The function returns the number of objects
// copied.  This function will fail if the handle passed is not a
// handle to an object list. 
//
// If the handle references an object copy, the object copy that is
// referenced remains untouched, however the new object, translated
// and possibly transformed as described above, is added to the
// database.
//

The library created after a conversion to Xic cells has bogus paths.
It also contained bogus entries for library devices.

(Windows only)
Clicking on an entry in the Contents list, or other uses of the
general-purpost listing pop-up, would crash the program.

Wow! The subwindow modw switch is broken!

Fixed bug in cross section code that would cause a fault if a new cell
was opened with the cross section display present.

Lots of inapplicable menu entries are now grayed out in the cross section
window.

The Cross Section command is now grayed out in electrical mode.

The thicknesses are scaledproportionally so as to always be visible.
They appear with actual size when one zooms in.

If a layer has the Symbolic keyword given, it will not be shown in
the cross section.

The FreeArray() function was returning 0 on success, it now correctly
returns 1.

(Unix/Linux only)
The internal memory use is now computed more accurately, using the
external memory allocation library now employed.
------------------------------

Fixed bug, handling of directory names with embedded spaces was not
right.  If the Path search path was in (...) form, cell files located
in directories with a space in the full path would not be found.

Change:  The traditional search path format can now include single or
double quoted directory paths.  Quoting is required if a directory path
contains the search path separation character ( ';' for Windows,
':' for Unix).

In library files, if the path contains white space of directory separation
characters, it should be quoted.

The LVS command in the Extract Menu now has its own controlling pop-up.

All log files that grow progressively while Xic is running are now
size-limited in the following way.  If the log file exceeds approximately
100Kb, the file is moved to the same name with a ".0" extension, and
the original log file is reopened.  Thus, a maximum of 200Kb of log
information is retained.

New `!' command: !logfiles
This will bring up a file manager pointing to the temporary directory used
for log files.  "Opening" the entries will bring up a file browser
pop-up loaded with the selected file.

SCRIPTS, open in binary mode for Windows encryption

The interprocess channel to WRspice was broken in the Windows release.
Trying to run WRspice from Xic would hang the program.

New feature: encrypted scripts

This feature allows script files to be encoded so as to be unreadable without
a password.  This allows OEMs to provide script packages to users while
maintaining confidentiality of the script text.

The encryption method is strong enough to foil most attempts at breaking the
code by average users, however t is probably easily broken by experts.
The encryption algorithm is not export-restricted.

Encryption is implemented with two new utilities, which are provided in the
Accessories distribution.  There is also a new script function, and a new
command-line argument to Xic.

The utilities are:
    wrencode file [files ...]
    wrdecode file [files ...]

    Both programs take as arguments lists of files to encode or decode.  At
    least one file must be specified.

    The wrencode program will prompt the user for a password, and for a
    repetition of the password.  The files on the command line will be
    encrypted using this password.

    The wrdecode program will prompt once for a password, and will decrypt
    the files listed in the command line which have been encrypted with this
    password.  They are not touched otherwise.

    These two utilities can be used for general applications.

    WARNING: since the encryption is done in-place, be sure to save a
    non-encrypted  backup of the files.

    The encrption/decryption should be portable between all systems
    that can run the two utilities.

Xic will read plain-text and encrypted scripts.  Encrypted scripts can be
read only if Xic been given the password.  The [assword can be given to
Xic on the command line with the -K option:

    -Kpassword

Note that there is no space between the "-K" and the password.  The password
must be given to Xic if this way if the startup file, or the function library file,
or a script run from batch mode, is encoded.  The password of course match
the password used to encode these files.

It is also possible the change the password when Xic is running with the
SetKey script function:

    (int) SetKey(password)

This function sets the key used by Xic to decrypt encrypted scripts.  The
password must be the same as that used to encrypt the scripts.  This function
returns 1 on success, i.e., the key has been set, or 0 on failure, which
shouldn't happen as even an empty string is a valid password.

At most one password is active at a time.  If the file can not be opened with
the current password, Xic will behave as if the file was empty.


Windows Only
daemon mode wouldn't start due to license problems.
----------------------------------------------------------
Fixed columns in listings, again

removed idle proc in row-select callback in file manager (unix), not needed
and can cause problems if object destroyed before idle proc called.

// (int) HandleArray(handle, array)
// empty or does not reference a list.  The handles in the array of
// handles can be closed conveniently with the CloseArray() function.

// (int) SortArray(array, size, descend, indices)
//
// This function will sort the elements of the array passed as the
// first argument.  The number of elements to sort is given in the
// second argument.  The function will fail if size is negative, or
// will return without action if size is 0.  The size is implicitly
// limited to the size of the array.  The sorted values will be
// ascending if the third argument is 0, descending otherwise.  The
// fourth argument, if nonzero, is an array which will be filled in
// with the index mapping applied to the array.  For example, if
// array[5] is moved to array[0] during the sort, the value of
// indices[0] will be 5.  This array will be resized if necessary, but
// the function will fail if resizing fails.
//
// If the array being sorted is multi-dimensional, the sorting will
// use the internal linear order.  The return value is the actual
// number of items sorted, which will be the value of size unless this
// was limited by the actual array size.
//
New function sub category: Utility Functions/Arrays

Call stack size expanded from 20 to 50
----------------------------------------------------------------

The properties handling of Xic has been enhanced in order to support
subcircircuit parameters as used in WRspice and Hspice.  Subcircuit
parameters are described in the WRspice documentation for the
.subckt line (!help .subckt).

To this end, the "initc" property has been replaced by a new "param"
properety.  The property number is the same, only the name has been
changed in the documentation.  In a few instances, such as the
keywords in device blocks and the labloc property, "initc" was used
as a keyword.  This is still recognized, however the new "param" keyword
is preferred, and is written into files generated by Xic.

Before the present changes, the "initc" designation was already misleading,
as this property was used for things other than initial conditions,
such as length/width/area specification.  The new "param" property
handles these, plus the parameters for subcircuits and subcircuit
instances.  Unlike "initc", the "param" property can be applied to
cells (through the cell properties editor) and instances, in addition
to device instances.

If applied to a cell, subsequently placed instances of the cell will
inherit the same "param" property string.  This of course can be
modified on a per-instance basis.

Like a Stalin-era photo of an out-of-favor aparatchak, all traces of
"initc" have disappeared from the Xic documentation.

The properties editor has changed a bit.  A new Add button replaces the
Name, Model, Value, Initc, and Other buttons.  In electrical mode, Add
produces a drop-down menu containing these buttons (with "Param" replacing
"Initc").  In Physical mode, Add will initiate property addition directly.
It is now possible to add a Param property to a subcell.


The cell properties editor has also changed slightly.  The Add button
produces a drop-down menu as before, with a new "Param" entry active
in electrical mode.  This allows a Param property to be added to
the current cell, allowing the use of parameters within the cell.
The template cell properties are now made insensitive while in
electrical mode.

Here is a brief description of how to use parameterization.  Suppose
that you are editing a cell that contains a resistor, and you wish to
parameterize the resistor.  Give the resistor a value property consisting
of some word, say "rshunt".  Give the cell a param property something
like "rshunt=2.5".  This will give the resistor a default value of 2.5 ohms.
Editing another cell, place two instances of the previous cell.  Note
that "rshunt=2.5" appears in a label next to each instance.  Select
one of the labels, and using the label editor change the string to
"rshunt=1.25".  This will change the resistor value in that instance (only)
to 1.25 ohms.

-----

New ! command: helpfixed fontname
set the fixed font family used by the help system.

The file manager was not treating symbolically linked directories properly
under FreeBSD and Linux2.

Fixes to mozy handling of forms like ./ and ../ in urls.

Fixed mozy problem with png images and transparent layers.

Improved mozy scrolling with form elements (less flicker).

Windows Only:  Won't find release notes if startup files are on another
drive.

DocsDir now set at startup.

Error in sample mozyrc file:
   the default FixedFontFamily should be misc-fixed-normal... and not
   fixed-misc-normal...
----------------------------------------------------------------

Bug fixed:  Uninitialized variable was wreaking havoc in the extraction
system, producing strange results (disappearing contacts, wrong
device numbering, etc).

----------------------------------------------------------------

The measurement logic for extracted MOS devices was not working properly.

The function that handles measurement of source/drain srea and perimeter
was modified to properly handle merged devices.  It should now properly
compute these parameters for isolated single and merged devices.  If
a contact is shared between two devices, e.g., common active layer for
two series-connected MOS devices, the common area and perimeter is shared
equally between the two devices.  This is accomplished by subtracting
half of the area and perimeter of the common contact area from each
device.  This should work whether or not the devices are multi-component
and merging is enabled.

The algorithm does assume that the common contact area is described by
a single trapezoid, so strange geometry may produce incorrect extraction
of these parameters.

Fixed memory warning: object being freed twice.

Node mapping turned on after sourcing physical or spice.

Modified association to better converg when electrical cell was created
from physical.

The association will attach a formal terminal to a Conductor layer is there
are no Routing layers in the net.  A warning will be given in the
associate.log file.  Prefiously, these terminals would not be placed.

Devices in flattened cells (i.e., using !set PnetFlattenPrefix) had area
and perimeter extraction primitives set to 0.
------------------------------------------------------------------

There is now a default password compiled into Xic, which is "qwerty".
This password will be used if no other password is supplied to Xic with
the -K command line option.

This same password must be given to
wrencode in order for Xic to use encoded scripts with the default password.

There is a new utility in the accessories:  wrsetpass [path_to_xic]

This utility will reset the default password in the Xic binary file image
whose path is given as an argument.  The program will prompt for a new
password, then modify the xic program file.  Note that you must have write
permission for the Xic executable (which likely means that you must be
root).

Note that for security the actual password is not saved in the Xic
executable file, only an encrypted version.

The password can contain almost any character.  If the password contains
characters which could be misinterpreted by the shell, the password
should be quoted, e.g., -K'password'.



// (object_handle)
//    ClipIntersectCopy(object_handle1, object_handle2, lname, all1, all2)
// 
// This function returns a list of object copies which represent the
// exclusive-or of box, polygon, and wire objects in the two object
// lists passed.  The lists are not altered in any way, and the new
// objects, being "copies", are not added to the database.  Objects
// found in the lists that are not boxes, polygons, or wires are
// ignored.  The new objects are placed on the layer with the name
// given in lname, which is created if it does not exist, independent 
// of the originating layer of the objects.  If a null string or 0 is
// passed for lname, the target layer is the first layer found in
// object_handle1, or object_handle2 if object_handle1 is empty.  The
// all1 and all2 are integer arguments indicating whether to use only
// the first object in the list, or all objects in the list.  If
// nonzero, then all boxes, polygons, and wires in the corresponding 
// list will be used, otherwise only the first box, polygon, or wire 
// will be processed.  On success, a handle to a list of object copies
// is returned, zero is returned otherwise.  A fatal error is
// triggered if either argument is not a handle to a list of objects.


!split [ v|V|1 ]

If an argument is given that has v,V, or 1 as a first character, the
splitting orientation is along the vertical.  Otherwise, splitting favors
the horizontal orientation.

// (int) Decompose(vert)
//
// The selected polygons and wires are decomposed into elemental
// non-overlapping trapezoids (polygons) similar to the !split
// command.  If the integer argument is nonzero, the decomposition favors
// a vertical orientation, otherwise the splitting favors horizontal.
// The returned value is 0 if called in physical mode, 1 if  
// not called in physical mode (an error).

// (object_handle) SplitObjects(object_handle, lname, vert)
//
// This function will split the objects in the list passed as the
// first argument into horizontal or vertical trapezoids (polygons or
// boxes) and return a list of the new objects.  The new objects are
// "object copies" and are not added to the database.  The new objects
// are placed on the layer with the name given in lname, which is
// created if it does not exist, independent of the originating layer
// of the objects.  If a null string or 0 is passed for lname, the
// target layer will be the layer of the first object found in the
// list passed as an argument.  The third argument is an integer which
// if nonzero indicates a vertical decomposition, otherwise a
// horizontal decomposition is produced.  The objects passed are
// untouched.  The ObjectDelete() function can be called to delete the
// old objects.  The ObjectCopy() function can be called on the
// returned objects to add them to the database.  This function
// returns a handle to the new list upon success, or 0 if there are no
// objects.  The function will fail if the first argument is not a
// handle to a list of objects or copies, or the lname argument is
// non-null and not a vaild layer name.

!layer [join|split|splitv]  new keyword "splitv", similar to "split" but
will use vertical orientation.

// Layer(string, depth, flat)
//
// This is very similar to the !layer command.  The string is of the
// form "[join|split|splitv] new_layer_name layer_expression".  The
// depth is the search depth, which can be an integer which sets the
// ...

giving a url for a directory in ftp protocol to the help viewer would
crash the program.

The httpget program would seg fault in graphics mode.  This prevented
ftp file downloads through the help viewer.

Fixed some problems in handling extra slashes in url's in the help viewer,
for example, http:///something (extra '/') would crash the program, and
http://something/ (trailing slash) would create harmless but unsightly
multiple slashes in child url's.

Empty cells are now displayed by a small highlighting box.  Previously,
these were invisible in the display.

Bugs fixed in help viewer:
    Animated gifs with a transparent layer in table cells would not use
    the correct background.
    The cache date/time check was not working correctly.
    If the first page did not need a vertical scrollbar, and the second
    page did, the second page formatted width was not correct.
    etc.

----------------------------------------------------------

The GetObjectBB() script function was swapping the top and bottom
coordinates of plain boxes that had been processed with SplitObjects()
with the vert argument nonzero.

In the !layer command, forms like "!layer split layername" are now taken
as "!layername split layername = layername", i.e., the split operation
is performed on layername.  Previously, without the explicit "= layername",
no operation was performed, except to create layername if it does not exist.

Major changes to the fill pattern editor.  The confusing logic is gone, and
transfers are now done with drag/drop.  There are now 64 default fillpatterns,
each of which can be used as a storage register.  The default fillpatterns
are now saved in a new startup file named xic_stipples, which is
provided in the startup directory, but can be overridden by the user in
the manner of other startup files.  A button in the fill pattern editor
allows a new xic_stipples file to be dumped into the current directory.
See "!help xic:fill" for the new documentation.

Main changes:
  o  The pattern for the current layer is not automatically loaded into
     the editor when the current layer is changed.  The color used in the
     editor is however the color of the current layer.
  o  Patterns are transferred by drag/drop.  Drag/drop works between:
       the Sample box to/from any default fill box (except for solid and
       empty) or layer in the layer table.  Drag patterns into the Sample
       box to edit them.
       Any default pattern box to any layer in the layer table.
       Any layer in the layer table to any default pattern box except
       solid and empty.  This operation will also set the current layer.
  o  An option menu allows one of four sets of 16 default patterns to
     be displayed.
  o  A Dump Defs button will dump all current default patterns to a
     xic_stipples file in the current directory.  Xic will use this
     file if found in the library search path.

Fixed a buffer overflow bug that would cause trouble if the full path
to a gds file was more than 64 characters.

Change to the fracturing algorithm to make it more faithful to the
horizontal or vertical orientation selected.

Fixed a bug that would cause gif images with a certain data pattern to
hang the help viewer.

Fixed some problems with html frames in the help viewer, the main one being
that frame targets were not being found: either a new window would appear,
or the link would do nothing.

Fixed a bug introduced in the last release:  the help viewer would not
load a page unless the content-length header was provided by the server.
This means that most pages would not load.
----

Fixed bug in handling of the BtnUp() script function, would cause memory
corruption.

Fixed a problem in symbolic electrical cells.  Wires in the SCED layer
would interact with the (invisible) wires of the underlying schematic,
potentially merging with these wires.  This would cause memory corruption
and potentially a program crash.  Also, the dotted-box highlightihg
used to indicate a possible connection when objects are being moved or
created was indicating the invisible circuit contact points.  This is
now turned off in symbolic cells.

Enhancements to the handling of BtnDown(), BtnUp(), KeyDown(), and
KeyUp() functions in scripts.  More of the xic_run.log file can now
execute properly.


// BtnDown(num, state, x, y, widget)
//
// This command generates a button press event dispatched to the
// widget specified by the last argument.  The num is the button
// number; 1 for left, 2 for middle, 3 for right.

true for keys and buttons?
  In Unix/Linux, The state is the
// "modifier" key state at the time of the event, and is the OR or 1
// if Shift press, 4 if Control pressed, 8 if Alt pressed, as in X
// windows.  Other flags may be given as per that spec, but are not
// used by Xic.  Under Windows, the state is a horrible thing
(the lParam for the WM_KEYDOWN message).  See your Win32 documentation
if you really must understand this.

  The coordinates are relative to the window of the
// target.  The widget argument is a string containing a resource path
// for the widget relative to the application, the syntax of which is
// dependent on the specific user interface.  A call to BtnDown should
// be followed by a call to BtnUp on the same widget.  There is no
// return value.
//
// BtnUp(num, state, x, y, widget)
//
// This command generates a button release event dispatched to the
// widget specified by the last argument.  The num is the button
// number; 1 for left, 2 for middle, 3 for right.  The state is the
// "modifier" key state at the time of the event, and is the OR or 1
// if Shift press, 4 if Control pressed, 8 if Alt pressed, as in X
// windows.  Other flags may be given as per that spec, but are not
// used by Xic.  The coordinates are relative to the window of the
// target.  The widget argument is a string containing a resource path
// for the widget relative to the application, the syntax of which is
// dependent on the specific user interface.  There is no return
// value.
//
state = lParam for msw

The macro recording facility has been enhanced.  The following changes
will be noticed by the user:

1)  The argument list to the BtnDown() and BtnUp() script functions has
    changed.

    This means that existing scripts that use these functions will have to
    be updated.  As these functions are not really intended for user scripts,
    it is unlikely that these functions appear in your scripts, unless you
    are a guru.  For compatibility, make the following change:

       BtnUp(num, x, y, widget -> BtnUp(num, 0, x, y, widget)
       BtnDown(num, x, y, widget -> BtnDown(num, 0, x, y, widget)

2)  The four functions BtmDown(), BtnUp(), KeyDown(), KeyUp() can now send
   events to any window that is owned by Xic.  Previously, only the main
   window and viewports could receive events from these functions.  Thus,
   these four functions can now control virtually all of the visual
   interface to Xic.

3) The format of the BtnDown and BtnUp lines used in the macros file
   .xicmacros has is now identical to the script commands.  Thus, the macro
  lines can be executed as script functions.  The reverse is not generally
  true, however.  Macros can use only the four functions mentioned above.

4) When recording a macro, a sequence which would bring up a pop-up now
actually causes the pop-up to appear.  Previously, this did not happen.
In general, memu commands will become active, but most subsequent events
will be swallowed by the macro recorder.  In most cases, you can send
events to the pop-up by performing the actions, which won't be carried
out but will be recorded in the macro.

For example, suppose you want to define a macro that will pop up the
Cell Placement panel and provide a default master name.  Select Key Map
in the attributes menu, and press Return at the prompt.  Then enter the
macro character.  Then drag down the Edit Menu and select Place.  The
Place pop-up will appear, along with a dialog box for the master name
(assuming that no master was previously specified).  Make sure that the
dialog has the key focus, and enter the name of a cell.  Move the pointer
or click to revert the focus to the main window, and press Enter.  Then,
when running Xic the next time, pressing entering the macro character
will bring up the pop-ups with your cell name in the dialog.  Click on
the dialog Accept button to actually enter the master name, not that
you could have included this step in the macro by typing Enter when the
dialog has the focus, and again typing Enter into the main window to
end the macro.

Note that while recording a macro, if a command it initiated that uses
the prompt line, the macro string will be overwritten.  It will come
back after the first event.  However, if the command uses the prompt
line for input, the macro will be terminated.  This will be resolved in
a future release.

Windows only
A reentrancy problem in the timer callback queue was potentially causing
random faults.


The events processed while Xic is in use are recorded in the xic_run.log
file.  This file and other log files are stored in a temporary directory,
which is deleted when Xic terminates normally.  To access the xic_run.log
file from Xic, use the !logfiles command, then select the xic_run.log
entry in the resulting file selector, then press the green octagon on
the file selector.  Advanced users can cut/paste sequences of the
commands into script files or macros.

-----------

fixed screwup in tiny box placement in display.cc

fixed imlib driver to not assume pixel mapping but get it from visual

Changed selecton behavior:  If one click-selects a subcell which is
completely covered by geometry, the subcell will be selected.  Previously,
the geometry would be selected preferentially.  Geometry will still be
selected preferentially over subcells, but not if the geometry completely
covers the subcell.

The !addcells command was not working.

Fixed minor logic inconsistencies in some of the menu button operations.

The !ltab add command would create new layers in the physical layer
table only.  Now, is will create layers in the current mode.

In symbolic mode, the cell bounding box is now forced to enclose all
the cell's terminals.  Previously, terminals could be placed outside the
bounding box (i.e., the symbolic geometry) which would fool some of
Xic's algorithms.

Fixed some strangeness regarding terminal names in electrical mode.  Newly
created instances would not have the terminal names set correctly.  Since
these are set before SPICE output is generated, there was no harm,
except that it was confusing.

**MSW SendKeyEvent with 0 widget should default to prompt line
*** Enter should not terminate macro unless to a drawing window.
Expand->toggle
Zoom->toggle
---------------------------------------------------

The drc error indication for errors in subcells would be shown twice
of the cell was moved, in both the old and new locations.

Fixed some subtle problems with the width command (for wires) and
merging.  This could produce error messages or spurrious wire segments.

The break command would refuse to divide a wire at a vertex location.

added override dup() method to CDp_oset.

fix PopUpErr in mswxic

environment variable XIC_DEBUG turns on debugging message reporting
and certain pop-up warnings about inconsistencies.

check script func for saving obj copies in database.  Have to remove
CDisCopy flag
check cpy_odesc(), set_cpy_odesc_ptr(), these require the flag

added setRef(0) in Terminal destructor

ObjectMove() and ObjectCopy()
Delete  stuff about UstTransform.  The current transform is always used.

mswxic ErrorLogV

finish removing fprintf(stderr from extract
----------------------------------------------------------------

Fixed situations where a 0-width wire would cause trouble, in particular,
if a 0-width wire was selected in the Erase Under command, the program would
likely crash.


When running WRspice from Xic, the WRspice toolbar is now visible by default.
This provides much more flexibility and control over WRspice.  This applies
only when WRspice is located on the local machine, and not when WRspice is
run remotely.

New variable: NoSpiceTools

If this variable is set *before* the connection is established to WRspice,
the WRspice toolbar will not appear.

Fixed a bug: subcircuit devices like the example "opamp" would be assigned
names that clash with ordinary subcircuits.

The device library no longer pops up automatically in electrical mode.

The devices in the pictorial device menu are now alphabetically sorted rather
than random.  Early, these were in order of appearance in the device.lib file,
however that went away with the switch to hash table access many releases
ago.

The maximum argument count (20) was not being enforced, causing memory
overflow crashes if more than thin number of arguments is passed to a
function. This is now enforced, and the limit was raied to 40.

Split xicf1.cc and xicf2.cc into xicf0.cc - xicf4.cc.

Added variable types TYP_ZLIST (trapezoid list) and TYP_LEXPR (layer
expression parse tree).

CHECK THIS
In a schematic, a device or subcircuit will not be included in the SPICE
output unless
 - there are two or more non-ground connections
 - there is one non-ground connection and one or more grounds
 - there is one non-ground connection and no opens
 - there is one non-ground connection and the object is a subcircuit
Previously, a device would be included in SPICE output in every case.

There are major internal changes taking place.  The changes are necessary
to support a more powerful and efficient geometric manipulation and testing 
capablilty.

There are two new types of variables in scripts: zoidlists and
layerexprs.  A zoidlist contains a list of trapezoids.  A layerexpr contains
a parse tree for a layer extression.

It is anticipated that all data objects that are currently "handles" will
become typed variables.  This will avoid the need for maintaining a
separate hash table for handles, and will avoid the hash table lookup
required for each data access.  All attempts will be made to support
existing scripts that use handles.

Properties of zoidlists

The math and logical operators are overloaded for zoidlists as follows

+, |    union
*, &    intersection
^       exclusive or
!       inverse

There is a current "reference" zoid list which represents the "background".
If not explicitly set (with the SetZref()) function, this is taken as the
boundary of the current cell.  The reference is used in operations such as
inversion and exclusive-or where the size of the background must be assumed.
Note that this background can be an arbitrary shape.

In binary operators with zoidlists, if one of the operands is an integer,
0 represents an empty list, and nonzero represents the reference list.

If a zoidlist is given to one of the Print() family of commands, the
coordinates are printed. one trapezoid per line, in order
x-lower-left, x-lower-right, y-lower, x-upper-left, x-upper-right, y-upper

Zoidlists can be assigned from other zoidlists, in which case a copy is
made internally.  If the assigned-to zoidlist already contained a list,
that list is freed from memory.

Properties of layerexprs

These variables can not be assigned, and no operators can be applied.
They can be passed to functions only.

If passed the the Print() family of functions, the layer expression
string will be printed.

Some tweeks to the Mode Mapping panel.  When listing the terminal
names, a function from the extraction package was used.  The problem
is that only "physical" terminals are listed, i.e.  terminals that can
have a physical representation in a layout.  Devices like voltage and
current sources, which are not "physical" devices, would never have
their terminals listed.  A new function will now list all contacts,
whether physical or not.  The name for a non-physical contact is
devicename_contactnum, i.e., the device name, followed by an
underscore, followed by the internal contact number for the device.

When ground is selected in the left panel, the right panel will now
indicate "ground node".  Previously, this panel was not updated.

// (string) TypeOf(variable)
//
// This function returns a string which indicates the type of variable
// passed as an argument.  The possible returns are
//  "none"       variable has no type
//  "scalar"     variable is a number
//  "string"     variable is a string
//  "array"      variable is an array
//  "zoidlist"   variable is a zoidlist
//  "layerexpr"  variable is a layerexpr
//

The C-style pre and post increment/decrement operators are now supported
in scripts.

For scalar variables:

   y = x++  is equivalent to y = x; x = x + 1
   y = x--  is equivalent to y = x; x = x - 1
   y = ++x  is equivalent to x = x + 1; y = x
   y = x--  is equivalent to x = x - 1; y = x

The parser operator precedence table had an error for the not (!) operator.

Previously, !a+b was evaluated as !(a+b), and similar for operators
other than '+'.  Now, this is evaluated as (!a)+b as in other languages.

The operator precedence table is

//    [] ()
//    ++ --
//    ! u-
//    ^
//    * / %
//    + -
//    < <= > >=
//    == !=
//    &
//    |
//    =
//    ,


Variable setting of arrays from the Monitor panel of the debugger was not
working.

If a range is given to a string or array variable in the Monitor, and the
higher index is less than the lower index, the elements/characters are
now shown as reversed, and accepted in reverse order when setting.

// (string) GetLastPrompt()
//
// This functions returns the most recent message that was shown on
// the prompt line, or would normally have been shown if Xic is not in
// graphics mode.  Although the prompt line may have been erased, the
// last message is available until the next message is sent to the
// prompt line.  The text on the prompt line while in edit mode is not
// saved and is not accessible with this function.  An empty string is
// returned if there is no current message.  This function never
// fails.
//

The ClearAll() function, and probably other commands that clear the
database, would fault when freeing cells with associated formal
terminals.

// (zoidlist) BoxZ(l, b, r, t)
//
// This function returns a zoidlist containing a single trapezoid
// which represents the box given in the arguments.  The given
// coordinates are in microns.  This function never fails.
//

// (zoidlist) ZoidZ(xll, xlr, yl, xul, xur, yu)
// 
// This function returns a zoidlist containing a single horizontal 
// trapezoid which represents the horizontal trapezoid given in the 
// arguments.  The six numbers must represent a non-degenerate figure
// or the function will fail.  The given coordinates are in microns.
// 

// (zoidlist) BloatZ(dimen, zoid_list)
//
// This function returns a new zoidlist which is a bloated version of
// the zoidlist passed as an argument (similar to the !bloat command).
// Bloating applies to Manhattan sides only.  Each edge that does not
// touch the edge of another trapezoid in the list will be pushed
// outward or pulled inward by dimen (positive values push outward).
// The dimen is given in microns.  The original list is returned if
// the bloat operation fails on all zoids in the list.  This function
// will not fail.
//

// (int) SetZref(thing)
//
// This function sets the reference zoidlist.  The reference zoidlist
// represents the current "background" needed by some functions and
// operators which manipulate zoidlists.  For example, when a zoidlist
// is polarity inverted, the reference zoidlist specifies the boundary
// of the inversion, i.e., the inverse of an empty zoidlist would be
// the reference zoidlist.
//
// The reference zoidlist can be set from various types of object
// passed as the variable.  This can be a zoidlist, or an object
// handle, or the constant 0, in which case the reference zoid list
// will be the boundary of the current cell.  This is the default if
// no reference zoid list is given.  This function will return 1 and
// never fails.
//

// (zoidlist) ObjectZ(object_handle, all)
//
// This function returns a zoidlist which is generated by fracturing
// the outlines of the objects in the object_handle.  If all is 0,
// only the first object in the list is used.  If all is nonzero, all
// objects in the list are used.  This function will fail if the first
// argument is not a handle to an object list.
//

// (layerexpr) ParseLayerExpr(string)
//
// This function returns a variable which contains a parse tree for a
// layer expression contained in the string passed as an argument.
// The resulting variable is used to rapidly evaluate the layer
// expression within the boundaries of the current reference zoidlist.
// The return value can not be assigned or otherwise maipulated, and
// can only be passed to functions that expect this variable type.
// The function will fail on a parse error in the layer expression.
//

// (zoidlist) EvalLayerExpr(layerexpr, zoidlist, depth, isclear)
// 
// This function evaluates the layer expression passed as the first
// argument.  The first argument can be a string containing the layer
// expression, of a return from ParseLayerExpression().  If the second
// argument is nonzero, it is taken as a reference zoidlist.  If 0,
// the current reference zoidlist (as set with SetZref()) will be
// used.  The third argument is the depth into the cell hierarchy to
// process.  This can be an integer, with 0 representing the current
// cell only, or a string starting with 'a' to indicate use of all
// levels of the hierarchy.  If isclear is 0, the returned zoidlist
// will represent all areas within the reference where the layer
// expression is "true".  if isclear is nonzero, the complement
// regions will be returned.  The function will fail on a parse or
// evaluation error.
//

// (int) TestCoverage(layerexpr, zoidlist, testfull)
//
// This function will return an integer value indicating the coverage
// of the layer expression given in the first argument over the
// regions described in the second argument.  The first argument can
// be a string containing a layer expression, or a return from
// ParseLayerExpression().  If the second argument is 0, the current
// reference zoidlist as set with SetZrev() is assumed.  If the
// testfull argument is 0, the return values are 0 if there is no dark     
// area, and 1 if dark areas exist.  If testfull is nonzero, an
// additional return value of 2 is returned if the zoidlist is
// completely covered by the layer expression result (i.e., completely
// dark).  This latter test if somewhat more expensive.  The function 
// will fail on a parse or evaluation error.
// 

// (object_handle) ZtoObjects(zoidlist, lname, join, to_dbase)
// 
// This function will create a list of objects from a zoidlist.  The
// objects will be created on the layer whose name is given in the
// second argument, which will be created if it does not already
// exist.  If this argument is 0, the current layer will be used.  If
// the join argument is nonzero, the objects created will comprise a
// minimal set of polygons that enclose all of the trapezoids.  If the
// join argument is 0, the objects will be have the same geometry as
// the individual trapezoids.  If the to_dbase argument is nonzero,
// the new objects will be added to the database.  Otherwise, the new
// objects will be "copies" that can be manipulated with other
// functions that accept object copies, but they will not appear in
// the database.  The function will fail if not called in physical
// mode, or the layer could not be created.
//


TYP_HANDLE
assignment ok
conditionals ok (like scalar)
math ops bad
overload ++ (return handle, call iterator)
overload istrue (0->empty handle)

todo:
all returns: new type
all args: new type
functns.c, add type to conditionals


Handle alloc succeeds: TYP_HANDLE, content != 0
fails: TYP_SCALAR, content = 0

xicf2.cc
IFlistHandle() : consolidate print
IFsizeof: new types


IFgetDims duplicated?
move to Arrays functoins
// (int) ArrayDims(out_array, array)
// 
// This function returns the size (number of storage locations) of an
// array, and possibly the size of each dimension.  Arrays can have
// from one to three dimensions.  If the first argument is an array
// with size three or larger, the size of each dimension of the array
// in the second argument is stored in the first three locations of
// the first argument array, with the 0'th index being the lowest  
// order.  Unused dimensions are saved as 0.  If the first argument is
// an integer 0, no dimension size information is returned.  The size
// of the array (number of storage locations, which should equal the
// product of the nonzero dimensions) is returned by the function.

// (int) GetDims(array, array_out)
//
// This is for backward compatibility.  This function is eqivalent to
// ArrayDimension(), but the two arguments are in reverse order.
// This function may disappear - don't use.
//


NEW
// (int) ArrayDimension(out_array, array)
//
// This function is very similar to ArrayDims(), and the arguments 
// have the same types and purpose as for that function.  The return
// value is the number of dimensions used (1-3) if the second argument
// is an array, 0 otherwise.  Unlike ArrayDims(), this function does    
// not fail if the second argument is not an array.
// 

If a handle is passed to the Print() family of functions, a string
giving the type of handle will be printed.

NEW
// (int) SetPrintLimits(num_array_elts, num_zoids)
//
// While printing with the Print() family of functions, or when using
// ListHandle(), the number of array points and trapezoids actually  
// printed is limited.  The default limits are 100 array points and 20
// trapezoids.  This function allows these limits to be changed.  A
// value for either argument of -1 will remove any limit, non-negative
// values will set the limit, and negative values of -2 or less will
// revert to the default values.  This function always returns 1 and
// never fails.


// (int) Sizeof(arg)
//
// This function returns the allocated size of the argument, which is
// mostly useful for determining the size of an array.  The return
// value is
//
//   string length          arg is a string
//   allocated array size   arg is an array
//   number of tarapezoids  arg is a zoidlist
//   1                      arg is none of above
//

ClipAroundAllCopy return type in docs should be handle

no height argument
// (int) Label(text, x, y, width)
// 
// This function creates a label on the current layer.  The first
// argument is of string type and contains the label text.  The next
// two arguments specify the x and y coordinates of the reference
// point, which is dependent on the current justification as set with
// the Justify() function.  The default is the lower-left corner of
// the bounding box.  The width specifies the width of the bounding
// box.  This provides the functionality of the label menu button.    
// 

istrue:  for all booleans (int)var == 0  overflow?
         arrays, v[0] tested.

handle math

need == != for handles and scalars
logical opts use istrue()
++ implemented

strcmp functions, incl overloads
 null/null returns 0
 null/!null returns 1
 !null/!numm returns strcmp() for funcs, boolean for ==/!=

check iterators!

// (int) ObjectNext(object_handle)
//
// This function is called with a handle to a list of objects, and
// causes the handle to reference the next object in the list.  If
// there are no more objects, the handle is deleted, and this function
// returns zero.  Otherwise, 1 is returned.  This function will fail
// if the handle passed is not a handle to an object list.
//

// (int) HandleNext(handle)
//
// This function will advance the handle to reference the next element
// in its list, for handle types that reference a list.  It has no
// effect on other handles.  If there were no objects left in the
// list, or the handle was not found, 0 is returned, otherwise 1 is
// returned.
//

// (int) PrptyNext(prpty_handle)
//
// This function causes the referenced property of the passed handle
// to be advanced to the next in the list.  If there are no other
// properties in the list, the handle is freed, and 0 is returned. 
// Otherwise, 1 is returned.  The number of remaining properties can
// be obtained with the HandleContent() function.
//

handle + handle overrides HandleCat

HandleArray() numeric values!  must convert to handle

is array[0] = handle ok?  scalar = handle?

// (int) HandleArray(handle, array)
// 
// This function will create a new handle for every object in the list
// referenced by the handle argument, and add that handle identifier 
// to the array.  Each new handle references a single object.  The
// array argument is the name of a previously defined array variable.
// The array will be resized if necessary, if possible.  It is not
// possible to resize an array referenced through a pointer, or an
// array with pointer references.  The function returns 0 if the array
// cannot be resized and resizing is needed.  The number of new
// handles is returned, which will be 0 if the handle argument is
// empty or does not reference a list.  The handles in the array of
// handles identifiers can be closed conveniently with the 
// CloseArray() function.  Since the array elements are numeric
// quantities and not handles, they can not be passed directly to 
// functions expecting handles.  The H() function should be used to
// create a temporary handle variable from the array elements when a
// handle is needed:  for example, HandleNext(H(array[2])).
//
// (handle) H(integer)
// 
// This function creates a handle from an integer variable.  This is
// needed for using the handle values stored in the array created with
// the HandleArray() function, or otherwise.  Array elements are
// numeric variables, and can not be passed directly to functions
// expecting handles.  This function performs the necessary data
// conversion.  Example:  SomeFunction(H(handle_array[3]))
//
// Array elements are always numeric variables, though it is possible
// to assign a handle value to an array element.  In order to use as a
// handle an array element so defined, the H() function must be
// applied.  Since scalar variables become handles when assigned from
// a handle, the H() function should never be needed for scalar
// variables.
----------

// (int) ShowPrompt(arg_list)
//
// Print the values of the arguments on the prompt line.  The number
// of arguments is variable.
// Example:
//    a = 2.5
//    b = "The value of a is "
//    ShowPrompt(b, a)
// will print "The value of a is 2.5" on the prompt line.
//
// If given without arguments, the prompt line will be erased, but
// without disturbing the current message as returned with
// GetLastprompt().  The function returns 1 if something is printed
// (message updated), 0 otherwise.
//

macros can now start with and contain underscores.
this includes defines in tech file and scripts

For any script which is read from a file (not counting the technology file)
the token THIS_SCRIPT is effectively #define'd to be the name of the
script (for scripts launched from the User Menu) or a path to the file.
Thus, in the script, the token THIS_SCRIPT is replaced by the file name.

The default filename when saving GDSII and CIF files shown on the prompt
line was garbled or missing.
--------------------------------------------------------------------

Rewrote the section that handles layers.  There is now no internal
limit on the number of layers that Xic can create internally.  Previously,
these had hard limits due to fixed-size arrays (128 physical, 16
electrical).

New generator class to iterate through layers.  New layer access methods.

Changes to almost every file in the program, beware bugs.

GDS reader changes

If a new layer is created, the name will be in the form
   NoMapDatatypes set
     hhXX     (hh is the hexadecimal value of the GDSII layer number,
               XX is literal)
   otherwise
     hhhh     (The left two h's represent the hexadecimal value of the
               GDSII layer number, the right two h's represent the
               hexadecimal value of the GDSII data type number)

   Example:   0EFF   layer 15, datatype 255

Previous behavior
    NoMapDatatypes set
      GDS layer number < 100
       dd00
      else
       ddd0
                (ddd is the decimal value of the GDSII layer number)
    Otherwise
      GDS layer number < 100 and data type < 100
        dddd    (left tw d's are layer, right two are data type
      else
        dddU    (ddd is the layer number, U is literal, all datatypes
                 mapped to this layer)

The previous method had obvious problems in mapping three digit layer
and datatype numbers into a four-character name. 


Previously, of an existing Xic layer had no GDS import layer mapping, but had
an export mapping for a GDSII layer number and any GDSII data type, when
reading GDSII input from that layer that does not otherwise have a mapping
to an existing Xic layer, the input data would be mapped to the Xic layer,
independent of data type.  This is no longer true.

Present logic
   loop through existing Xic layers {
      if Xic layer nas no GDS input mapping {
         if Xic layer output mapping matches GDSII layer {
             if NoMapeDatatypes
                 (use this layer)
             else if (output mapping datatyep matches GDSII datatyps
                 (use this layer)
         }
      }
   }


Previously, if an Xic layer name was numeric, and it had no GDS input mapping,
then when reading GDSII input on a layer number that matches the layer name,
all input from that layer, independent of data type, would map to that layer.
This is no longer true.

Present logic

   Print layer_name
      (NoMapDatatypes set: hhXX, otherwise hhhh)
   loop through existing Xic layers {
       If Xic layer name matches layer_name
           (use this layer)
   }

As before, a new layer is created if no existing layer can be found to
map to.


// (int) SetCurLayerAlias(longname)
//
// This function sets the long name of the current layer to the string 
// given as an argument.  The long name is optional secondary name for   
// a layer.  Most if not all functions that take a layer name argument
// will also accept a long name.  The long name can contain any
// characters, but it should not match the short or long name of
// another layer.  Matching of the long name, as with the regular 
// name, is case-sensitive.  The function returns 1 if the long name
// is applied to the current layer, 0 if there is no current layer.
//

// (string) GetCurLayerAlias()
//
// This function returns a string containing the long name of the 
// current layer.  If no long name has been set, a null string is
// returned.
//

If a layer name in the technology file is not a valid CIF layer name,
the following will happen:
    any characters the first four will be truecated
    any characters that are not alphanumeric will be replaced with 'X'
    the original name will be saved as the long name of the layer.

// (int) NewCurLayer(name)
// 
// The current layer is set to the named layer.  If the named layer
// does not exist, it will be created.  If the name is not a valid CIF
// layer name (four characters maximum, all alphanumeric) and a new
// layer is created, its name will be truncated to the first four
// characters, and any non-alphanumeric characters are replaced with
// 'X'.  The original name will be saved as the long name (alias) for
// the new layer.  The function will fail if the name is null, empty,
// or contains only white space.
// 

In !layer command and equivalent that takes the layername[.cellname]
symtax, layername can be a long name.  Both layername ance cellname can be
double quoted, and should be quoted if the name contains a '.'.

When using Source Physical, and the physical part has no extracted
electrical information, and the clear option was selected, the
cell would not be cleared.  In the present release, the electrical
cell will be cleared in this circumstance.

Tried to address a long-standing logic error in the undo system.  The
Source Physical command, if given in electrical mode, will place undo
information in the physical mode undo list, even though most if not all
of the operations are changes to the electrical database.  When one
switches to electrical mode and starts making changes, the pointers to
objects in the electrical database that are contained in the physical
mode undo list were not being purged when an electrical object is
deleted.  The bad pointers would cause "mysterious" program crashes.
An attempt has been made to avoid this problem by purging the undo
history for both modes when any object is deleted.


// (object_handle) FilterObjects(object_list, template_list, touchok,
//   useall, remove)
//
// This function creates a handle to a list of objects that is a
// subset of the objects contained in the object_list.  The objects in
// the new list are those that touch or overlap objects in the
// template_list, which is also a handle to a list of objects.  If
// touchok is nonzero, objects in the object list that touch but do
// not overlap the template object(s) will be added to the new list,
// otherwise not.  If useall is nonzero, all of the objects in the
// template_list will be used for comparison, otherwise only the head
// object in the template list will be used.  If remove is nonzero,
// objects that are added to the new list are removed from the
// object_list, otherwise the object_list is not touched.  The
// function will fail if the handle arguments are of the wrong type. 
// The return value is a new handle to a list of objects.
//

// (object_handle) FilterObjectsA(object_list, array, array_size, touchok,
//   remove)
//
// This function creates a handle to a list of objects, which consist
// of the objects in the object_list that touch or overlap the polygon
// defined in the array.  The array_size is the number of x-y
// coordinates represented in the array.  In the array, the values are
// x-y coordinate pairs representing the polygon vertices, and the
// first pair must match the last pair (i.e., the figure must be
// closed).  The values are specified in microns.  If touchok is
// nonzero, objects that touch but do not overlap the polygon will be
// added to the list, otherwise not.  If remove is nonzero, objects
// that are added to the new list are removed from the object_list,
// otherwise the object_list is not touched.
//
// The function will fail if array_size is less than 4, or the size of
// the array is less than 2Xarray_size, or if the handle argument is
// not a handle to a list of objects.  The return value is a new
// handle to a list of objects.
//

When .panic files are written during a crash, these files will always
be written in the current directory.  Previously, Xic cells would
be written in the directory of the source  for the cell file.

During a panic, a file named xic_panic.log is created in the current
directory, if possible.  This contains log messages emitted when
modified cells are dumped, and other information.

When reading/writing files, inability to open a log file is no longer a
fatal error.  You just won't have a log file.

When Xic scans its memory and prompts the user whether to save modified
cells, such as just before quitting, a new pop-up will appear rather
than prompts on the prompt line.  The pop-up displays a listing of all
modified cells and hierarchies, each with a yes/no entry that can be
toggled by the user to set whether the cell or hierarchy will be saved.
The display has four columns.  Column 1 gives the name of the cell, which
for a hierarchy is the top level cell.  The second column us "yes" or "no".
Clicking on this word will toggle between the two states.  The buttons
will set the states of all these words: Save All sets them to "yes",
Skip All sets them to "no".  The third column gives the type of file
that will be created or updated: 'X' for Xic native, 'C' for CIF, 'G'
for GDSII, 'E' for EDIF-200, and 'O' for OCT.  The fourth column is the
full path name of the file that will be written if the second column is
"yes".  While the pop-up is visible, all other controls, including the
window delete button, are inoperable.  Pressing Apply will save the
files, delete the pop-up, and allow Xoc to continue.

MSW: path_canon() in OpenFileDlg()

Added a function to strip forms like /./ and /../ out of the paths
used for cell files.  These are harmless but unsightly.

Added color to the yes/no toggles of the Merge Control, Empty Cells,
and Modified Cells pop-ups.

In the Modified Cells pop-p, the file type code is shown in color.  The
color used for archives (CIF, GDSII, EDIF) is different than the color used
for single-cell files (Xic, OCT).

Consolidated all of the colors allocated in various pop-ups and elsewhere.
These can now be set by the user by setting certain variables to the name
of a color.  These are listed in the table below

variable               default             use
pop_color_no            red                Merge Control, Empties, Modified
pop_color_yes           darkgreen          Merge Control, Empties, Modified
pop_color_hl1           red                Debug, Keys Pressed "insert"
pop_color_hl2           blue               Modified
pop_color_hl3           violet             Modified
pop_color_hl3           cyan
------

New technology file keywords

LongName name

This can appear in layer blocks.  The long name for the present layer is
set to the name given.  If no non-space characters follow the keyword,
the statement is ignored.

Description string

This can appear in layer blocks.  The string following the keyword is
saved in the description field of the present layer.  In no non-space
characters follow the keyword, the statement is ignored.

The Conversion Parameter Editor pop-up now allows editing of the
LongName and Description fields of the layers.

// (int) SetCurLayerDescr(descr)
//
// This function sets the description of the current layer to the 
// string given as an argument.  The description is an optional text
// string associated with the layer.  The function returns 1 if the
// description is applied to the current layer, 0 if there is no
// current layer.
//

// (string) GetCurLayerDescr()
//
// This function returns a string containing the description of the
// current layer.  If no description has been set, a null string is
// returned.
//

In exiting, after the Modified Cells pop-up goes down, there is a
final confirmation prompt to exit Xic.  The exit can be aborted at
this point.

Convert/Edit GDSII Keys --> Edit Parameters

Applying the !bloat command to a non-manhattan polygon would cause a
program crash.

// (object_handle) SelectHandleTypes(types)
//
// This function returns a handle to a list of objects that are
// currently selected, but only the types of objects specified in the
// argument are included.  The argument is a string which specifies
// the types of objects to include.  If zero or an empty string is
// passed, all types are included, and the function is equivalent to
// SelectHandle().  Otherwise the characters in the string signify
// which objects to include:
//
//      'b'   boxes
//      'p'   polygons
//      'w'   wires
//      'l'   labels
//      'c'   subcells
//
// For example, passing "pwb" would include polygons, wires, and boxes
// only.  The order of the characters is unimportant.
//

The keyword in the display for the DRC Rule Editor, Convert Parameter Editor,
and Extraction Parameter Editor pop-ups is now displayed in color.

The Properties and Cell Properties pop-ups now use color.  The color code
is
sienna:  ordinary (user-modifiable) properties
dark blue:  pseudo-properties (physical mode)
black:  internal properties

-----

Windows Only
Lots more colors are now available by name from the Set Color pop-up.
In particular, all of the names from the X-window system are recognized.
Previously, only a subset of these colors were available.

In the file selection pop-up family, double-clicking on a file name
is now the same as pressing the green "Go" button.

The font used in the main window for the prompt line ans coordinate readout
can now be specified.

When Xic starts, it looks for a 12pt fixed-pitch font in the following
families:
    Lucida Console
    Courier new
    Courier

If for some reason the Lucida Console font is not available, one of the Courier
fonts will be used.  These are smaller than the Lucida Console font, and are
more difficult to read.  Lack or the Lucida font may explain conplaints
about this font being hard to read.

To set the screen font, create a file in the startup directory named
"mswscreenfont".  The startup directory is usually
c:/usr/local/lib/xictools/xic (or xicii).  This file contains one line of
the form
   (size)FontName
for example
   (12)Lucida Console
or
   (14)Courier New

With this file in place, the specified font and size will be used, if it
is available on the system.  The name of any mono-spaced font that exists
on your system can be used.

Xic will now extract the capacitance of all wire nets during extraction.
The capacitance, along with some other information, will be printed in
the physical netlist output, it "Net" is selected.  The capacitance shown
applies only to the conductors included in or prompted to the current
cell (recall that wire-only subcells are essentially flattened for
extraction purposes).  The capacitance will only be printed if nonzero.
To extract the capacitance of a routing layer, the Capacitance keyword
must be supplied for that layer, in the technology file or with the
Extraction Parameter editor.  This keyword provides the capacitance
per square micron and capacitance per micron parameters.  These parameters
are used to obtain the capactiance using the area and perimeter of each
distinct polygon in the wire net, by multiplication.  Also listed in the
netlist for each net are the routing layers used, and the area and perimeter
for each layer (microns).

If the boolean vairable PnetShowGeometry is set, each group in the
netlist will provide a listing of the objects in the group.  The listing
is in modified CIF syntax, where 1000 units corresponds to one micron.

Pnet script func needs ShowGeometry

The pop-ups for Dump Physical Netlist, Dump Electrical Netlist,
Source SPICE, and Source Physical have been updated.  Now, there is
a corresponding !set variable for each of the check boxes.  If the
variable is changed while the pop-up is visible, the pop-up will be
updated.

Button              Variable               New
Source Physical
all devs            NoExsetAllDevs         *
create              NoExsetCreate
clear               ExsetClear             *
include wire cap    ExsetIncludeWireCap    *

SourceSpice
all devs            SourceAllDevs
create              SourceCreate           *
clear               SourceClear            *

Dump Electrical
net                 NoEnet                 *
spice               EnetSpice              *
bdnet               EnetBdnet              *

Dump Physical
net                 NoPnet
devs                NoPnetDevs
spice               NoPnetSpice
bdnet               PnetBdnet
show geometry       PnetShowGeometry       *
include wire cap    PnetIncludeWireCap     *

The popup check box will be checked if the corresponding variable is
set, unless the variable name has a "No" prefix, in which case the logic
is reversed.  Changing the state of the check box will set/unset the
corresponding variable.

Fixed memory problem in design rule editor
MSW !!!!!!

The Source Physical pop-up has a new option button "include wire cap".
If selected, the computed capacitance of the interconnects is included
in the electrical update.

Extracted wire capacitors have a name prefix "C@NET".

The following script functions have been modified.  Although the
functionality is the same or expanded, the argument lists are
completely different from previouslreleases.  A "mode string" argument
is supplied instead of multiple boolean flag arguments.  See the
help system for documentation.

// (int) DumpPhysNetlist(filename, depth, modestring)
// (int) DumpElecNetlist(filename, depth, modestring)
// (int) SourceSpice(filename, modestring)
// (int) ExtractAndSet(depth, modestring)

Internal consolidation of variables into single data struct.

In electrical mode, is a property label is too long, the text is not
shown, but rather a small open box at the label origin.  However, the
full bounding box was used for selections, and was highlighted when
the label was selected.  Now, only the small box is sensitive for
selection, and is highlighted.

However, when the label is highlighted during a move or stretch, the
"real" bounding box is shown.

The MexPrpLabelLen variable should be set to a larger value, or the
label text size shrunk, to make the labels visible.  The text of a
non-printed label can be obtained from the Info command in the View
menu.

!exset now has [-[n]w] option

list all cells  added to pnet check boxes

PnetFlattenPrefix -> FlattenPrefix

Fixed bug in gds reader.  If a GDSII layer was mapped to more than one
Xic layers, conversion of labels would fail with a memory fault.
--------------------------------

Added DECclass::errLayer function

UPDATE properties script!!!

New '!' command:

  !errlayer layer_name prpty_num

This command will create a polygon on layer_name corresponding to the
error regions currently stored in the list of design rule errors.  The
layer will be created if it does not already exist, and will be cleared
before updating.  All objects are created in the current cell.  The
second argument is an integer greater than 0 that is taken as a
property number.  Each created object will be given a property with
this number, and the text being the error message for the error.

added geomXXX script functions

If a layer has no rules, a garbage string would be printed in the
DRC Rule editor.

User DRC rules was broken (evaluation function stack pointer problem)

New user DRC rule functions:

// (int) DRCuserTest(indx)
//
// Return 1 if the test region is not empty, 0 otherwise.

// (int) DRCuserEmpty(indx)
//
// Return 1 if the test region is empty, 0 otherwise.

// (int) DRCuserFull(indx)
//
// Return 1 if the test region is fully covered, 0 otherwise.

// (zoidlist) DRCuserZlist(indx)
//
// Return the zoids clipped from the test region.

// (int) DRCuserEdgeLength(indx)
//
// Return the length of the test segment along the edge.

EGAD! the !layer command was broken

!join command and similar: if in layer-specific mode, only selected objects
on the current layer will be joined.  Function was rewritten.

A new resizing algorithm is used in the !bloat command and elsewhere for
bloat operations.  Unlike the previous algorithm, this one works with
non-manhattan geometry.  It works by creating the same "halo" as used in
the DRC tests to either expand the objects or clip the objects depending
on whether we are growing or shrinking.  For best results, do a !join
before applying a bloat operation.
DESCRIBE algorithm

// (int) ZtoTempLayer(longname, zoidlist, join)
//
// This function creates a temporary layer using longname, and adds
// the content of the zoidlist to the new layer, in the current cell. 
// If the temporary layer for longname exists, it will be used, with
// existing geometry untouched.  If join is nonzero, the zoidlist will
// be added as a minimal set of polygons, otherwise each zoid will be
// added as a box or polygon.  The function returns 1 on success, 0
// otherwise.  This works in physical mode only.

All functions that take a zoidlist argument, that argument can be
   a zoidlist (obviously)
   0          (implies the reference zoidlist)
   a string   (the string is parsed as a layer expression, which is evaluated,
              and the result returned)
   a layerexpr (evaluate layer expression, return result)

// (int) ClearTempLayer(longname)
//
// This function will clear all of the objects in the current cell
// from the given layer, without saving them in the undo list.  If
// successful, 1 is returned, otherwise 0 is returned.  This works in
// physical mode only.
//
// (zoidlist) gromAnd(zoids1 [,zoids2])
// 
// This function takes either one or two arguments, each of which is
// either a zoidlist, or 0 to represent the reference zoidlist, or a
// string giving a layer expression, or a layer expression type.  If
// one argument is given, the return is a zoidlist consisting of the
// intersection regions between zoids in the argument list.  If two
// arguments are given, the return is a list of intersecting regions
// between the tow argument lists.
//

// (zoidlist) geomAndNot(zoids1, zoids2)
//
// This function takes two arguments, each of which is either a
// zoidlist, or 0 to represent the reference zoidlist, or a string
// giving a layer expression, or a layer expression type.  The return
// is a list of regions covered by the first list that are not covered
// by the second.
//
// (zoidlist) geomCat(zoids1, ...)
//
// This function takes one or more arguments, each of which is either
// a zoidlist, or 0 to represent the reference zoidlist, or a string
// giving a layer expression, or a layer expression type.  The return
// is a list of all regions from each of the arguments.  There is no
// attempt to clip or merge the returned list.
//
// (zoidlist) gromNot(zoids)
//
// This function takes one argument, which is either a zoidlist, or 0
// to represent the reference zoidlist, or a string giving a layer
// expression, or a layer expression type.  The return is a list of
// zoids representing the areas of the reference area not covered by
// the argument list.
//
// (zoidlist) geomOr(zoids, ...)
//
// This function takes one or more arguments, each of which is either
// a zoidlist, or 0 to represent the reference zoidlist, or a string
// giving a layer expression, or a layer expression type.  The return
// is a list of all regions from each of the arguments, merged and
// clipped so that no elements overlap.
//
// (zoidlist) geomXor(zlods1 [,zoids2])
//
// This function takes one or two arguments, each of which is either a
// zoidlist, or 0 to represent the reference zoidlist, or a string
// giving a layer expression, or a layer expression type.  If one
// argument is given, the return is a list of areas where one and only
// one zoid from the argument has coverage (note that this is not
// exclusive-or, in spite of the function name).  If two arguments are
// given, the return is the exclusive-or of the two lists, i.e., the
// areas covered by either list but not both.
//
--------------------------------------------------------------

*** trace toPolyAdd, propagate XIrt

fix doc above 0-->empty, nonzero-->ref_zlist

// (zoidlist) GetZlist(layername, depth)
//
// This function returns a zoidlist from the layer given in the first
// argument, which has the form layername[.cellname].  If the cellname
// extension is not given, the current cell is assumed.  The second
// argument is the hierarchy depth to search, which can be a
// non-negative integer or a string starting with 'a' to indicate
// "all".  If not called in physical mode, an empty list is returned.

The layer expression parser and evaluation functions were more fully merged
with the regular script functions.
Changes:  the divide operator '/' and unary minus are no longer allowed
in layer expressions.
The following functions are allowed:
    sPTfunc( "bloat",                  2,  IFbloatZ ),
    sPTfunc( "box",                    4,  IFboxZ ),
    sPTfunc( "zoid",                   6,  IFzoidZ ),
    sPTfunc( "geomAnd",          VARARGS,  IFgeomAnd ),
    sPTfunc( "geomAndNot",             2,  IFgeomAndNot ),
    sPTfunc( "geomCat",          VARARGS,  IFgeomCat ),
    sPTfunc( "geomNot",                1,  IFgeomNot ),
    sPTfunc( "geomOr",           VARARGS,  IFgeomOr ),
    sPTfunc( "geomXor",          VARARGS,  IFgeomXor ),

New !set variable: SpiceListAll (boolean)
When set, all devices and subcircuits in the schematic will be included in
SPICE output.  Otherwise, only devices and subcircuits that are connected
will be included.

changed:
// (int) ClearLayerGdsInMap(lname)
//
// This function deletes all of the GDSII input mappings applied to
// the layer named in the argument.  These mappings may have been
// applied through the technology file, added with the Conversion
// Parameter Editor, or added with the AddLayerGdsInMap() function. 
// This function returns -1 if the layer name does not exist in the
// symbol table for the current display mode (physical or electrical). 
// Otherwise, the return value is the number of mapping records
// deleted.
//

Fixed major f-up in listutil.cc

mozy bugs:
   <a name=xxx></a> would leave a space if embedded in a word
   gif decoder has an infrequent image corruption problem
   The font selector pop-up would always set the .mozyrc file to a fixed
    font
   Font names with white space such as "b&h-luxi sans" now work in the
   .mozyrc file.

The first shot at a Cadence compatibility package is now available, through
a new technology file keyword:

    ReadCds  filename

This can appear anywhere in the technology file, and will cause Xic
to read information form the Cadence technology file given in filename.
This should be a full path to the file, unless the file is in the
library search path.

Presently, there are two types of Cadence startup files that are understood:
the Design Resource File, and the ascii Technology File.  Although the
names may vary, the design resource file in our installation is named
"display.drf" and the technology file is named "techfile.txt".

The design resource file must be read first, i.e., there should be two
calls to ReadCds, first with the design resource file, then for the
technology file.  A minimalist Xic technology can consist of these two
statememts.  This will set the layers and their colors, fill patterns,
and some of the electrical information.

This feature is rapidly evolving and will be documented more fully later.

The server mode was mot operating properly when the return value was a
zoidlist, layerexpr, or a handle.  Somehow, this was overlooked when
these new types were added.

There are two new directives in the server protocol
  longform
    When given, the server will be placed in a mode where data from the
    current expression will be returned after each command.

  shortform
    When given, the server will be placed in a mode where only the data
    type is returned from each command.  This is the default.

Previously, the default was to return all the data, as if "longform"
were given.  This is egregiously stupid, since most of the time the
return values are not used, and the data, which can be sizeable, has
to be transmitted across the network.
-------

If the client crashes, the server would hang.  This should no longer
be true.

// (zoidlist) BloatZ(dimen, zoid_list)
//
// This function returns a new zoidlist which is a bloated version of
// the zoidlist passed as an argument (similar to the !bloat command). 
// The dimen is given in microns.
//
// (int) SetZref(thing)
//
// This function sets the reference zoidlist.  The reference zoidlist
// represents the current "background" needed by some functions and
// operators which manipulate zoidlists.  For example, when a zoidlist
// is polarity inverted, the reference zoidlist specifies the boundary
// of the inversion, i.e., the inverse of an empty zoidlist would be
// the reference zoidlist.
//
// The reference zoidlist can be set from various types of object
// passed as the variable.  This can be a zoidlist, or an object
// handle, or the constant 0, in which case the reference zoid list
// will be the boundary of the physical current cell, or a large
// "infinity" box if there is no current cell.  This is the default if
// no reference zoid list is given.  This function will return 1 and
// never fails.
//
Fix all of these
// (zoidlist) geomAnd(zoids1 [,zoids2])
//
// This function takes either one or two arguments, each of which is
// taken as a zoidlist after possible conversion as described in the
// heading for thes section.  If one argument is given, the return is
// a zoidlist consisting of the intersection regions between zoids in
// the argument list.  If two arguments are given, the return is a
// list of intersecting regions between the tow argument lists.
//

The tcl/tk script interface was broken for functions returning the
new data types (zoidlists, layerexprs, and handles).  Support for handles
has been re-established, hoewver the form in TCL is a little different.
Previously, handles were simply integer values.  Now handles arre in the
form of a text string <xic-handle>N, where N is an integer.  However, if
the handle is closed, it is always the value 0.  Thus, code like

     set tclvar [ xic func_returning_handle ... ]
    if { $tclvar == 0 } {
       handle is empty
    }
can be used to detect an empty or closed handle.
-----------------------------------------------------

Update the the license server and interface.

New server commands:
    dumpmsg
    nodumpmsg

If dumpmsg is given, messages received by Xic in server mode are printed
to standard output, enclosed in '|' symbols to delineate the string.
Normally, this will be invisible, unless the output is redirected to
a file ("xic -S > dumpfile").  This may be useful for debugging.  The
nodumpmsg comand turns the feature off.

Repaired problem with conicident object merging, merging of these objects
could cause faults when reading CIF or native files.

spiralform demo was broken

The GDSII reader would not convert files with records longer that 4800
bytes.  Now, up to 16Kb records are accepted, implying that polygons
and paths can have up to 8000 points.

The GDSII is inconsistent on the number if vertices allowed in polygons.
The Cadence document for GDSII Release 3 specifies 600 vertices, yet
elsewhere 200 vertices is given.  Previously, Xic assumed a 600 vertex
limit.  In GDSII Release 3, the number of wire path points is limited
to 200.

As of GDSII Release 7 (2002), the both limits have increased to 8000
vertices.  In order to support Release 7 as well as older releases,
a new variable has been added:

    GdsOutLevel  (integer 0-2)

This can be set with the !set command, and affects only the GDSII
output.

level 0: (the default)
  max poly vertices: 8000
  max path vertices: 8000
  Stream level: 7

level 1:
  max poly vertices: 600
  max path vertices: 200
  Stream level: 3

level 2:
  max poly vertices: 200
  max path vertices: 200
  Stream level: 3

By setting GdsOutLevel to 1 or 2, GDSII files generated with Xic should
not cause difficulty when read by older programs (including old versions
of Xic).

New Variable:  JoinMaxPolyVerts  (integer 20-8000)

This sets an upper bound on the number of vertices in polygons created
with the !join command and similar operations.  The provious limit, and
the current default, is 600 vertices.

New '!' command:  lisp filename [args...]

The filename is searched for in the script path and the current directory.
argc, argv
add text

In user-defined script functions, if a handle is no longer in scope
when the function returns, the handle is automatically closed.
Similarly, zoidlists and layerexprs that go out of scope are noow freed,
avoiding a potential core leak.

The AltResolution, AltPhysResolution, AltElecResolution technology
file keywords were being ignored.

The AltResolution, AltPhysResolution, AltElecResolution keywords are
no longer accepted.

There is a new keyword which can appear in printer driver blocks in the
tehcnology file: HardCopyDefResol (integer)
This has meaning only to drivers that have selectable resolutions.  The
value following this keyword is a zero-based index into the list of
resolutions as given with the HardCopyResol keyword, and indicates the
default resolution which will be selected in the Print pop-up for the
driver.

Example:
HardCopyDevice postscript_line_draw
HardCopyResol 72 75 100 150 200 300 400
HardCopyDefResol 2

This will select 100 as the resolution for the postscript_line_draw
when the Print pop-up first appears.  The resolution can be changed with
the menu.

Reworked the Set Grid pop-up.
Changes:
    new buttons for Solid, Dots, and Textured grid line styles.
    new preview window for grid lines
    you can now set multiple pixels by dragging in the line style editor.
    in editor, button 1 toggles bits, button 2 clears bits, button 3
     sets bits.
    the area to the left of the first bit in the sequence is now shown
    in gray.

The spin command has been enhanced.  The operation now supports all object
types, however if a subcell or label is included, the rotation angle is
constrained to be a multiple of 45 degrees.  If only boxes, polygons, and
wires are included, all rotation angles are supported, as before.

Once the rotation has been performed, and the rotated objects are
ghost-attached to the pointer, pressing the Enter key will place the
rotated objects at the reference point, replaceing the original objects.
The result is a simple rotation about the reference point.

Added option menu to the Convert-Export panel for GdsOutLevel.
-----------------

!rehash command;  Re-reads the script files and libraries along the
script search path, and rebuilds the User Menu (same as the Rehash
button in the User Menu).

Whenever the ScriptPath is set, the script files and libraries are
re-read and the User Menu rebuilt, as if the Rehash button was pressed.

The !rmfunc command has been enabled.  It was turned off temporarily
since it could cause memory referencing errors.  This has been fixed.

New '!' command: helpreset
This will throw out all of the internally cached information in the
help database.  This should be called after modifying the text in
a help database file.

The text mode help which is supposed to be available when no graphics
is available wasnt working.  This has been fixed.

bangcmds.cc import if probably foo-bar

Reworked some of the core database structures to be more efficient.  This
should fix performance issues for the following two cases:
1) a cell contains a huge number of different subcells
2) the hierarchy contains a huge number of different cells, each containing
   an instance of one type of cell.

Fixed some core leaks in the GDSII reader.

Internal changes to the skeleton mode implementation to improve speed.

New variable: SkelSaveNum (integer >= 0)

This controls a new feature in skeleton mode that is an attempt to improve
processing speed.  If a cell contains this many geometrical objects or
fewer, it is kept in memory.  The assumption is that if there some small
cells that are instantiated in many places, it is more efficient to
cache these cells rather than having to update from the file each time the
content is needed.  This variable should be set to some small number.
If set to 0, this feature is effectively disabled.

New '!' command: !summary [-v] [filename]

This prints summary information (similar to the Info command) for each
cell in the hierarchy rooted in the current cell to a file.  If -v
is given, the output will be more verbose.  If no filename is given, a file
named "xic_summary.log" will be created in the current directory.

add Fcgx to mswdir.cc, mswplace.cc
mswconv enum change

Previously, when a GDSII file was read into Xic of converted to Xic native
files, certain attributes from the GDSII file header were saved as
properties in each symbol derived from the file.  These attributes,
such as font names, library names, etc. are not used by Xic, but would
be put back into any subsequently created GDSII file in case another
application uses them.

This behavior has changed, since saving this information reduces efficiency.
Now, the behavior is as follows:
   When a GDSII file is read into Xic using the Edit command or equivalent,
   the :header properties" are applied only to the top-level physical
   cells from the file, i.e., those cells that are not used as
   subcells.

   When a GDSII file is converted directly to Xic files from the command
   in the Convert/Convert pop-up, the "header properties" are written
   to a file named "gds_header_props" in the destination directory for
   Xic files.  This file is subsequently ignored by Xic.

The GDSII reader has been extensively revised, mostly to improve speed.

Less extensive revision to the other converter modules, to improve
efficiency.

A noe file format for input/output has been added.  This is a binary
file format similar to GDSII.  It has simplified record structure, but
extensions in data flexibility.  If is more compact than GDSII and is
more efficient to read and write.  This file format was developed by
Whiteley research Inc., but will be placed in the public domain with
no or minimal restrictions.

The format is named CGX (Computer Graphics eXchange).  The file extension
is ".cgx".  Gzipped files (".cgx.gz") are supported.  Xic will automatically
identify this file type, and can read, write, and convert to Xic files
just as GDXII.  At present, there is no conversion to/from a text
representation as there is with GDSII.  GCX files can be used in
skeleton mode, as with GDSII.

The advantage of GCS is smaller files and faster read/write than GDSII.

The pop-up text window used for certain errors, messages, and the Info
command now scrolls with the mouse wheel.

When using the Edit Layers command in the Attributes Menu to add layers,
pointing to the right of all layers, or to the layer specific icon,
will add the layer to the right of the last layer shown.  Previously,
this would toggle layer-specific mode, and it was not possible to add
a layer to the end of the list.

Added an ABORT button to the Modified Symbols pop-up.  Pressing the
ABORT button a will exit the present operation without saving any cells.

Got rid of the final "Exit Xic?" prompt.

GET RID of setjmp in cifread.cc

Revised the display control functions.  Screen updates should be faster.

----
Xic will now die is it gets more than three floating point exceptions.
Often, these are recovarable and Xic can continue, however sometimes
one gets into an infinite loop where each exception creaets a new
exception, and Xic would hang.  This will no longer happen.

MSW CheckForEvents ->App->CheckForInterrupt(False);

UseDisplayCache -> NoDisplayCache
UsePixmapStore -> NoPixmapStore

In batch mode, the log files for reading and writing of files
are now written to the current directory.

// (int) ToCGX(cgx_name)
//
// This function will write the current cell hierarchy to a CGX
// format file on disk.  The argument is the name of the CGX file to  
// create.  If the cgx_name is NULL or the empty string, the name used
// will be the top level symbol name suffixed with .cgx.  
//

// (int) FromCGX(cgx_file, destination_dir)
//
// The FromCGX function will convert a CGX file cgx_file to Xic  
// symbol files.  The symbols are not read into the database.  The
// second argument is the directory where the Xic files will be
// created.  If this argument is a null or empty string or zero, the
// Xic files will be created in the curent directory.
//

PopUpModified on quit, what about error?
------
// (int) Edit(filename, symname)
//
// This command will read in the named file or cell and make it, or
// the top level cell in the hierarchy, the current cell.  If the
// present cell has been modified, the user is prompted for whether to
// save the cell before reading the new one.  If name is null or
// empty, a valid name is prompted for on the prompt line.
//    
// The name provided can be a CGX, GDSII, CIF, EDIF-200, or OCT file,
// the name of an Xic cell, or a library file.  If the name of a CGX,
// GDSII or CIF file is given, the name of the cell to open can be
// provided as symname.  If no symname is given, the top level cell
// (the one not used as a subcell by any other cells in the file) is
// the one opened for editing.  If there is more than one top level
// cell, the user is presented with a pop-up choice menu and asked to
// make a selection, if in graphics mode.  If not in graphics mode,
// the current cell won't be set, but all cells are in memory.  For
// EDIF files, only the top-level cell can be opened, i.e., the
// function will ignore symname.  If the file is a library file, the
// symname can be given, and it should be one of the reference names
// from the library, or the name of a cell defined in the library.  If
// no symname is given, a pop-up listing the library contents will
// appear, allowing the user to select a reference or cell.
//
// The name argument can be passed 0, in which case the user will be
// prompted for a file or cell to open for editing, if in graphics
// mode.  If not in graphics mode, an empty cell is created in memory
// and made the current cell.
//
// When reading CGX, GDSII, CIF, EDIF, or OCT, the cell is scaled
// according to the current scale for reading.  This scale can be set
// with the SetConvertScale() function, of from the Convert - Import
// panel in Xic.
//
// The return value is one of the following integers, representing
// the command status:
//  -2      The function call was reentered.  This is not likely to
//          happen in scripts.
//  -1      The user aborted the operation.
//   0      The open failed: bad file name, parse error, etc.
//   1      The operation succeeded.
//   2      The read was successful on an archive with multiple top-
//          level symbols but the symbol to edit can't be determined.
//          The current cell has not been set, but the cells are in
//          memory.  The second argument could have been used to
//          resolve the ambiguity.
//   3      The cell name was the name of the device.lib or model.lib
//          file, which has been opened for text editing (in graphic
//          mode only).
//

// (int) OpenCell(filename, symname)
//
// This function will read a cell (and subcells) into memory, but
// unlike the Edit() function, the new cell will not be the current
// cell.  Once in memory, the cell is available by its simple name,
// for use by the Place() function for example.  If name is the name
// of a CGX, CIF, GDSII or library file, symname is the cell or
// reference to open, similar to the Edit() function.
//
// When reading CGX, GDSII, CIF, EDIF, or OCT, the cell is scaled
// according to the current scale for reading.  This scale can be set
// with the SetConvertScale() function, of from the Convert - Import
// panel in Xic.
//
// The return value is 1 on success, 0 otherwise.
//

// (real) SetConvertScale(real, which)
//
// This sets the scale used for conversions.  There are three such
// scales, and the one to set is specified by the second argument,
// which is an integer 0-2.
//   which = 0:
// Set the scale used when converting an archive file to a collection
// of native files, with the FromXXX() script functions or with the
// Convert menu.
//   which = 1:
// Set the scale used when writing a file with the ToXXX() script
// functions of the Conversion - Export panel.
//   which 2 2:
// Set the scale used when reading a file into Xic with the Edit() or
// OpenCell() functions, or from the Convert - Import panel in Xic.
//
// The scale argument is a real value in the inclusive range 0.01 -
// 100.0.  The return value is the previous scale value.
//

FromCIF/ToCIF etc, note about scaling.

The Open - Import pop-up from the Convert Menu now has an entry area
for a scale factor and a Read File button.  This allows a file to be
read into Xic and scaled by the specified scale factor.  Otherwise,
this is similar to the Edit command, however the Edit command does not
allow scaling.

---

New Variable: CifLayerMode (integer 0-2)

modifications: CIFoutStyle ->CifOutStyle
               CIFaddBBox -> CifAddBBox

GdsSkeletal -> SkeletonMode

Trxt to GDSII would fail on symbolic property
-----------

EraseBehindTerms now 0-2
------------------------------------------------------------------

The Mark option in the Attributes Menu could incorrectly cause
selected object to have a white rather than a blinking outline.

All of the screen marks and selections now use the backing store to redraw
when deleted.  This is hugely more efficient.

GdsTwoPass no longer used

The CGX/GDS/CIF/Native file input/output have been rewritten to be more
modular.  As a result, it is not possible, through the Convert panel in
the Convert menu, to directly convert files between these types.  Previously,
direct conversion was only possible when writing native cell files.  Now,
one can directly write to CGX/CIF/GDSII as well.  The Convert panel now
has two option menus: one for the input file type and one for the output
file type.

The Create Symbol command no longer writes the symbol to disk automatically.
The cell is created in memory only.

Syntax change in extended CIF output.

The end style of wires is not part of traditional CIF.  Previously, this
parameter was stored as a wire property in CIF output.  Since this is
a bit messy and inefficient, the wire format has been changed in native
output to accept the new parameter.

The wire style is an integer 0-2 that immediately follows the "W" in
a wire specification, i.e., the full syntax for a wire is

   W0 | W1 | W2  <width> <x-y data>;

This is used in all native files, and in CIF output uless the
StripForExport button is active.

These files can not be read by older releases of Xic!


When writing a collection of Xic native files from the Convert - Export
panel, the scale factor is now applied.  Previously, it was ignored.

cif -> gds layer mapping
if the cif layer is found in the layer table ane it has a GDS output mapping,
use that mapping.
if the layer name is a four-difit hex number, interpret it as "LLDD".
else, assign a new layer index starting at 1 and datatype of 255.

-> gds:  no checking for call name conformance

cell name length in v7 gds files is 128

The CifTwoPass and GdsTwoPass variables have been removed.

Unix/Linux
all distributions now support 64-bit file offsets for cif/gdsii/cgx
files.  This means it is now possible to read and write files larger
than the 2Gb limit imposed by 32 bits.

use sPF::error

Make sure GdsSkeletal in gone from help.

// (int) SkelWriteGeom(depth, filename, flat, clip)
// 
// This function will write the cells and objects that have nonzero
// area overlap with the current skeleton window to a file.  The
// current hierarchy must have been opened in skeleton mode (i.e.,
// with the SkeletonMode variable set).  Only geometry which is within
// the current data window will be written.  The first argument is the
// depth in the hierarchy to write.  This can be an integer, with 0
// representing the current cell only, 1 will include its subcells,
// and so on.  A negative value will read the entire hierarchy.  This
// argument can also be a string starting with 'a' to indicate reading
// of the entire hierarchy.
//
// The type of file written is implied by the filename.  If the
// filename is null or empty, native cell files will be created in the
// current directory.  If the filename is the name of an existing
// directory, native cell files will be created in that directory.
// Otherwise, the extension of the file name determines the file type:
//  CGX     .cgx
//  CIF     .cif
//  GDSII   .gds, .str, .strm, .stream
// Only these extensions are recognized, however CGX and GDSII allow
// an additional .gz which will imply compression.
//
// If the third argument is 0, the existing cell hierarchy is
// maintained.  If nonzero, the written hierarchy will be flattened,
// i.e., all objects will appear in the top-level cell.
//
// If the fourth argument is nonzero, objects written to the file
// will be clipped to the skeleton data window.
//
// The return value is 1 on success, 0 otherwise.
//

Only geometry that overlaps the clip area will be included in the file.
However, when viewing the file, geometry in subcells that also exist
outside of the clip area will also be visible.

Fixed bug, entering certain key combinations could cause a program
crash.

CIF files now work in skeleton mode.

The Convert pop-up has new features.  When translating a file, it is possible
to filter out ofjects that do no overlap a given rectangular area, or
to clip objects to a rectangular area.  It is also possible to flatten the
hierarchy, so that the top-level cell in the written file contains all of
the geometry (and no subcells).

The Use Window button controls whether or not a rectangular area is to be
used.  If this button is set, only the objects that intersect this area
will appear in the output file.  For subcells, only the objects that
appear within the window for some instance will be converted in the
corresponding cell.  The rectangular area can be set with the Left, Bottom,
Right, and Top entry areas.  These are coordinates, in microns, in the
coordinate system of the top-level cell, *after* scaling is applied.

If the Clip button is active in addition to the Use Window button, objects
will be clipped to the given window.

If the Flatten button is active, the output file will be a flat representation,
i.e., all geometry will appear in the top-level cell, which will have no
subcells.

XXX what happens if multiple top level cells?

The bounding-box extensions:
   1 Bound l b r t;
   if (CifAddBBox set)
      (BBox l,t w h);
are added only when writing from the database, not when translating.
The BBox extension is now also applied to Xic native cells.
These are not used by Xic at present.

// (int) FromCGX(cgx_file, destination)
// 
// The FromCGX function will read a CGX file cgx_file and translate
// the contents to another format.  The type of file written is
// implied by the destination.  If the destination is null or empty,
// native cell files will be created in the current directory.  If the
// destination is the name of an existing directory, native cell files
// will be created in that directory.  Otherwise, the extension of the
// destination determines the file type:
//  CGX     .cgx
//  CIF     .cif
//  GDSII   .gds, .str, .strm, .stream
// Only these extensions are recognized, however CGX and GDSII allow
// an additional .gz which will imply compression.
//
// The scale factor used can be set with the SetConvertScale function.
// The windowing and flatting functions will be applied if the
// corresponding flags are set with the SetConvertFlags and
// SetConvertArea functions.  The scale, flags and area rectangle can 
// also be set from the Conversion pop-up in Xic.
//
// The value 1 is returned on success, 0 otherwise.
//
similar for FromCIF, FromGDS

// (int) SetConvertFlags(use_window, clip, flatten)
// 
// This function sets the status of flags used in format conversions.
// The three arguments coorespond to the Use Window, Clip to Window,
// and Flatten Hierarchy buttons in the Conversion pop-up.  A nonzero
// integer value will set the flag, 0 will reset the flag.
// 
// The flags will affect conversions initiated from this pop-up, and
// the FromCGX, FromCIF, and FromGDS script functions.  The data window
// can be set with the SetConvertArea script function.  To apply clipping,
// both the use_window and clip flags must be set.
// 

// This function always returns 1.
//
// (int) SetConvertArea(l, b, r, t)
// 
// This function sets the rectangular area used to filter or clip
// objects during format conversions.  This rectangle can also be set
// from the Conversion pop-up.  Use of the window can be enabled with
// the SetConvertFlags script function.  The coordinates are in
// microns, in the coordinate system of the top level cell of the
// input file, after scaling (if any).  The function always returns 1.
//
-----

Found and fixed a serious problem in electrical mode: the node properties
were being stripped from sub-subcells when read from Xic files.  Is it
possible that this was badly broken for months and nobody noticed?

When clipping, wires are cut into segments when the clipping boundary
intersects the path.  Thus, the wire geometry may extend outside of the
clipping boundary by up to one half or the wire width.
------------------------------------------

Fixed bug:  Deleting an empty symbol would cause a program crash.

The bounding box of parent cells was not being updated when empty instances
were deleted.
MSW FIX! gtkplace.cc ec_btn_proc()

If saving an archive file and the operation fails, the original file,
if any, is moved back to the original name.

CheckElectrical() no longer leaves curop with electrical cell.  This would
cause failure of scripts like
  Edit("whatever", 0)
  Xor(...)

Major rewrite of the computational geometry functions to improve speed.
The logical operations, clipping, joining, etc should be faster.

During lengthly operations, Xic periodically calls a graphical library
function to check for events, such as a Ctrl-C press.  With recent
updates to the GTK and X-Window libraries, the overhead of this
function has grown, and now such checking can dominate the execution
time.  The function was called after a a fixed number of operations,
which means that for a fast machine, the number of calls per second
was gross overkill.
  To fix this, Xic now uses a global timer that ensures that
event testing is not done more frequently that every 200 milliseconds. 
This should be a big improvement, particularly with faster machines.

Some work on DRC for efficiency and numerical robustness.

internal timer GRsleep could not handle t > 999 ms, PeekSleepMsec
was restricted.

The overall system timer is now a separate thread.

// (int) SkelWriteDigest(digest_file)
//
// This function writes a digest file for the skeleton hierarchy
// rooted at the current cell.  A digest file is a simplified
// representation of the cell hierarchy, containing only the
// information needed to access the cell data in the archive file.  In
// order to access the cells in the archive file in skeleton mode, one
// can open the archive file, or open the digest for the archive.  The
// latter should be faster.
//
// This function must be called while in skeleton mode (the
// SkeletonMode variable is set), with a skeleton hierarchy rooted at
// the current cell.  The argument is the name of the digest file, and
// must be a valid file name.  The function returns 1 on success, 0
// otherwise.
//

// (int) SkelReadDigest(digest_file, archive_file)
//
// This function reads a digest file created previously with
// SkelWriteDigest(), which applies to the CGX/CIF/GDSII archive file
// given in the second argument.  If successful, upon return return
// the current cell is set to the cell that was current when the
// digest was created, and all cells in the hierarchy should have
// their offsets and bounding boxes set.  One can then use skeleton
// mode functions to read the area-filtered geometry, just as if the
// cell was opened with the Edit() command or equivalent.  This method
// should be much faster for large archives.
//
// This command must be called in skeleton mode (the SkeletonMode
// variable is set) with no other skeleton hierarchy in memory.  It is
// very important that the digest file match the archive file.  It the
// archive is modified in any way after the digest was produced, the
// file offsets in the digest will be wrong and errors or program
// crashes could result.  There is at this point no consistency
// checking.
//
// The function returns 1 if successful, 0 otherwise.
//

New variable:  JoinMaxPolyGroup (integer >= 0)

When an assemblage of trapezoids is being combined into polygons, such as
for the !join command, this variable changes the limit on the number of
trapezoids used to create each polygon.  The default value (when this
variable is unset) is 100.  If set to zero, no limit is applied.  Generally,
smaller limits allow faster join operations, however this will leave
more polygons that could have been joined as separate objects.


New variable:  JoinMaxPolyQueue (integer >= 0)

new struct BYlist, revision of box merge operation for speed.

New command: !time
This prints the elapsed running time in seconds on the console window.
The granularity is 200ms.
-------------------------------------------------

in converters, decrease frequency of size print feedback

The FromXXX() script functions wouldn't work unless there was a
current cell.

Writing CGX files from the database would fail in some cases since
the box cache size exceeded the record size.

Note: the multi-box record supported by CGX in not used when translated
from another format, but is used when written from the database.  In the
latter case, files can be up to 20% smaller.

The user feedback prompt during file read/write is not every 1Mb instead
of every 100Kb

CIF read, size feedback numbers weren't accurate.

CDo->left -> CDo->down !!!!

(left -> down)
cd.h new: CDo::set_cpy_links(CDo*)  set_cpy_sdesc_ptr(CDs*)
boxbase.cc polygon.cc wire.cc  now use set_cpy_sdesc_ptr
variable.cc xicf2.cc xicf3.cc  now use set_cpy_links

cd.h
new CDo flags: CDoMark1-4
new methods set_flag, unset_flag, is_flag

cddb.cc/cddb.h/cd.h
no more Bdiff

CDg, sPF cd.h->cddb.h
CDtf cd.h->cdgeom.h

symdesc.cc
  use CDo::setclip()
  added CDs::checkCoinc(CDo*)
  added CDs::listCoinc(CDo*)
  computeBB, db_bb()

 bangcmds.cc
cddb.cc/h  db_rebuild/db_merge CDelt->CDo
bang_origin
bang_import
bang_bincnt

    geometry.cc:  toOlist now sets CDisCopy flag and uses cpy_odesc() for
    link.

    group.cc grgen next func, use of toOlist
    extract.h  new grgen method good_phony() (revert BB->gBB, ldesc->gLdesc) 

symdesc.cc
cdesc's are not inserted into db until BB is valid.

got rid of CDpath.

fixed pointer bug in JoinObjects() script function (introduced in 23)

XXX all objects in db are now used to compute BB.

digest read: set top symbol filename/filetype

CDs::skelReadGeom() fails if no layers.

secure.cc backdoor

ClipToAll, ClipToAllCopy: special cased when clip region is a single rectangle
for speed.

erase command, use PSELstrict_area_nt, skip non-clipped objects in clipping mode

Work to make clipping functions faster, particularly when the clipping region
is a simple rectangle.

The object database, which is the core of Xic, has been replaced.  The previous
database, based on spatially-binned skip-lists, was inefficient for spatially
filtered area retrieval.  The new database does away with spatial binning and
uses an R-tree-like mechanism for spatial filtering, while retaining the
ordering property of the skiplist approach.  The new database outperforms the old
on all tests, sometimes very substantially (for example, the "merge-boxes-on-read"
feature has much lower overhead now).  The memory consumption overhead is about
the same.

// (int) ClipAround(object_handle1, object_handle2 [, all1, all2 ])
//
// This function will clip out the pieces of objects in the second
// handle list that intersect with objects in the first handle list. 
// The third and fourth arguments are optional, and default to 0 if
// not given.  If all1 is nonzero, all objects in the first handle are
// used for clipping, otherwise only the first object is used.  If
// all2 is nonzero, all objects in the second handle list may be
// clipped, otherwise only the first object in the list is a candidate
// for clipping.  Only boxes, polygons, and wires that appear in the
// second handle list will be clipped.  The objects in the first
// handle list can be of any type, and labels and subcells will use
// the bounding box.  The objects in the second list must be database
// objects, if they are are copies, no clipping is performed.  The
// objects in the first list can be copies.
//
// The newly created objects are added to the front of the second
// handle list, and the original object is removed from the list.  The
// return value is the number of objects created, or -1 if either
// handle is empty or some other error occurred.  The function fails
// if either handle does not reference an object list.
//
// (object_handle) ClipAroundCopy(object_handle1, object_handle2 [, lname, all1, all2 ])
//
// This function is similar to ClipAround(), however no new objects
// are created in the database, and neither of the lists passed as
// arguments is altered.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// object or objects referenced by the second handle that do not
// intersect the object or objects referenced by the first handle. 
// The remaining arguments are optional, and default to 0 if not
// given.  The all1 and all2 are flags specifying whether to use all
// objects in the respective lists, or just the first, as in
// ClipAround().  Unlike ClipAround(), the second handle can reference
// object copies.
//
// If lname is is given and is a non-empty string, it is taken as the
// name for a layer on which all of the returned objects will be
// placed.  The layer will be created if it does not exist.  If zero
// or an empty or null string is passed, the object copies will retain
// the layer of the original object from the second handle list.
//
// The returned list can be used by most functions that expect a list
// of objects, however they are not copies of "real" objects.  If no
// new object copy would be created by clipping, the function returns
// 0.  The function will fail if either handle is not an object-list
// handle.
//
// (int) ClipTo(object_handle1, object_handle2 [, all1, all2 ])
//
// This function will clip objects referenced by the second handle to
// the boundaries of objects referenced by the first handle.  The
// third and fourth arguments are optional, and default to 0 if not
// given.  If all1 is nonzero, all objects in the first handle are
// used for clipping, otherwise only the first object is used.  If
// all2 is nonzero, all objects in the second handle list may be
// clipped, otherwise only the first object in the list is a candidate
// for clipping.  Only boxes, polygons, and wires that appear in the
// second handle list will be clipped.  The objects in the first
// handle list can be of any type, and labels and subcells will use
// the bounding box.  The objects in the second list must be database
// objects, if they are are copies, no clipping is performed.  The
// objects in the first list can be copies.
//
// The newly created objects are added to the front of the second
// handle list, and the original object is removed from the list.  The
// return value is the number of objects created, or -1 if either
// handle is empty or some other error occurred.  The function fails
// if either handle does not reference an object list.
//
// (object_handle) ClipToCopy(object_handle1, object_handle2 [, lname, all1, all2 ])
//
// This function is similar to ClipTo(), however no new objects are
// created in the database, and neither of the lists passed as
// arguments is altered.  Instead, a new object list handle is
// returned, which references a list of "copies" of objects that are
// created by the clipping.  The new objects are the pieces of the
// object or objects referenced by the second handle that intersect
// the object or objects referenced by the first handle.  The
// remaining arguments are optional, and default to 0 if not given. 
// The all1 and all2 are flags specifying whether to use all objects
// in the respective lists, or just the first, as in ClipTo().  Unlike
// ClipTo(), the second handle can reference object copies.
//
// If lname is is given and is a non-empty string, it is taken as the
// name for a layer on which all of the returned objects will be
// placed.  The layer will be created if it does not exist.  If zero
// or an empty or null string is passed, the object copies will retain
// the layer of the original object from the second handle list.
//
// The returned list can be used by most functions that expect a list
// of objects, however they are not copies of "real" objects.  If no
// new object copy would be created by clipping, the function returns
// 0.  The function will fail if either handle is not an object-list
// handle.
//

Depredated:
// (int) ClipAroundAll(object_handle1, object_handle2)
// (object_handle) ClipAroundAllCopy(object_handle1, object_handle2)
// (int) ClipToAll(object_handle1, object_handle2)
// (object_handle) ClipToAllCopy(object_handle1, object_handle2)

!bincnt command is a little differnt now.

    !bincnt [layername [level]]

This command prints some database statistics on the console window.  If no
layername is given, the layer examined will be "$$", the internal layer that
contains subcell instances.  The message will look something like

Cell noname
levels 2, nodes 1, frac 0.25, items 2 (allocated 2)

this indicates that the tree structure for the data items has depth 2, 1 node
other than the data nodes, occupancy fraction 0.25, and tow data items, which
matches the cached allocation number.

If a number follows the layer name, the enclosing bounding box for each sub-tree
at the given level is transiently shown on-screen.


Place panel, Origin and Lower Left logic reversed (MSW!!!)
--------------------------------------------
gcc-3.x 
httpget: add -lstdc++

New variable: CifOldWire (boolean)

When set, CIF output (without the Strip For Export button set), and the
native symbol files, will use the old syntax for wires, which is compatible
with older releases of Xic.  It is necessary to use this option when
exporting files to be read by older releases is the cells contain wires
with non-default end style.  The new syntax is more efficient and should
be used if possible.

A label was added to the Conversion - Export panel that reminds users
that the Strip For Export and Skip Invisible functions apply to
conversions from this panel only, and not when writing files with the
save command or similar.  The remaining settings apply in all cases.

When opening an archive file and there are multiple top-level symbols
in the current mode, Xic will check if one of these is top-level in
both modes, and if one such cell is found, it will be opened.  This
avoids the pop-up which asks the user to choose which cell to open
in most cases.


Minor change to the script debugger pop-up:

New accelerator keys when in execute mode (Unix/Linux only)
   t, <space>      single step
   r               run
   e, Backspace    reset

These are hard coded, and are in addition to the accelerators in the
menu (which can be changed).  The problem with the menu accelerators
is that they require the Ctrl key to be pressed, which may fool scripts
that are sensitive to the Ctrl key.

These are not available under Windows, due to the inflexibility of the
interface provided by Microsoft.

Key presses when the debugger has the focus in execute mode are no longer
reflected to the main window.

(bug)  The reset operation would not scroll the text to the top.

(bug)  The ButtonDown() and ButtonUp() script functions were not working
       correctly when run from the debugger.
   
mswxic.cc grabstate_t

Fixed extraction oddness:  If a device such as a resistor has its contacts
implemented in a subcell, and there is no metal in the present cell making
contact to the device, the device contact is not assigned to a conductor
group.  This is as it should be, however if there are several such devices,
all with contacts as described, they were being extracted as one device
in parallel (since each contact, internally, has group number -1).  This
no longer happens - if a device has a contact that is not given a
"real" group number, it won't be merged.  

In extraction, if the formal terminals couldn't be placed because of some
inconsistency, it was possible to get into an infinite loop.

There was also an instability problem is terminals were manually placed
over metal in a subcell that is part of a device.

In the Edit Terminals command, clicking on a terminal now brings up
the terminal properties editor, Shift-clicking will allow the terminal to
be moved.  The SHIFT key has reverse logic from earlier releases.

The ghost-drawn terminals are shown as a box, which is easier to see
than the previous cross.

Fixed problem that caused instability if the Symbol Merge pop-up
was used (new database needed virtual destructors).
----------------------------------------------------------

Can Xic handle nested CIF comments? Yes

KeepDbSorted variable is gone

(Unix/Linux)
When dismissing the Print panel, using the Dismiss button would preserve
the state of the panel, while using the X button in the title bar would
not.  This is no longer true - the state is always preserved.

---Selections in Info windows? (Cells List description)

Turned on the button-1 text selection capability in Info and some other
text pop-up windows, so it is now possible to cut-and-paste from these
windows.  If the selected text in an Info window happens to be a cell
name, then the Edit command, and the commands in the Cells Listing
window, will use this cell as a default.
XXX selection hierarchy


Xic will now save the file of origin for archive files only if the
archive has one top-level cell only, and only in that cell.  Previously,
the rules for saving the original file name were too loose, making it
too easy to overwrite the archive with partial content, for example
while in a Push.

If in a Push, and the Edit command is given, the current cell will
now be given as the default cell to edit.

Tweek to CGX format xform.

The CGX file format is now documented in "!help cgxformat".

Fixed bug:  In electrical mode, add some plot points and save the
cell.  Move an object that has a plot point attached (though
invisible), and press Tab for undo.  Move sonething else.  There
would probably be a crash.

New Help database keyword:
  !!REDIRECT keyword alias
This can appear in help database file, and will map the keyword into
the alias.  For example,  if a database file contains
  !!REDIRECT nyt http://www.nytimes.com
then giving "!help nyt" will bring up a help window and load the
New Your Times web page.

All of the script function names are now help keywords.  For example,
giving
  !help ClipAround
will bring up a help window describing the ClipAround() script function.

---Convert gdsii->text (at least), wont find ./xxx.gds unless . is in path

Fixed bug:  when opening a file with a name that starts with ./ or ../,
Xic was corculating through the respective internal path definition
(LibPath, etc)  looking for the file in the path components terminated
with the given name.  This means that unless the current directory is in
the path, the file would not be found, or the wrong file would be found.
Now, Xic does the sensible thing when given one of these forms and looks
only in the directory rooted at the current directory.

---Enforce "." in LibPath

When opening files in the LibPath, Xic will always try to open the
file in the current directory before searching the LibPath.  The, the
LibPath inplicitly contains "." as the first component.  It turns out
that having a LibPath without "." could lead to confusing problems
for the user, who may have forgotten the information burried in the
documentation that the LibPath should always contain ".", so Xic now
enforces this.  It is no problem if the LibPath already contains ".".

Fixed Bug:  The .alias file was not being written when GDSII files
were written or read.

The GDSII alias file feature, which was broken in the last release,
has been made optional.  This feature provides too many traps for the
unwary to be "on" all the time.  The feature can be turned on by setting
the following new variable:

New variable: GdsUseAlias (boolean or string)

This variable enables utilization of the alias file when converting
to or from GDSII.  If simply set as a boolean, i.e., to no value,
the alias file will be read before a conversion, and created or
updated if necessary after a conversion.  If the variable is set to
a word starting with `r' (case insensitive), then the alias file
will be read before a conversion and used during the conversion (if
it exists), but will not be created or updated after the conversion. 
If the variable is set to a word starting with `w' or `s' (case
insensitive), the alias file will not be read before a conversion,
but will be created or updated after the conversion.

***change
  s, w  write but no read
  r     read but no write
  otherwise read and write


When writing an alias file for a gzipped GDS file, the ".gz" is stripped
from the alias file name.  When reading a gzipped GDSII file, Xic will
first try to open the alias file without "gz", then with "gz" for
backward compatibility.  An update will never contain "gz".
More information on the present alias file support in
"!help gdsalias".

--Extend the skip invisible capability to the script file writing
--functions.
Already Done - note this in documentation.

// (int) SetSkipInvisLayers(code)
//
// This function sets the variable which controls how invisible layers
// are treated by the output conversion functions.  Layer visiblity is
// set by clicking in the layer table with mouse button 2, or through    
// the SetLayerVisible() script function.  If code is 0 or negative,
// invisible layers will be converted.  If code is 1, invisible
// physical layers will not be converted.  If code is 2, invisible
// electrical layers will not be converted.  if code is 3 or larger,  
// both electrical and physical invisible layers will not be
// converted.  The return value is the previous code, which represents
// the state of the SkipInvisible variable, and the check boxes in the
// Conversion - Export panel.


SkipInvisibls (boolean or string)
if starts with 'p', skip physical invisible layers only.
if starts with 'e', skip electrical invisible layers only
anything else, skip invisible layers in both modes.


Add some means for skipping layers, or gds layer/dt's

Shishir output issue.
Skeleton mode might not be the way to go for this kind of file.
Can you read the whole file into Xic in normal mode?  If so, it
should be easy write a function to write the file out in pieces,
like SkelWriteGeom but from memory.  That should be much faster
in this case, but if the file doesn't fit in memory this won't work.

Another approach would be to have all the output files open at once,
then read through the big file and for each object, clip it and write
the pieces to the appropriate output files.  Maybe that is the way to  
go.  The output would be clipped and flat.  But, the total size of the
files might be enormous.

There is a variable named LockMode, which if set might reduce the
memory used.  This will prevent allocation of memory for the stub used
for electrical data in each cell, which is small but in this case
might be significant.

--I'll add the layer selection capability:
--1) somehow give Xic a list of layers/datatypes to ignore when reading.
--2) extend the Skip Invisible Layers feature to script functions that
--   write files.

New capability when reading or translating archive files: layer filtering.

New variable:  LayerList (string)

This can be set to a space-separated list of layer names.  These layers
can be used for filtering when an archive file is being read or translated.
Each layer name should be four characters or fewer (names will be truncated
to four characters) and are expected to match a layer in the input archive
file.  For GDSII files, which do not have layer names but instead have
layer and data type numbers in the range 0-255, the names in the layer
list take the form of a four-digit hex number "LLDD", where "DD" is the
0-padded hex data type number, and "LL" is the 0-padded hex layer number.
Either field can instead be "XX" literally, in which case the field will
match any value.

New Variable: UseLayerList (boolean or string)

This variable deterines how and if the LayerList string is used when
input is being read from an archive file.  The layer list is used,
if enabled by this variable when
  .  Input is being read from a CGX, CIF, or GDSII file
  .  The operation was initiated from the Conversion - Import or
     Conversion panel, or from on of the FromCGX, FromCIF, FromGDSII,
     Edit, or OpenFile script functions.  The LayerList is ignored otherwise,
     whether of not UseLayerList is set.

If UseLayerList in not set, the LayerList is ignored, and any layer found in
the input file will be read or converted.  If UseLayerList is set to a
word starting with 'n' or 'N', layers that are listed in the LayerList will
not be converted.  If UseLayerList is set to a anything else (including no
value)  only the layers listed in the LayerList will be converted.

The Conversion - Import and Conversion panels how have an editable field
for a list of layers, and check boxes for whether to use only the listed layers
or skip the listed layers.  These control (and are controlled by) the
values of the LayerList and the UseLayerList variables.

----

The 'long text' editing feature was not working correctly.

Due to some subtle bugs and other things not good about the Property
Editor and Cell Property Editor, these were rewritten.

Changes:
The 'L' button is now a (mostly hidden) part of the main window, instead
of a separate pop-up.

Properties Editor:

When the Property Editor is visible, clicking on an object with the
Shift or Contgrol button pressed will bring up the Property Info
window, loaded with the properties of the object.  This contains a
listing just like the Property Editor, however there are no buttons
other than Dismiss.  The object is shown with a white highlight, similar
to the selected object shown in the Property Editor, which is yellow.

The Property Editor and Property Info windows are drag/drop sources
and receivers, mdeaning that one can drag properties from one
window to another.  This will apply the dragged property to the
object associated with the drop window (the source object is not
affected).  Properties that must be unique, such as most electrical
properties, will be replaced with the dropped property.  Properties
that are not unique will be added, without replacement.

Edit button:
   If no property selected in text
     The first property will be selected and its text used in the prompt
     line.  The up/down arrow keys will cycle through the editable
     properties listed in the window.  Clicking on an entry in the
     window will select it and load its text into the prompt line.
   If an entry was selected
     That property will be loaded into the prompt line for editing.  The
     arrow keys work as above.  Clicking on another property works
     as above.
   The above is true whether or not the Global button is set.  With the
   Global button set, a string is solicited for each selected object,
   replacing or adding a property to each object in sequence.  After
   the first prompt, the arrow keys and click-selection are disabled.

   When the prompt is active for a property string, clicking on another
   object in the drawing will bring up the Property Info window listing
   that object's properties in the same format as the main Property
   Editor window.  One need not press Shift or Control for this function
   while the text editor is active.  Properties can be dragged/dropped
   from the Property Info window to the prompt line, or the X-selection
   mechanism can be used.

   In Global mode, for properties that can have more than one instance
   (OTHER electrical properties and all physical properties)  if the
   number and string of the original property shown highlighted in
   the window match those of an existing property, that property  
   will be replaced.

Add button
   Any selected property is ignored.  The user is asked to input the
   string for the property type selected in the Add menu (electrical mode)
   or a number and string in physical mode.  The arrow keys have no
   errect on this.

   If the Global button is inactive
   The new property will be added to the current object (replacing an
   existing property of the same type for most electrical properties).

   If the Global button is active
   The new property will be added to or replace a similar property in
   all selected devices.  The same property is added to all, unlike
   from the Edit button where a separate string is given for each
   property addition.

   In Global mode, for properties that can have more than one instance
   (OTHER electrical properties and all physical properties)
   new properties will always be added, never replaced.  This is potentially
   different from the action of the Edit button.

Cells Property Editor:
This works about as before, but some bugs were fixed.  Unlike the
Properties Editor, a selection must be made before pressing the Edit
button, and the arrow keys are not used, and a subsequent click-selection
will not change the property being edited.
   

TODO:
hypeertext from subcircuit gives wrong name?
now returns instance name rather than cell name

dnd icon from file mgr erases screen!
fixed - still erases screen if NoPixmapStore

UsePixmapStore -> NoPixmapStore
UseDisplayCache -> NoDisplayCache

Layer table no longer flickers during drag


*** Undo property drag/drop

in Edit, if first chowen is model, can't use longtext if target property
changes.


In the plot and iplot commands, multiple trace indicators can now be
attached to the same node, as long as they are spatially distinct.
Click on an indicator to delete it.  Previously, clicking anywhere on
a wire net would delete any associated trace indicator, i.e., there
could be only one indicator per node.  This made it a little tough
to create plot strings where a node voltage was used mor than once.

The "selected" tag in option menu form elements was being ignored
in the html viewer.

The mailto: handling in the help system was broken.
---------------------------------------------------------------------

in CDtd, int tfm[4] -> signed char tfm[4].

tflist_t defined in xforms.cc, tlist field added to sk_info.

// (int) SkelWriteGeomSplit(basename, x0, y0, wid, hei, border)
//
// This function will split the hierarchy under the current cell,
// which must have been read in skeleton mode, and write the flattened
// geometry to a set of output files.  This is similar to the
// WriteGeomSplit() function.  Each file contains the geometry for a
// cell in a defined grid, including some possible overlap with
// neighboring grid cells.  The x0, and y0 (in microns) set the grid
// origin relative to the origin of the current cell.  The wid and hei
// (in microns) set the periodicity of the grid, i.e., the unit cell
// width and height.  The border, in microns, is the amount by which
// the grid cell is bloated before geometry is extracted and written. 
// This must be positive or zero.
//
// The basename is a cell path name, with an extension which gives the
// type of file to create.  One of the following extensions must be
// provided:
//  ".cgx"      CGX output
//  ".cif"      CIF output
//  ".gds"      GDSII output
// The files will be named in the form basename_X_Y.ext, where the
// .ext is the extension supplied, and X,Y are integer indices
// representing the grid cell.  The 0,0 grid cell has its lower left
// corner at x0,y0 before bloating by the border width, and the
// indices increase with increasing x,y.  If negative, the character
// 'm' is used instead of a minus sign.  Each file will consist of a
// single cell, whose name is tha name of the file with the extension
// stripped, containing the geometry for that grid cell.
//
// In addition to the channel output files, an Xic cell file is
// written, using the basename without the extension, that references
// each of the channel files.  Opening this cell will open all of the
// channel files, showing all geometry from the original file (memory
// limits permitting).
//
// This function reads data directly from the source file to minimize
// memory use.  All files are opened and written in parallel.  The
// number of grid cells (and thus open files) is limited to 1000,
// however the user may still encounter system limitations on the
// number of file descriptors open simultaneously.  The function
// returns 1 on success, 0 otherwise.
//

// WriteGeomSplit(fname, cname, basename, l, b, r, t, x0, y0, w, h, b)
//
// This function will read the CGX, CIF, or GDSII file fname, and split
// to geometry in cname into a collection of flat files covering a grid,
// in the manner of the SkelWriteGeomSplit() function.  If cname is 0,
// the top-level cell, if unique in the file, will be assumed.  This
// function operates outside of skeleton mode, and should consume far
// less memory and may be faster than reading/writing in skeleton mode.
//
// Each output file contains the geometry for a cell in a defined
// grid, including some possible overlap with neighboring grid cells. 
// The l, b, r, t define a rectangle, in microns, which is the area
// over which the grid will be defined.  This is typically the
// bounding box of the top-level cell.  Unlike in skeleton mode, the
// size of the bounding box is not known, and must be entered.  The
// area can be smaller than the bounding box, which will truncate the
// grid, however objects are not clipped to this boundary.
//
// The x0, and y0 (in microns) set the grid origin relative to the
// origin of the current cell.  The wid and hei (in microns) set the
// periodicity of the grid, i.e., the unit cell width and height.  The
// border, in microns, is the amount by which the grid cell is bloated
// before geometry is extracted and written.  This must be positive or
// zero.
//
//
// The basename is a cell path name, with an extension which gives the
// type of file to create.  One of the following extensions must be
// provided:
//  ".cgx"      CGX output
//  ".cif"      CIF output
//  ".gds"      GDSII output
// The files will be named in the form basename_X_Y.ext, where the
// .ext is the extension supplied, and X,Y are integer indices
// representing the grid cell.  The 0,0 grid cell has its lower left
// corner at x0,y0 before bloating by the border width, and the
// indices increase with increasing x,y.  If negative, the character
// 'm' is used instead of a minus sign.  Each file will consist of a
// single cell, whose name is tha name of the file with the extension
// stripped, containing the geometry for that grid cell.
//
// In addition to the channel output files, an Xic cell file is
// written, using the basename without the extension, that references
// each of the channel files.  Opening this cell will open all of the
// channel files, showing all geometry from the original file (memory
// limits permitting).
//
// This function reads data directly from the source file to minimize
// memory use.  All files are opened and written in parallel.  The
// number of grid cells (and thus open files) is limited to 1000,
// however the user may still encounter system limitations on the
// number of file descriptors open simultaneously.  The function
// returns 1 on success, 0 otherwise.
//

Dropping a property in an empty Property Editor or Property Info window
would crash the program.

MSW -- test sPi::odesc in drop hdlr

functions above, add window limiting description (SkelDataBB)

Fixed bug in renaming cells from GDSII files.  Cell names were
being changed unnecessarily.

File selection file listing was not being updated properly when
files in directory change.
CHECK MSW

Clicking on a subcell on physical mode while the edit prompt is active will
inject the cell name into the edit line.  Previously, "_UNKNOWN_" was
injected.
----------------------------------------------------------

Fixed subtle display bug for cell arrays.

Fixed scaling bug in skeleton mode from GDSII files.
-----------

TODO: call ShowParameters from save function, erase "Mod".

read/write alias cell in gdsii conversion.

Xic was not checling for recursion when opening a native cell file and
would crash if passed such a cell.  Xic will not preoperly abort with
an error message if recursion is encountered.

The Save() script function will no longer write a cell file with the
same name as an existing cell in memory not the current cell.  This
avoids creating recursive cells.

CDsymGen and CDsGen can now handle recursive hierarchy.

On reading a recursive hierarchy, all cells in the hierarchy are deleted,
see end of CD.Open().

problem with destructor for property panel sP/sPi: core leak in Unix/Linux,
double free in Windows.

New trapezoid clipping functions, may be a little faster.

In SkelWriteGeomSplit(), extra files were being generated.

Parameter area updated, to get rid of "Mod" when cell saved.  This was not
always happening.

Special case added to function that builds polygons from zoid lists for
groups containing only one zoid.

Replaced Poly::remove_inline_verts() with more efficient function.

Memory monitor functions moved to malloc/monitor.cc
Turn on.off in Makefile
environment: MMON_STARTUP [-N]

Misc tweeks to Ylist functions to try and speed execution.

Enabled interrupt handling while in server mode.

Enabled OOB handling on server socket.

Fixed mess when stopping grapnics in background drc.

GRX modified >>> change MSW!!!

When NoCheckEmpties is set or the "Skip cehcking for empty cells" option
is checked in the Conversion - Import panel, the empty cell test is
skipped while reading, meaning no messages about empty cells will
appear in the log file.  Previously, this variable would cause the
skipping of a second test, after reading, for empty cells that would
pop up a dialog window if empties were found.  This is still true,
but new the testing while reading is also suppressed.

in gds-text output,  M-UNIT and U-UNIT records were omitted.

The conversion scale in Convert/Convert was being applied twice.  Worse,
if a source GDSII file had non-unit scaling, that scaling would be applied
twice.

int Convert/Convert, the source and destination files can no longer be
the same.

Two text windows of the same size at the same location could get into a
competition and loop after an expose event, disabling the application
until one window was moved.

Changes to Ruler command (View Menu)

Rulers are now disabled in Electrical mode.

The rulers are now saved for each cell, so that if the editing context
changes, the rulers will still be there when the original cell is edited
again (the rulers will disappear if a cell in memory is overwritten, however).

New '!' command: !dr [arg]

This will delete currently displayed rulers.  If no arg is given, the most
recently generated ruler is deleted.  The arg can be an integer, or 'a'.
if 'a' is given, all rulers are deleted.  If a number is given, that ruler,
counting backward from the most recently generated, will be deleted, i.e.,
0 erases the most recent ruler, 1 erases the one before that, etc.

New selection behavior
If something is selected, clicking in a drawing window in an empty area
will deselect the the head of the selection list, which is the last
object selected.  If this new behavior is found to be undesirable, it
can be turned of by setting the variable NoDeselLast.
-------------------------------------------------------------

Unix/Linux only
There was a zlib conflict that prevented the png file format from working.
The 64-bit and 32-bit zlibs are now separate.

There was a protability problem with the gtk theme engine which is dynamically
installed on some systems.  Unless the engine supplied on the user's system
is compatible with the libraries used by Xic, this would fail, and in at
least one case Xic would not run.  Xic now uses a default theme known
to work (see README under default_theme in the startup directory).  This can
be disabled, i.e., the system themes used, by setting the envoironment
variable XT_USE_GTK_THEMES.  This applies to Xic and WRspice.
----------------------------------------------------------

New command line option: -Lserverhost

This supplies the host name of the machine running the license server.
Note that there is no space after -L.  If given, this will override
the server host supplied by other means.

hierarchy:
-Lserverhost
XTLSERVER in environment
license.host file
xtlserver in /etc/hosts
name of local machine

MSW - wrspice error message window does not wrap text - check wrapping
elsewhere
-----------------------------------------------------

Windows only:
Fixed bug, in various places, use of inode field in stat function
return, this field is always 0 in Windows.  Most notably, the
translations in Convert/Convert would fail with the message
"Source and destination files are the same!"

The model.lib file would not be found in the current directory, unless
the current directory is in the LibPath.  As with other startup files,
the current directory will now be searched for model.lib before looking in
the path.  The "models" subdirectories will be found only in the
path.

stack-walk capability for Solaris added (malloc).

added theme library to build, special build to avoid dependence on shared
libs.

Fixed core leak in error logging function.

Extraction functions would leave a pointer set that would cause instablity
if cells were iverwritten in memory.
/*
Global changes to handle CDp::dup returning 0, so CDp_oset doesn't copy.
CDp_oset destructor clears Terminal::oset.
*/

If a device.lib or model.lib file was found in the current directory
at startup, and that directory is not in the LibPath, if one changes to
another directory these files would not be accessible.
--------------------------------------------------------------

Some improvements and fixes to the script debugger:

     
  1)  (Unix/Linux only)
      Arrow keys pressed while the debugger has focus would cause
      funny behavior, every other press would be sent to the main
      window, where it would translate the layout.  This should
      work correctly now.

  2)  (Unix/Linux only)
      When single stepping, and the acript is executing an "Ask"
      function, i.e., the prompt line editor is active, if the
      debugger was killed with a delete window message (i.e., the
      X button in the title bar), there would be error messages
      from GTK and possibly a program crash.  This is now safe.

  3)  (Unix/Linux only)
      If the title bar X button was used to delete the debugger
      window, all changes would be lost.  This is no longer true.
      If the script text was changed, when exiting in this way,
      Xic will save the text as the name of the script file with
      a ".sav" extension.  Of course, using the menu Quit button to
      exit will prompt whether to save changes as usual.

  4)  When single stepping, the keyboard focus now automatically
      reverts back to the debugger after executing an instruction
      that changes the focus to another window.
      
  5)  (Windows only)
      The auto-detection of text modification was not working, so
      the save button was never enabled!  I guess that Windows
      users never debug scripts?
 
Fixed a used-after-free problem in the help viewer which would very
occasionally cause segmentation faults.

Minor clean-up in multi-component device estraction.

Bug fixed in series/parallel merging - extracted value was sometimes
incorrect for complex networks involving both series and parallel
devices.

Fixed GTK errors in server mode.
todo *** PopUpMergeControl return correct overwrite setting.
new NULLapp struct


  (int) IsCellInMem(cellname)

    This function returns 1 if the string cellname is the name of a
    cell in the current symbol table, 0 otherwise.

  (int) IsFileInMem(filename)

    This will compare the string filename to the source file names
    saved with top-level cells in the current symbol table.  If
    filename is a full path, the function returns 1 if an exact match
    is found.  If filename is not rooted, the function returns 1 if
    the last path component matches.  In either case, 0 is returned if
    no match is seen.  Only the top-level cells are searched, so
    filenames of subcells in Xic hierarchies will not be found.

  (int) NumCellsInMem()

    This function returns an integer giving the number of cells in the
    current symbol table.

  (stringlist_handle) ListCellsInMem()

    This function retuns a handle to a list of strings, sorted
    aplhabetically, giving the names of all cells in the current
    symbol table.

  (stringlist_handle) ListTopCellsInMem()

    This function retuns a handle to a list of strings, sorted
    aplhabetically, giving the names of top-level cells in the current
    symbol table.  These are the cells that are not used as subcells,
    in either physical or electrical mode.

  (stringlist_handle) ListModCellsInMem()

    This function retuns a handle to a list of strings, sorted
    aplhabetically, giving the names of modified cells in the current
    symbol table.  A cell is modified if the contents have changed
    since the cell was read or last written to disk.

  (stringlist_handle) ListTopFilesInMem()

    This function returns a handle to a list of strings,
    alphabetically sorted, giving the source file names of the
    top-level cells in the current symbol table.

The Empty Symbols pop-up would delete all empty symbols if Apply was
pressed, whether or not the cell was marked for deletion.

The Empty Symbols pop-up caused occasional segmentation faults.  This
is probably fixed, but I am unable to reproduce the error.  Some code
that was skipped for efficiency is now executed, since it appears to
be needed.

All conversion scaling and object magnification factors can now be in
the range 0.001 through 1000.0.

There is now a warning message printed in the conversion log file if a
cell bounding box extends beyond "infinity".  When this happens, which
is generally the result of incorrect scaling, Xic will have trouble
displaying the cell, and a whole lot of other things won't work
properly.  This should probably be a fatal error, however I decided to
allow Xic to continue to help the user figure out what the problem is.

The value of infinity is one million microns.

Fixed problems with dates in CGX/GDSII files:
   The year values were incorrectly specified
   In gds-text files, the printing was messed up.
---------------------------------------------------------------

Fixed scaling problem with magnified cells in Flatten.
------

Manual errata:
SetTransform function
"about the x/y axis" should be "of the x/y axis"
4 locations.

Help system:
   substitute %TITLE% in !!HEADER text
   system uses first !!HEADER, !!FOOTER encountered, used to be last

Fixed bug in merge fuction - redundant pass through loop.  Minor tweeks.

Fixed core leak in argument cleanup function for strings in script evaluation.

More pointer consistency tests added to memory dallocation function.  This
should produce memory allocation error messages instead of core dumps if
memory gets corrupted.

The xic_mem_errors.log file is now generated in the temporary log
directory, instead of the current directory.  This file is
generated/appended to if memory errors are detected.  If this file
exists when Xic exits, it will be emailed to Whiteley Research (by
default).  However, if XICNOMAIL is set in the environment, the file
will instead be moved to the current directory, and a message will be
printed requesting that the user mail it to Whiteley Research.

Fixed bug in help viewer, text wasn't flowing around tables correctly.

New variable: NoPopUpLog (boolean)

When set, the File Browser loaded with the log file which appears if
there were errors or warnings when reading an input file or writing
output will not appear.  This applies to the Edit command and
equivalent, and the file input/output operations in the Convert Menu. 
It is not recommended to set this in general, but the browser popping
up does become annoying at times, so this variable can be set when the
user knows what to expect in the file.

Changes to the periodic license validation code to avoid ill-effects
due to timing of this asynchronous process.

Additions to the help text:
    A Quick Tour of the Xic Menus
    A Quick Tour of Xic Capabilities

Fixed a bug:  If a layer name starts with a digit, if would likely not
be recognized in layer expressions.  For example, using such layer
names in the Rules Editor wouldn't work.

TEXT added to layer_exp in help:
    If the names of any defined layers are numeric values, one must be  
    a little careful when specifying the the equivalent numeric value,
    since a layer name interpretation will sepersede a numeric
    interpretation.  For example, in the presence of a layer named
    "1", one could use "1.0" to specify the number 1.

TEXT added to layertab in help:
  In either case, layers
    that happen to have the same color as the selected blinking layer
    will also blink, since the operation is sensitive only to the
    layer color.

TEXT added to button3 in help:
    second paragraph modified

-----------------------------------------------------------------

New function:

// SaveCellAsNative(cellname, directory)
// 
// Save the cell named in the first (string) argument, which must
// exist in the current symbol table, to a native format file in the
// directory.  If the directory string is null or empty (or 0 is
// passed for this argument), the cell is saved in the current
// directory.  The function returns 1 if the save was successful, 0
// otherwise.
//

// HCshowAxes(style)
//
// This function sets the style or visibility of axes shown in plots
// of physical data (electrical plots never include axes).  The
// argument is an integer 0-2, where 0 suppresses drawing of axes, 1
// indicates plain axes, and 2 (or anything else) indicates axes with
// a box at the origin.  The return value is the previous setting. 
// Note:  This is ignored if the rendering driver has "NoAlt" set, use
// ShowAxes() in this case.

// HCshowGrid(show, mode)
//
// This function determines whether or not the grid is shown in plots. 
// If the first argument is nonzero, the grid will be shown, otherwise
// the grid will not be shown.  The second argument indicates the type
// of data affected:  zero for physical data, nonzero for electrical
// data.  The return value is the previous setting.  Note:  This is
// ignored if the rendering driver has "NoAlt" set, use ShowGrid() in
// this case.

// HCsetGridInterval(spacing, mode)
//
// This function sets the grid spacing used in plots.  The first
// argument is the interval in microns.  The second argument indicates
// the type of data affected:  zero for physical data, nonzero for
// electrical data.  For electrical data, the spacing in microns is
// rather meaningless, except as being relative to the default which
// is 1.0.  The return value is the previous setting.  Note:  This is
// ignored if the rendering driver has "NoAlt" set, use SetGrid() in
// this case.

// HCsetGridStyle(linemod, mode)
//
// This function sets the line style used for the grid lines in plots. 
// The first argument is an integer mask that defines the on-off
// pattern.  The pattern starts at the most significant '1' bit and
// continues through the least significant bit, and repeats.  Set bits
// are rendered as the visible part of the pattern.  If the style is
// 0, a dot is shown at each grid point.  Passing -1 will give
// continuous lines.  The second argument indicates the type of data
// affected:  zero for physical data, nonzero for electrical data. 
// The return value is the previous setting.  Note:  This is ignored
// if the rendering driver has "NoAlt" set, use SetGridStyle() in this
// case.

// HCsetGridOnTop(on_top, mode)
//
// This function sets whether the grid lines are drawn after the
// geometry ("on top") or before the geometry.  If the first argument
// is nonzero, the grid will be rendered on top.  The second argument
// indicates the type of data affected:  zero for physical data,
// nonzero for electrical data.  The return value is the previous
// setting.  Note:  This is ignored if the rendering driver has
// "NoAlt" set, use SetGridOnTop() in this case.

64-bit stat() calls isolated.  Call special functions defined in zio.cc
instead of stat().
XXX mswdimen.cc

Modifications to source tree organization and code to support new
Sparc64 full 64-bit distribution.

Prevent duplication of pseudo-flat generators in consistency test table.
Duplication could cause (or was causing) faults.
----------------------------------------------------------

The Routing keyword could not be deleted in the Extraction Parameter Editor.

The Extraction Parameter Editor has some changes:
  1)  The Apply button is gone.  Changes are now in effect when they are
      visible in the listing window, the same as in other parameter editing
      pop-ups.
  2)  When a parameter is changed, internally all grouping is invalidated,
      the Show Groups/Show Nodes mode is turned off, and any active command
      is terminated.  Grouping is reestablished when a command is selected
      that requires grouping/extraction/association.

When parsing a layer expression, a token that is a 4-digit hex number
is taken as a layer name, not a number, even if no layer by that name
exists.  This is necessary so that when reading the technology file,
layer expressions can reference layers with numerical names from GDSII
that have not yet been defined.

mswextrc.cc!!!

New substitution escape in Device block format statements:
   %p lname pnum"

lname is the name of a layer, space after the 'p' is optional.  The pnum
is a non-negative integer.

The token is replaced with a propertu string corresponding to pnum.  Each
of the objects on lname that intersects the device bounding
box is checked for a property pnum.  The string of the first such property
found is used.

TODO
    NoConvertSymbolic ? (Symbolic layers like LB, LC, LX)
    way to prevent electrical devices/subckts from LVS

New variable:  RulerSnapToGrid (boolean)
When set, when entering the Rulers command the snap-to-grid mode will
be initially set.

New Variable:  ShowDots (boolean or 'a')
    This sets the drawing of connection indications in electrical mode,
    similar to the dots button in the side menu (which internally sets
    this variable).  If set to a word starting with "a", all connections
    are marked with a dot.  If set to anything else, only the potentially
    ambiguous connection points are marked with a dot.  When unset, no
    dots are shown.

If a name property of a subcircuit was changed in electrical mode, the
terminals did not properly reflect the change.

In electrical mode, with terminals displayed, the terminals display
was not being updated correctly after a modification.


The default numbering for electrical devices and subcircuits has changed.
Previously, devices were numbered in order of creation.  Now, devices
are numbered in database order.  This is keyed by the upper left corner of
the device bounding box, and increases downward, or to the right for devices
with the same Y value.  Thus, the numbering should be less random.

Tried to improve some of the ancient spaghetti code that has evolved with
respect to updating device labels and terminals on-screen, after an operation
or undo/redo.  Fixed a few things that weren't quite right along the
way.

// (int) RenameCell(oldname, newname)
//
// This function will rename the cell in memory named oldname to
// newname, and update all references.  The function returns 1 if the
// operation was successful, 0 otherwise.  The oldname cell must exist
// in memory, and the newname can not clash with an existing cell or
// library device.
//

in the Convert pop-up under the Convert Menu, if the input and output formats
are both GDSII or both CGX, the file is directly copied, possibly with
compression or decompression, avoiding parsing.  The ".gz" suffix on
the input or output file names indicates whether compression/decompression
is applied.  Unlike some versions of the standard gzip/gunzip utility,
this is applicable to files larger than 2Gb.


The Properties Editor was not allowing creation of mor than one Other
properties - addin an Other property would overwrite an existing Other
property.

The Add menu of the Cell properties Editor has changed slightly.  It
is now possible to add "Other" properties to cells in electrical mode. 
These have no meaning to Xic, but might be of use to the user.  Any
number of these properties can be added.

It is now possible to add Other properties to subcircits.  This was
disabled previously.

New '!' commands:

gzip infile [outfile]

The will compress the file given as infile using the gzip method.  If
outfile is not given, output is written to a file with the same name as
infile but with a ".gz" extension.  Otherwise, the file name given for
outfile must have a ".gz" extension.  Under Unix/Linux (except for the
older Solaris distribution) this uses 64-bit file offsets so can be
applied to files larger than 2Gb, unlike some versions of the GNU gzip
upility.  Unlike the GNU gzip program, this will not delete infile.

gunzip infile [outfile]

This will uncompress the file given as infile, which was previously
compressed with gzip, and has a ".gz" extension.  If no outfile is
given, output is written to a file with the same name as the infile
but with the ".gz" suffix stripped.  Under Unix/Linux (except for the
older Solaris distribution) this uses 64-bit file offsets so can be
applied to files larger than 2Gb, unlike some versions of the GNU
gunzip upility.  Unlike the GNU gunzip program, this will not delete
infile.

The Apply button is gone from the GDSII parameter editor.  The state
is as shown in the listing.

Windows only
The Routing and Conductor keywords in the menu of the Extract Parameter
Editor were switched.

Undo function did not work in GDS Parameter editor.
--------------------------------------------------------------

TODO
   streaming place
   NOLVS property
   DeleteEmpties function

If there are exactly two layers, LayerHandle(0) would return only one.

The ListConcat script function no longer appends a separation string
after the last list element.

forms like SomeFunc(FuncReturningHandle(), ...) would not automatically
close the handle from FuncReturningHandle

When the SkeletonMode variable is unset, the flag for each cell that
indicates that it was read in skeleton mode are now reset.  Thus, any
skeleton hierarchy in memory will look for all purposes like a normal
cell hierarchy.

When using the Tcl/Tk interface, trying to execute a Xic function that
has no return or returns a null string would crash the Tcl interpreter.
Tcl is now given an empty string from such functions.

// Unset(name)
//
// This function will unset the variable.  No action is taken if the
// variable is not already set.  This is equivalent to Set(name, 0).
//

// DeleteEmpties(recurse)
//
// This function will delete empty symbols found in the hierarchy
// under the current cell.  This operation can not be undone.  The
// argument is an integer flag; if zero, one pass is done, and all
// empty symbols are deleted.  If the argument is nonzero, additional
// passes are done to delete symbols that are newly empty due to their
// subcells being deleted on the previous pass.  The top-level symbol
// is never deleted.  The return value is the number of symbols
// deleted.  No symbols will be deleted if the top-level symbol was
// opened in skeleton mode, and skeleton mode is active (the
// SkeletonMode variable is set).

During reading GDSII (at least), Xic would incorrectly identify some
cells as empty and emit a bogus warning.  Cells with no physical
objects, but containing subcells, would be incorrectly identified as
empty.

New '!' command:  !assemble configfile
This command implements a feature whereby several archives can be
merged into a larger archive, on-the-fly so as to avoid memory
limitations.  The output consists of a definition of a top-level
cell, containing instances of cells found in the archive, followed
by the translated records from the archive files.  The input and
output can be GDSII, CGX, or CIF, in any combination.  
The opeeration is controlled by a specification file which supplies
the file names and the description of the top-level cell.  It is a
simple text file, perpared by the user, containing a number of
keywords with values.  The format is illustrated below.

Only physical data are translated, electrical data will be stripped. 
Presently there is no scaling, windowing, or flattening capability.

The configuration file format:

# Comments start with '#', blank lines are ignored
# Other lines start with a keyword

# This is mandatory: name of output file
OutFile out_file_name
# Optional top-level cell added for placing subcells
TopCell cellname
# Name of a source file, must be one or more
Source filename
# The remaining keywords describe cell placement in the topcell. 
# There can be arbitrarily many of these blocks, though none should
# appear if no topcell is given.  Each block starts with a Place line,
# followed by optional transformation lines as shown.  The
# trnaformation is the same as usen in the GDSII and CGX formats.  The
# translation coordinates are in microns.  Reflection is about the
# X-axis before rotation.  The angle is in degrees, counterclockwise. 
# For CGX and GDSII, any angle can appear and will be accepted,
# however Xic only allows 45 degree multiples.  If converting to CIF,
# only 90 degree multiples are accepted.
Place cellname
Translate x y
Rotate angle
Magnify magn
Reflect

Minor hacks in the WriteGeomSplit/SkelWriteGeomSplit script functions
to avoid Linux file i/o problem that would cause early termination
with a write error.

TODO
  default to present cell in Edit command
  chec Rename -> RenameCell indocumentation.

New error reporting structure inplemented.

// (string) GetError()
//
// This returns the current error text.  Error messages generated by
// an unsuccessful operation that opens, translates, or writes cells
// or manipulates the database, can be retrieved with this function
// for diagnostic purposes.  This function should be called
// immediately after an error return is detected, since subsequent
// operations may clear or change the error text.  If there are no
// recorded errors, a "no errors" string is returned.  This function
// never fails and always returns a message string.
//
// AddError(string)
//
// This function will add a string to the current error message, which
// can be retrieved with GetError().  This is useful for error
// reporting from user-defined functions.  Any number of calls can be
// made, with the retrieved text consisting of a concatenation of the
// strings, with line termination added if necessary, in reverse order
// of the AddError calls.  No other built-in function should be
// executed between calls to AddError, or between a call that
// generated and error and a call to AddError, as this will cause the
// second string to overwrite the first.

// (int) GetLogNumber()
//
// Return the integer index of the most recent error message dumped to
// the errors log file.  The return value is 0 if there are no errors
// recorded in the file.
//
// (string) GetLogMessage(message_num)
//
// Return the error message string corresponding to the integer
// argument, as was appended to the errors log file.  The 10 most
// recent error messages are available.  If the argument is out of
// range, a null string is returned.  The range is the current index
// to this index minus 10, or 1, whichever is larger.
//
// (int) AddLogMessage(string)
//
// Apply a new error message index to the string, and append the
// string the the error log file.  The return value is the index of
// the new message, or 0 if the string is empty or null.
//


The following script functions no longer write errors to the prompt
line.  Instead, GetError() should be called after a failure to obtain
the error text.
    SkelWriteGeomSplit
    WriteGeomSplit

From functions:
    writes errs to log and prompt line

in To, on failure both outfilename and outfilename.bak would be deleted,
now, outfilename.bak -> outfilename.

Convert/Convert to non-native:
   .bak file now created
   if fails, file restored from .bak

In Convert:  filecopy of not using layers, scale == 1

Edit command: default to current cell name
---

New property for electrical devices and subcircuits: NoPhys

When this property is applied to an electrical device or subcircuit,
that device or subcircuit is assumed to have no physical
implementation and is ignored in LVS testing.

In order to actually simulate a circuit, it is necessary to add sources
and perhaps other devices to the circuit, which have no counterparts in
the physical layout.  Previously, this sould cause LVS errors.  Now, the
NoPhys property can be added to the additional devices to avoid these
errors.

The numerical value of the property is 5
The property string is "nophys"
Devices inherit this property from cell definitions in the device library
file.

The Properties Editor has been modified to allow adding and deleting
NoPhys properties.

The supplied device.lib file has been updated to supply this default
property on voltage and current sources.

The imsave library, used to generate image files, assumed that the
various helper functions (convert from ImageMagick, the netpbm functions,
cjpeg and djpeg) were located in /usr/local/bin. Now, the programs will
be looked for along a search path.  The serach path (a colon-delimited
list of directories) can be provided in the environment variable
IMSAVE_PATH.  If not set, the internal path is
"/usr/local/bin:/usr/X11R6/bin".

functions, "nophys keyword"

!select, !deselect : 'y' for NoPhys property
Propereties editor remove: 'y'


memory error fixed in HCdump().

The AltRGB, AltFilled, and AltVisible values, if not set in the technology
file, ard now initialized to the RGB, Filled, and Visible values.
Previously, these were given an internal initialization.

Fixed bugs in help viewer:
  1) Exiting after using Print generated GTK error messages.
  2) Print preformatted text (<pre>...</pre>) didn't work.
------------------------------------------------------

Changes to the script parser.

Static and Global declarations of arrays with dimension higher than one
were not working.

Keyword recognition now uses a hash table, should speed up the parse.

In previous releases, the script parser, when reading the following
constructs, would assume that the construct occupies the rest of
the current line of text.  That is, the parser would stop reading
after reading the construct, and anything that follows on the line
would be ignored.  However, this behavior could be modified if a
semicolon (';') followed the construct.  In that case, the parser
would continue reading after the semicolon, as if reading a new line.

    goto label
    statement
    end
    break [n]
    continue [n]
    return [statement]
    function xxx(...)
    endfunc
    static ...
    global ...

In the present release, the parser will continue reading after all of
these constructs, whether or not a semicolon is present.  Thus, with
a couple of exceptions, an entire script can now be given on a single
line.  This is not recommended, as line-numbered error messages would
not mean much, and the debugger would be useless, however this facilitates
creating complicated macros with the '#define' keyword, which must always
expand to a single line.

The two exceptions are:
  1)  Comments start with '#' and continue to the end of the current
  line.  It is not possible to include command text after a comment on
  a line.
  2)  The declaration lists that follow the static and global keywords
  must be terminated with a semicolon if a different construct is to
  appear on the same line following the static or global construct.

The semicolon will still explicitly terminate a construct as before,
and may be needed in rare cases where the parser has trouble interpreting
the syntax.  The only place where a semicolon is required is to
terminate the static and global declaration lists, if further command
text follows on the line.

This change should not affect existing scripts, unless the script author
"cleverly" took advantage of the previous behavior to "hide" comments,
for example:

   b = (expression)   any text can go here since it is ignored

Presently, this would work fine if a comment character ('#') is
added ahead of the text:

   b = (expression)   # any text can go here since it is ignored

Note that for comments, all text on the line following '#' is ignored.
Specifically, The semicolon mechanism will not work following a comment.


The format of the distributions files has changed (except for Linux).
Distributions are not provided in the "native" format for the operating
system, avoiding the need to install the rpm program.

The reasons for making this change are
1) This should simplify the installation process
2) Portability of the rpm program itself and distributions created with
   it have become issues.

Linux:
The Linux and Linux2 distribution use rpm as before.

FreeBSD:
FreeBSD distributions are tar-balls for use with the pkg_add command.

Solaris:
Solaris and Solaris8 distributions use the Solaris streaming package
format, for use with the pkgadd command.

All distributions have been released, or the version numbers incremented
and re-released, in the new formats.

The wr_update script, provided in the accessories directory, has been
updated to handle the new file types.  It has also been enhanced in
other wanes, for example it no automatically knows of the releases
are installed in a non-standard location.

There is a new wr_install script available.  This performs file
unpacking ane installation, and can be used for initial installation,
or subsequent installations.  It basically hides the sequence of
operating system commands from the used, simplifying things.


All of the XicTools programs now respond to the XT_PREFIX environment
variable.  When the tools are installed in a non-standard location,
i.e., other than /usr/local, this can be set to the directory prefix
which effectively replaces "/usr/local", and the programs should be
able to access the installation library files without further directives.
The XIC_LIB_PATH, etc. variables still work, and have precedence.


Fixed bug in table indentation in help viewer.

Solariis: need libxsdev.so or is libxsdev.so.2.0 ok (newindex.html)
update secure/README

todo: change layer during move/copy

Handle XT_PREFIX
    xic/xicii
    wrspice, wrspiced
    mozy
    xtlserv

The FreeBSD and Solaris distributions no longer use the rpm program and
instead use the native package facilities.  The installation procedure
is somewhat different, see the installation instructions on the web site.

There is a new wr_install script supplied with the distribution files
on the web site.  This facilitates the unpacking and installation of
the files.  The install a distribution, as root give
wr_install distfile ...
where the arguments are downloaded distribution files (but don't change
the distribution file names!).

It is now possible to change the layer of objects during a move/copy
operation.  This applies the the basic pointer operations, the Move
and Copy menu commands, and the placement part of the spin (side menu)
command.

During the time that objects are ghost drawn and attached to the mouse pointer,
if the current layer is changed, the objects that are attached will be
placed on the new layer.  Subcells are not affected.  If in layer-specific
mode, only objects whose layer was the original current layer will be
changed to the new layer.  If not in layer-specific mode, all new objects
will be placed on the new layer, no matter what their original layer.
If the current layer is set back to the previous layer before clicking to
locate the new objects, no layers will change.  Note that layer change is
only possible for "click-click" mode and not "press-drag".

!mo dx [ dy [layer_name]]
!co dx [ dy [layer_name]]
The third argument, if given, will allow a layer change during the
move.  It should be the name of a layer that is
not the current layer.  If in layer-specific mode, objects being moved
that are on the current layer will be moved to layer_name.  If not in
layer-specific mode, all objects moved will be changed to layer_name.
Subcells are not affected.

New command
!ro x y angle [layer_name]
This command will rotate all selected objects about x,y (given in microns)
by angle (given in degrees) counterclockwise.

modified text
// (int) Copy(fromx, fromy, tox, toy)
//
// Copies of selected objects are created and placed such that the
// point specified by the first two arguments is moved to the location
// specified by the second two arguments.  The return value is 1 if
// there were no errors and something was copied, 0 otherwise.
//
// (int) Move(fromx, fromy, tox, toy)
//
// Moves the selected objects such that the reference point specified
// in the first two arguments is moved to the point specified by the
// second two arguments.  The return value is 1 if there were no
// errors and something was moved, 0 otherwise.
//

NEW
// (int) CopyToLayer(fromx, fromy, tox, toy, oldlayer, newlayer)
//
// This is similar to the Copy() function, but allows layer change. 
// If newlayer is 0, null, or empty, oldlayer is ignored and the
// function behaves identically to Copy().  Otherwise the newlayer
// string must be a layer name.  If oldlayer is 0, null, or empty, all
// copied objects are placed on newlayer.  Otherwise, oldlayer must be
// a layer name, in which case only objects on oldlayer will be placed
// on newlayer, other objects will remain on the same layer.  Subcell
// objects are copied as in Copy(), i.e., the layer arguments are
// ignored.
//
// (int) MoveToLayer(fromx, fromy, tox, toy, oldlayer, newlayer)
//
// This is similar to the Move() function, but allows layer change. 
// If newlayer is 0, null, or empty, oldlayer is ignored and the
// function behaves identically to Move().  Otherwise the newlayer
// string must be a layer name.  If oldlayer is 0, null, or empty, all
// moved objects are placed on newlayer.  Otherwise, oldlayer must be
// a layer name, in which case only objects on oldlayer will be placed
// on newlayer, other objects will remain on the same layer.  Subcell
// objects are moved as in Move(), i.e., the layer arguments are
// ignored.
//
// (int) RotateToLayer(x, y, ang, oldlayer, newlayer)
//
// This is similar to the Rotate() function, but allows layer change. 
// If newlayer is 0, null, or empty, oldlayer is ignored and the
// function behaves identically to Rotate().  Otherwise the newlayer
// string must be a layer name.  If oldlayer is 0, null, or empty, all
// rotated objects are placed on newlayer.  Otherwise, oldlayer must
// be a layer name, in which case only objects on oldlayer will be
// placed on newlayer, other objects will remain on the same layer. 
// Subcell objects are rotated as in Rotate(), i.e., the layer
// arguments are ignored.
//
// (int) ObjectMoveToLayer(object_handle, refx, refy, x, y, all,
//     oldlayer, newlayer)
//
// This is similar to the ObjectMove() function, but allows layer
// change.  If newlayer is 0, null, or empty, oldlayer is ignored and
// the function behaves identically to ObjectMove().  Otherwise the
// newlayer string must be a layer name.  If oldlayer is 0, null, or
// empty, all moved objects are placed on newlayer.  Otherwise,
// oldlayer must be a layer name, in which case only objects on
// oldlayer will be placed on newlayer, other objects will remain on
// the same layer.  Subcell objects are moved as in ObjectMove(),
// i.e., the layer arguments are ignored.
//
// (int) ObjectCopyToLayer(object_handle, refx, refy, x, y, all,
//     oldlayer, newlayer)
//
// This is similar to the ObjectCopy() function, but allows layer
// change.  If newlayer is 0, null, or empty, oldlayer is ignored and
// the function behaves identically to ObjectCopy().  Otherwise the
// newlayer string must be a layer name.  If oldlayer is 0, null, or
// empty, all copied objects are placed on newlayer.  Otherwise,
// oldlayer must be a layer name, in which case only objects on
// oldlayer will be placed on newlayer, other objects will remain on
// the same layer.  Subcell objects are copied as in ObjectCopy(),
// i.e., the layer arguments are ignored.
//
-----------------------------------------------------------------

(Unix/Linux Only)
The file selector would always initially list the files in a single
column.


Improved the drag/drop in Fillpattern Editor, less flicker now.
Dump Defs now pops up information message.

New math functions for scripts:
    floor(x)
        Returns the largest integer value less than or equal to x.
    celi(x)
        Returns the smallest integer value greater than or equalt to x.
    rint(x)
        Returns the integer rounded to x according to the system's
        rounding mode (always round-to-nearest).
       

Clickin in the prompt line with button 2 in edit mode, with no active
text selection, would make the test cursor disappear temporarily.

Fixed subtle problem in File Selection pop-up.
Assume current cell is a modified native cell.
double-click file in file selection, this generates prompt line msg
enter 'y' Enter on prompt line, brings up directory selector
click on other names in file selector
move pointer to main window and press Esc, removes directory selector
Find either a "garbage" word selected in file selector, or program crash.


gdsii->text, units record printed twice.
---------------------------------------------------------------------

Tweek to polygon-to-trapezoids algorithm to ensure that decomposition
is completely horizontal (or vertical).

todo: Select: tag in info line not updated correctly after undo.
      Jelle comment

todo: implement join mode
      check all write funcs for oversize poly, wires

JoinMaxPolyVerts can be 0, in which case there is no limit.

New variable:  JoinBreakClean (boolean)
In the !join command and similar functions, when building
up the polygons and the vertex limit (JoinMaxPolyVerts) is reached,
ordinarily the present polygon is output, and a new one is started
immediately.  This generally produces a set of polygons with
complicated and seemingly arbitrary borders.  If this variable is
set, then the polygons are initially built ignoring the vertex
limit, and polygons that exceed the vertex limit are split into pieces
along Manhattan bisectors, so that no piece exceeds the vertex
count.  This gives a much nicer looking layout, but is more
compute intensive.

The !join command, and the Join() and JoinObjects() script functions,
and other commands sucha s !layer which perform a join operation,
are sensitive to four variables which fine-tune the behavior and
performance.  The default values emphasize speed but limit the
complesity of resulting polygons.  The user may need to set one or
more of these variables in order for the operation to meet
requirements.

To join a collection objects, the first step is to decompose each
object onto a collection of trapezoids.  As the objects are decomposed,
the trapezoids are added to a list, which will be sent on to the function
which performs the join.  The variable JoinMaxPolyQueue sets the limit on
the number of trapezoids that can accumulate before the list is processed.
All or none of the trapezoids from a given object are added to the list,
i.e., objects are not broken up at this point.  If the addition of the
trapezoids would cause the list to exceed the limit, then the list is
sent on for processing,  and a new list started.  If JoinMaxPolyQueue is
set to 0, there is no limit, and only a single list will be processed.

When a list is sent on for processing, the first operation is to break up
the list into groups.  Each group contains one or more trapezoids,
such that the trapezoids in each group are "connected", i.e., the
aggregate forms a single figure.  The variable JoinMaxPolyGroup specifies
a limit on the number of trapezoids in any single group.  If this limit
is reached, no additional trapexoids are added, instead they are placed
in a new group or possible some other existing group.  If this variable
is set to 0, then no limit is applied, and in this case all groups are
guaranteed to be disjoint.

For each group, one or more polygons are created, which exactly cover
the area of the trapezoids.  The variable JoinMaxPolyVerts specifies a
limit on the number of vertices which can appear in any single
strpezoid.  Thus, if the limit is reached, more than one polygon will
be generated.  If this variable is set to 0, then no limit is applied,
and a single polygon will be created for each group.

When JoinMaxPolyVerts is nonzero, the JoinBreakClean variable determines
now the partitioning is done.  If this variable is not set, then the
polygons are built up by adding trapezoids until the vertex limit is
reached, at which point a new polygon is started, and constructed using
the remaining trapezoids.  The process continues until all trapezoids
have been included in a polygon.  The resulting collection of trapezoids
may have complicated boundaries that interleave the polygons in a rather
random way.

If JoinBreakClean is used, the vertex limit is initially ignored, and
a single polygon is created from all of the trapezoids.  If this limit
is exceeded, the polygon is split in two pieces, either horizontally or
vertically.  If either piece still exceeds the limit, it is subdivided
in the same way, and so on until all polygons are within the limit.
In this case, the boundaries are Manhattan.  This processing is more
compute-intensive than the other approach.


Internally, there is no longer a limit of 8000 points on the size of a
polygon or path.

When writing a GDSII file from the database, if a layer does not have
a GDSII output mapping, but the name is a four-digit hex number,
the mapping is taken from the layer name to be "LLDD".  The left two
hext digits give the layer number, and the right two digits give the
datatype number.  Previously, no such mapping was implicit, and the
conversion would fail or the layer would be ignored.

When a polygon or wire is written to a disk file, if it has too many
vertices, it will be cut into pieces before the write.  For the different
formats, the limits are

native: no limit
CIF: no limit
EDIF: no limit
OCT: no limit
CGX: 8000 vertices
GDSII: depends on GdsLevel, max is 8000 veretices.

For CIF files, Xic can read/write arbitrarily large polygons and wires,
but other tools may have limits.

Doubled the allowable transform stack depth (to 60) to avoid error from
extremely deep hierarchy.

New command: !xdepth
This prints two numbers on the console.  The first number is the current
transform stack depth, which should always be 1.  The second number is
the transform stack maximum depth used since the last !xdepth call.

The pseudo-flag generators would use less transform stack entries
now when pushing into instances that are not arrays.

When writing CGX output, when StripForExport is active, no electrical
data is written.  Previously, electrical data were written.

todo: skip electrical stub in gdswrite, etc

Holding Shift while pressing the arrow keys now causes "fine" panning.
New keymap actions: PanLeftFine_action, etc
user probably must remake keymap

--
Xic will no longer, in most cases, add an empty electrical part to
created files.  Previously, physical-only cell files and archives
would include the electrical information for an empty cell, after the
physical information.  This is wasteful and unnecessary and is no
longer done.

// (string) FileInfo(filename, flags)
//
// This function returns a string containing information about the
// archive file passed in the first argument.  The second argument is
// an integer whose bits represent the types of information to return. 
// If this value is 0, all information will be returned, otherwise the
// returned information will contain fields associated with the set
// bits (more to be added in future):
//
//  0x1   Estimated memory use to read the file in skeleton mode.
//  0x2   A tabulation of the counts of record types in the file.
//
// If an error occurs, the returned string will contain an error
// message.  The file must be a GDSII, CGX, OASIS, or CIF file.  The
// operation has no effect on the database.

New '!' function: !fileinfo filename [flags]

Added support for OASIS files.

Removed support for EDIF-200 and OCT/bdnet


// (int) DumpPhysNetlist(filename, depth, modestring, names)
//
// This function dumps a netlist file extracted from the physical part
// of the database, much like the Dump Phys Netlist command in the
// Extract Menu.  The filename argument is a file name which will
// receive the output.  If null or empty, the file will be the base
// name of the current cell with ".physnet" appended.  The depth
// argument specifies the depth of the hierarchy to process.  If an
// integer, 0 represents the current cell only, 1 includes the first
// level subcells, etc.  A negative integer specifies to process the
// entire hierarchy.  This argument can also be a string beginning
// with the letter 'a', which will process all levels of the
// hierarchy.
//
// The final argument is a string, consisting of characters from the
// table below, which set the mode of the command.  These are
// analogous to the check boxes that appear with the Dump Phys Netlist
// command.  If a character does not appear in the string, that option
// is turned off.  If it appears in lower case, the option is turned
// on, and if it appears in upper case, the option will be set by the
// present value of the corresponding "!set" variable.  The characters
// can appear in any order.  If the string is empty or null, all
// options will be set by the corresponding variables.
//
// character  option            corresponding variable
// n          net               NoPnet
// d          devs              NoPnetDevs
// s          spice             NoPnetSpice
// b          list bottom-up    PnetBottomUp
// g          show geometry     PnetShowGeometry
// c          include wire cap  PnetIncludeWireCap
// a          list all cells    PnetListAll
// 
// The final argument, if not null or empty, contains a
// space-separated list of physical format names, each of which must
// match a name in the physical format library file.
//
// For each cell, a field in the output is generated for each format
// choice implicit in the modestring or given in the names.  In most
// cases, only one format is probably wanted.  The option text in the
// table above can also be included in the names (those containing
// white space should be double-quoted), which is equivalent to giving
// the corresponding lower-case letter in the modestring.  The
// modestring setting will have precedence if there is a conflict.  If
// both the modestring and the names string are empty or null, an
// effecitve mode string consisting of all of the upper-case option
// letters is used.
//
//  Example:  print a SPICE file
//    DumpPhysNetlist("myfile.cir", "a", "s", 0)
//    or
//    DumpPhysNetlist("myfile.cir", "a", 0, "spice")
//
// If the function succeeds, 1 is returned, otherwise 0 is returned.
//
// (int) DumpElecNetlist(filename, depth, modestring)
//
// This function dumps a netlist file extracted from the electrical
// part of the database, much like the Dump Elec Netlist command in
// the Extract Menu.  The filename argument is a file name which will
// receive the output.  If null or empty, the file will be the base
// name of the current cell with ".elecnet" appended.  The depth
// argument specifies the depth of the hierarchy to process.  If an
// integer, 0 represents the current cell only, 1 includes the first
// level subcells, etc.  A negative integer specifies to process the
// entire hierarchy.  This argument can also be a string beginning
// with the letter 'a', which will process all levels of the
// hierarchy.
//
// The final argument is a string, consisting of characters from the
// table below, which set the mode of the command.  These are
// analogous to the check boxes that appear with the Dump Elec Netlist
// command.  If a character does not appear in the string, that option
// is turned off.  If it appears in lower case, the option is turned
// on, and if it appears in upper case, the option will be set by the
// present value of the corresponding "!set" variable.  The characters
// can appear in any order.  If the string is empty or null, all
// options will be set by the corresponding variables.
//
// character  option            corresponding variable
// n          net               NoEnet
// s          spice             EnetSpice
// b          list bottom-up    EnetBottomUp
// 
// The final argument, if not null or empty, contains a
// space-separated list of electrical format names, each of which must
// match a name in the electrical format library file.
//
// For each cell, a field in the output is generated for each format
// choice implicit in the modestring or given in the names.  In most
// cases, only one format is probably wanted.  The option text in the
// table above can also be included in the names (those containing
// white space should be double-quoted), which is equivalent to giving
// the corresponding lower-case letter in the modestring.  The
// modestring setting will have precedence if there is a conflict.  If
// both the modestring and the names string are empty or null, an
// effecitve mode string consisting of all of the upper-case option
// letters is used.
//
// If the function succeeds, 1 is returned, otherwise 0 is returned.
//

New variables
PnetBottomUp
EnetBottomUp

// (int) GetNumberGroups()
//
// Return the number of conductor groups allocated by the extraction 
// process in the physical part of the current cell.  The group index
// passed to other functions should be less than this value.
//
// (string) GetGroupName(group)
// 
// Return a string containing a name for the group whose number is
// passed as the argument.  If the group has no name, a null string is
// returned.
//
// (real) GetGroupCapacitance(group)
//
// Return the capacitance assigned to the group whose index is passed
// as the argument.  If no capacitance has been assigned.  0 is
// returned.
//


This replaces prev ListGroupTerminals()
// (terminal_handle) ListgroupTerminals(group)
//
// Return a handle to a list of formal terminals associated with the 
// group number passed as an argument.  If an error occurs, 0 is
// returned.  If the group contains no formal terminals, the list will
// be empty.
//

Former ListGroupTerminals is ListgroupTerminalNames()

//
// (string) GetTerminalName(terminal_handle)
//
// Return a string containing a name for the group whose number is
// passed as the argument.  The name is the name of a formal terminal
// attached to the group, or the net name if no formal terminal.  If
// the group has no name, a null string is returned.
//

// (string) GetGroupNetName(group)
//
// Return a string containing the net name for the group whose number
// is passed as the argument.  If the group has no net name, a null
// string is returned.

//
// (int) GetTerminalType(terminal_handle)
//
// Return a type code index for the terminal referenced by the handle
// passed as an argument.
//
// This is not expected to be useful at present.
//
// (int) GetTerminalFlags(terminal_handle)
//
// Return the flags for the terminal referenced by the handle passed
// as an argument.
//
// This is not expected to be useful at present.
//
// (int) GetTerminalLocation(terminal_handle, array)
//
// Return the location for the terminal referenced by the handle 
// passed as an argument.  The second argument is an array of size two 
// or larger which will receive the x-y coordinate, in microns.  The
// function returns 1 on success, 0 otherwise.
//
// (instance_handle) GetTerminalInstance(terminal_handle)
//
// Return a handle to the electrical subcircuit or device instance 
// associated with the terminal referenced by the handle passed as an
// argument.  This will not exist for fromal terminals.
//
// The returned object is an *electrical* object.  This function is
// therefor probably not useful as is.
//
// (int) IsTerminalFormal(terminal_handle)
//
// Return 1 if the terminal is "formal", i.e., it is one of the
// external connections to the current cell.  Otherwise, return 0 if
// the terminal connects to internal objects only.  The return value   
// is -1 on error.
//
// (object_handle) GetTerminalObject(terminal_handle)
//
// Return a handle to a physical object that is associated with the 
// terminal referenced by the handle passed as an argument.  Terminals
// are associated with underlying conducting objects as part of the
// connectivity algorithm.  Not all terminals have an associated   
// object, in which case they are "virtual".
//
// (int) GetTerminalVgroup(terminal_handle)
//
// Return the virtual group number for the terminal referenced by the
// handle passed as an argument.  Terminals that are not associated   
// with an object are "virtual" and represent pass-through between   
// other cells or subcells.  The returned value is -1 on error or if
// the terminal is not virtual.
//
// (string) GetTerminalLayer(terminal_handle)
//
// Return a string containing the layer name for the terminal 
// referenced by the handle passed as an argument.  Non-virtual
// terminals are associated with a conducting layer.
//

// (string) GetPdevContactDevName(dev_contact_handle)
//
// This function returns the name of the device containing the contact
// referenced by the argument.  A null string is returned on error.


// (int) GetPdevContactDevIndex(dev_contact_handle)
// 
// This returns the index number of the device to which the contact,
// referenced by the passed handle, is associated.  Each device of a
// given type has an index number assigned, which is unique in the
// containing cell.  On error, -1 is returned.  A valid index is 0 or
// larger.
//

// (string) GetPscContactSubcName(subc_contact_handle)
//
// This function returns a string containing the name of the
// subcircuit associatd with the contact referenced by the argument.
// A null string is returned on error.
//

// (int) GetPscContactSubcIndex(subc_contact_handle)
//
// This function returns the index of the subcircuit associatd with
// the contact referenced by the argument.  Each subcircuit of a given
// kind has an index number that is unique in the containing cell.  On
// error, -1 is returned.  Valid index values are 0 and larger. 
//

// (string) GetPscContactName(subc_contact_handle)
//
// This function returns a name string, if available, from the
// subcircuit contact referenced by the argument.  If the subcircuit
// does not provide a name, the returned string will be a number
// giving the subcircuit group contacted.  A null string is returned
// on error.

// (int) IsPscContactIgnorable(subc_contact_handle)
//
// If the subcircuit associated with the contact referenced from the
// argument is flattened or ignored, return 1.  Otherwise 0 is
// returned.  When 1 is returned, the contact can usually be skipped
// in listings.
//

todo: saw problem with bounding box change.

gone:
FromEDIF()
ToEDIF()
FromOCT
ToOCT

// (int) FromOASIS(oas_file, destination_dir)
//
// The FromOASIS function will convert an OASIS file oas_file to Xic
// symbol files.  The symbols are not read into the database.  The
// second argument is the directory where the Xic files will be
// created.  If this argument is a null or empty string or zero, the   
// Xic files will be created in the current directory.  The scale
// factor used can be set with the SetConvertScale() function.
//
// (int) ToOASIS(oas_name)
//
// This function will write the current cell hierarchy to an OASIS  
// format file on disk.  The argument is the name of the OASIS file to
// create.  If the oas_name is NULL or the empty string, the name used
// will be the top level symbol name suffixed with .oas.  The file is  
// written according to the settings of the controls in the Convert -
// Exports panel, and/or the related variables.  The scale factor used
// can be set with the SetConvertScale() function.
//

// (int) GroupObjects(object_handle, array)
// 
// This function acts on the first object in the list and all other
// objects on the same layer found in the list.  The objects are
// sorted into groups, so that each group forms a single figure, i.e.,
// no two members of the same group are disjoint.  The groups are then
// joined into polygons, and a handle to each group is returned in the
// array.  The array will be resized if necessary.  The returned value
// is the number if groups, corresponding to the used entries in the
// array.  The H() function should be used on the array elements to
// convert the values to an object handle data type, similar to the
// treatment of the array returned from the HandleArray() function. 
// The CloseArray() function can be used to close the handles.  The
// created objects are copies, so are not added to the database.
// 
// This function uses the JoinMax...  variables in processing.  There
// is no effect on objects in the list whose handle is passed as the
// first argument.  The value 0 is returned on error or if the list is
// empty.
//

// (int) CheckObjectsConnected(object_handle)
// 
// This function returns 1 unless the list contains objects that are
// mutually disjoint, meaning that there exist two objects and one can
// not draw a curve from the interior of one to the other without
// crossing empty area.  If disjoint objects are found, 0 is returned.
//

// (int) CheckForHoles(object_handle, all)
// 
// This function returns 1 if the object, or collection of objects,
// has "holes", i.e., uncovered areas completely surrounded by
// geometry.  The first argument is a handle to a list of objects.  If
// the second argument is nonzero, the geompetry represented by all
// objects in the list is checked.  If zero, only the first object
// (which might be a complex polygon containing holes) is checked.  If
// no holes are found, 0 is returned.
// 
// When all is true, only objects on the same layer as the first 
// object in the list are considered.
//

batch mode tooas - help
XICP_OCT
XICP_INST


The KeepBadCif and KeepBadGds variables are gone.

New variable: KeepBadArchive (boolean)

When generating an archive file and an error occurs, the archive file
will normally be deleted.  However, if this variable is set, the
output file will be given a ".BAD" extension and retained.  This file
should be considered corrupt, but may be useful for diagnostics.

OasCompress works in conversion, OasNameTab does not

Compress and NameTab with random access XXX

The zlib interface (.gz file support) was rewritten.  The new interface
provides 64-bit support without the need for a special hacked version
of the library.

Hash table was overflowing, causing (at least) performance problems.

Updated freebsd to 4.9
rebuilt gtk12, hacked in makefile to add --disable-NLS to configure, to
avoide the gettext crap.

Properties Editor changes:
  If the Name property is set, the property text is highlighted.
  Since this property is always in the listing, it would otherwise be
  impossible to tell if the values has been set, if the value is in
  the same form as the internally assigned name.

  The dotted marker boxes for the Properties Editor and Property Info
  Windoe no longer destroy one another.

XIC_SYSTEM_MALLOC is now XT_SYSTEM_MALLOC

(Windows Only)
  The Files List window was (incorrectly) showing the full path for
  each file.
  
Changed has functions, big improvement!
-----------------------------------------------------------------

todo: make flashsides a !set variable

Tables should work now, uncompressed files only.
- <name> records that are not in tables must appear ahead of the
  reference.
- if not strict and using tables and an internal reference count,
  the table must be ahead of any other <name> records of that type.
"strict mode guarantees that all references to the corresponding class
of objects (names, stringss, or colls) are made exclusively by
reference-number"
- Xic does not enforce this.

The OASIS code for cell arrays was incorrect.

When reading OASIS, if a repetition is found in a <geometry> record, the
object will be replicated as per the repetition record.  This is not
reversible, i.e., when writing a file, the replicated objects are kept
as separate objects.

New variable: OasWriteRep (boolean)
   If setm when writing OASIS output from the database (not conversions)
   an attempt is made to combine arrays of identical objects into
   repetition records.

BAD bug:  Writing native top-level cell with empty electrical part, the
SPICE comment was added (incorrectly), causing an error when the cell
is read.
  This release is immune to this error, but users should remove the
  last line of the file (starts with '*') with a text editor.

The line counting in cif/native parse was wrong, leading to confusing
error messages.
-------------------

todo: add top level help topic "reporting bugs"

oasis:  fixed bugs in handling properties of repeated objects
        parser now handles xgeometry and xelement records, but ignores
            data
        format for instance arrays was wrong.
        When reading, all repetitions are handled.  If the repetition
        can be converted to an array, it is done, otherwise individual
        instances are placed.

todo: test new array code

If Metric was selected in Print panel, changing the output format would
screw up width/height due to internal conversion error.

CBLOCK handled in read_table

Bug: the Tiny Boxes selection in the Attributes Menu was not working
correctly, it was effectively always on.

The Tiny Boxes button in the Attributes Menu works slightly differently
now.  When set, cells that are smaller than a minimum size are shown as
a bounding box only.  When not set, these cells are not displayed at all.

New Variable:  CellThreshold (integer >= 0)
This sets the size threshold in pixels for subcells to be shown in the
display.  If not set, the value is effectively 4.  Subcells that are
smaller than this size in the display are either shown as a bounding box,
or not shown at all, depending on the setting of the Tiny Boxes button
in the Attributes Menu.  If set to 0, all detail is drawn, which can
significantly increase rendering time.  This applies to hard copy output
as well as the on-screen rendering.

In releases prior to 2.5.38, a CIF file with negative cell index numbers
would crash the program.  These are accepted in present releases.

The bounding box of the current cell was not being maintained correctly
after undo.
------------------------------------

DumpElecNetlist bug:  The top-level cell name was erroneously freed in the
database when printing spice plus some other format.

DumpElecNetlist bug:  Only the top-level cell would get a spice listing
when listing spice plus some other format.

Added the following two functions, and added example formatting to
xic_format_lib

// (int) GetNumNodes()
//
// Return the size of the internal node map.  The internal node 
// numbers range from 0 up to but not including this value.  The
// return value is 0 on error or if the cell is empty.
//

ListNodeTerms -> ListNodeTerminalNames

// (terminal_handle) ListNodeTerminals(node)
// 
// Return a handle to the list of terminals connected to the internal
// node number supplied as the argument.
//

ExtractRLC problems under Windows:
 - seg fault when trying to dump a file.
 - fork didn't work

when reading gds.gz files, sometimes would get a spurrious warning:
"File contains junk after physical data."

Giving "!set ?" now pops up a help window rather than generating its
own listing window.

The "set!" listing has a more legible font for the value string, and
will not lose the '<' character due to HTML format.
 
There is a new "S" button to the left of the layer menu, which controls
layer-specific mode.  The box icon at the right of the layer table can
also be used to set layer-specific mode, and the Layer Specific button
in the Selection Control Panel from the layer button in the side menu
is yeat another way to set layer-specific mode.

The S button, along with the up/down arrow buttons that control layer table
scrolling, respond to keyboard accelerators, and have "tooltips".  The
keywords are
S button : lspec
up arros : ltup
down arros: ltdn

Clicking with button 2/3 on either of the up/dow buttons to the right of
the layer menu previously had the same effect as clicking on the box icon
at the right of the layer table.  This is no longer true.

Fixed rounding problem for magnified cells, bounding box could have
one-unit error which could break connectivity in extraction.
------

The OASIS magic word header had \r and \n reversed.  The correct header
is now written, and temporarily the incorrect header will be accepted
in input files.  THIS BACKWARD COMPATIBILITY KLUGE WILL GO AWAY!
YOU MUST WRITE NEW OASIS FILES TO ENSURE THAT THEY CAN BE READ INTO
FUTURE XIC RELEASES (AND OTHER APPLICATIONS).
-------------------------------

When a string is set-expanded, i.e., forms like $(varname) are replaced
with the value of varname, if any of the substitutions are of the form
"(...)", then the parentheses and leading/trailing white space are stripped
before substitution, and the entire substituted string is enclosed in
parentheses if it is not already.  This is for convenience when adding a
directory to a path variable, and the path is enclosed in parentheses,
using forms like "!set path dir $(path)".  If path is "( /dir1 /dir2 )",
then the form above would be "( dir /dir1 /dir2 )", which is correct.
Previously, this would give "dir ( /dir1 /dir2 )", which is garbage.
The parentheses are optional anyway, but if they are used, they have to
be used correctly.

On startup, the script path would be sourced twice: once when reading
the technology file if SourcePath is given, and once later.  This
is harmless but redundant.  Xic no longer sources the script path while
reading the technology file.

In scripts, function/endfunc blocks no longer have to appear ahead of
other statements, they can now appear between statements anywhere in
the file.  Since these are read during the parse, which occurs before
execution, they can appear after calls to the function.

It is now legal to have ordinary statements in the library file.  These
will be executed once only, when the library file is read.  This can be
useful for library initialization.

If the right Ctrl button is held, after a while get a ffc3 down/up key press
for some reason.  ffc3 = F6 -> Cells Listing.  Doesn't seem to happen with
left button.  This appears to come from the window manager, or perhaps the
keyboard?  Not a Xic bug.

In the "mut" command, i.e., selecting the "mut" device in the device menu
to define mutual inductors, the outline boxes of the selected inductors
were not being erased when the selection changes.

Fixed subtle bug: changing label text that increases the size of the label
would at times not allow selection of the label if the label was clicked on
outside of the original bounding box.  The R-tree database was not being
updated.

label button, long text incorrectly active when editing a mutual inductor
coefficient label

No longer possible to assign conflicting mutual inductor name when editing
coefficient lqbel

Changes to WRspice interface:
 1) more informative error message if remote spice server operation fails
 2) after connection failure, the user can try again (after fixing things).
    Previously, the interface was locked out after a serious error, so
    Xic would have to be restarted.

In help mode, when a device from the device library in electrical mode is
selected, the help keyword accessed is now "dev:device_name".  Previously,
it was just "device_name", where "device"name" is the name of the device
from the device library file.  These would access the help from WRspice
for that device type, if available.  Now, separate help entries are provided.

If you have added devicees to the library, and added help topics, the
keyword should be changed by adding a "dev:" prefix.

// (unsigned int) ShiftBits(var, val)
//
// This function will shift the binary representation of the unsigned
// integer var by val.  If val is positive, the bits are shifted to
// the right, or if negative the bits are shifted to the left.
//
// All numerical data are stored internally in double-precision
// floating point representation.  This function merely converts the
// internal values to integer data, and applies the integer shift
// operators.
//
// The function returns the shifted value.
//
// (unsigned int) AndBits(val1, val2)
//
// This runction returns the bitwise AND of the two arguments, which
// are taken as unsigned integers.
//
// (unsigned int) OrBits(val1, val2)
//
// This runction returns the bitwise OR of the two arguments, which
// are taken as unsigned integers.
//
// (unsigned int) XorBits(val1, val2)
//
// This runction returns the bitwise exclusive-OR of the two
// arguments, which are taken as unsigned integers.
//
// (unsigned int) NotBits(val)
//
// This runction returns the bitwise NOT of the argument, which is
// taken as an unsigned integer.
//

In server/batch mode, Xic no longer tries to bring up an xterm during
the program crash termination sequence.

The internal update feature for the device library file was broken.

New feature: a fancy pop-up to facilitate saving devices.

Devices in the device library can be edited, while in electrical mode,
by simply giving the device name to the Edit command or equivalent.
When saving, with either Save or Save As, the Library Device Parameters
pop-up will appear.  This allows various defaults and parameters to be
specified for the device, and allows to be saved in a device library file
or in a native cell file.

This panel will appear when a device library is saved while in either
electrical or physical mode.

The panel will also appear in the Save As command if the name of the
cell or file to save has been specified as the name of the device library file
(default "device.lib").  In this case, the current cell is internally marked
as a library device, and the panel appears.  This is one way to add new
devices to the library, the other way is to edit an existing device and change
the name.  Of course, the cell should contain geometry appropriate for
the device library, i.e., no physical data, no subcells, etc.

The Device Name entry area contains the device (cell) name.  This is
arbitrary and can be changed, however a string must appear.  This is the
name by which the device is known to Xic, and the name that will appear
in the device selection menu.

The SPICE Prefix is one or more characters that will be prepended to the
device instance lines when a SPICE file is created.  An entry in this
field is mandatory.  The pop-up will accept anything, however
the first character should
match the requirements of SPICE, which expects a certain key letter
for each device (case independent).  Additional characters can appear,
and should be alphanumeric.  An exception is the vcc terminal, which is
not instantiated in SPICE, and must have a prefix starting with the
character '@' for internal use by Xic.

If the current cell is not a SPICE device but rather a macro, which will
instantiate a subcircuit (such as the "opamp" example in the supplied
device.lib file) the SPICE Prefix must start with 'x" (case insensitive).

The Default Model and Default Value fields are optional for devices.
Either one, but not both can be given, providing a default model name or
default value to the device.  If both are given, the value will be
ignored.

If the device is a macro, i.e., the SPICE prefix starts with 'x' or 'X',
then the Default Model field is mandatory and contains the name of the
subcircuit that will be instantiated.  This name should be found in a
.subckt line in the model library.

The Default Parameters field provides a default parameter set for the
device or macro.  The string can be any text relevant to the device,
and will appear as a param property when the device is instantiated.

The Hot Spot button, and associated menu and entry area, allows a branch
property to be applied to the device.  The branch property allows
an internal value or function to be associated with a location in the
schematic symbol, which can be clicked on in the drawing to obtain
the values, after a simulation.  For most devices, this will yield
the current through the device.

The Hot Spot button will be active when the device contains a
branch property.  Pressing the button will create the property.

The branch property contains the hot spot coordinates, which are marked
with a white cross.  While the Hot Spot button is active, clicking in the
drawing will move the hot spot, and the white cross, to the button down
location.  The used should click to locate the hot spot where desired
in the drawing.  In most of the devices in the supplied device library
file, the hot spot is located on the '+' symbol that appears near the
top device terminal.

The menu contains an orientation for the hot spot data.  This is needed
when the returned value is a current, and indicates the actual direction
of positive current flow, relative to the device symbol.  Typically, the
two device terminals  are oriented vertically, with the '+' associated with
the top terminal, which would imply that the orientation choice should be
"Down".  If a scalar value is returned, so that there is no orientation,
the correct choice would be "none".

The text entry provides an expression for the value to be returned.  The
description of the branch property describes this.

The No Physical Implementation box should be checked if the device will
never have a direct correspondence to geometry in the physical layout.
This is true for example for voltage and current sources.  Devices with
this property set will not be considered in LVS testing and will never
appear in netlists extracted from physical data.  The device terminals
will never appear in physical layouts.

Once all fields have been filled in, the device can be saved.  The Save in
Library button will perform the following steps:

1)  The device library file will be copied to the current directory, if it
doesn't already exist in the current directory.  If is does exist in that
directory, the file will be copied and given a ".bak" extension.

2) The present device is written into the device library file.  If the
name already appears in the file, the device will be updated.  If the name
does not appear, the device will be appended to the file.

It is critical that the first line of a device description in the device
library be a commend naming the device, in the form
    (Symbol: devname);
When updating the library, the process looks for lines of this form.
Xic will always add this line, but it may not be present if the file
has been hand edited.

3)  The modified device library is read back into Xic, and Xic is updated
to use the new library.

4)  The pop-up is retired, and a message indicates completion.

If, instead, it is desirable to avoid touching the device library but the user
wishes to save the device, the Save as Native Cell button can be used
to save the device as a symbol file in the current directory.  When this
is done, a message appears warning that it is not a good idea to have such
files lying around, as they can potentially conflict with the device library.
The file should be moved somewhere safe, i.e., out of the search path.
They can be copied into the device library file with a text editor to manually
update the device library file.


From the text editor, if a delete window signal is sent from the window
manager, as happens when the user pressed the 'X' button in the window
title bar, the editor now acts the same as if Quit in the File menu
was pressed.  That is, it now allows the user to save work, unstead of
exiting unconditionally.

The script debugger now handles backslash continued lines.
Quitting with the window manager button is now the same as the Quit button.

MSW file selector, file listing column widths will now expand to show
long file names.

Fixed subtle indentation problem in HTML viewer.

Fixed numerical oddity in inductance extractor that would give slightly
different values for identical bu mirror image structures.

Fixed incorrect LVS error due to electrical net connected to only
nophys devices.
-------------

todo:  if nophys, use alt drawing color ?

httpget: fixed bug that would not read relocated image

mozy: fixed bug that affected table placement with margins set

Extract RLC changes:
   add stuff

The display of the variables in the pop-up is now updated when
the variables are changed with the !set command.
fixed bug, these weren't initialized corredtly.

There is a new entry field labelled "Dataset Name".  An arbitrary
one-word name for the dataset should be entered here.  This name will
be used to construct the name of the output files.

When dumping data to a file, the name of the file is the dataset name
suffixed with an extension (though the user may change this).  If no
dataset name has been entered, the default is "unnamed".  The extensions
are:

  FastHenry input  .inp
  FastCap input    .lst
  Saved dataset    .sav
  FastHenry output .fh_out
  FastHenry log    .fh_log
  FastCap output   .fc_out
  FastCap log      .fc_log

new variables:
   FhUnits
   This specifies the length units used in created Fasthenry input
   files.  If can be set to one of km, m, cm, mm, um, in, mils,
   and will recognize many full-word equivalents.  If not set, the
   default is "um" (microns).
   Note: previous releases used meters.
   Note: Xic assumes that:
      1. the values of Sigma/Rho given in the techmology file
          are always MKS units.
      2. the values for Thickness and Lambda given in the technology
        file are always in microns.

    FhPath
      This can be set to the directory containing the fasthenry executable,
      if it is not in the standard location.  The standard location is
      the same directory searched for wrspice, which usually defaults to
      /usr/local/bin (see the XT_PREFIX and SPICE_EXEC_DIR environment
      variables, and SpiceExecDir !set variable).  The executable name is
      always "fasthenry".

    FcPath
      This can be set to the directory containing the fastcap executable,
      if it is not in the standard location.  The standard location is
      the same directory searched for wrspice, which usually defaults to
      /usr/local/bin (see the XT_PREFIX and SPICE_EXEC_DIR environment
      variables, and SpiceExecDir !set variable).  The executable name is
      always "fastcap".

    FhArga
      This variable can be set to a string, which will be included in the
      argument list to fasthenry when it is run from Xic.

    FcErgs
      This variable can be set to a string, which will be included in the
      argument list to fastcap when it is run from Xic.

Terminal layer, object property to enforce layer
  1 layername

Delete key in partition editor now resets partition, no longer deletes object.

The Lambda (penetration depth) parameter was not being written to the
new technology file in the Update Tech command.

todo: how to prevent operating programs after time limit by changing system
  time.

new function to take care of spin button/button 2 problem with button 2
exit, to centralize handling.  DblClickSpinBtnContainer()

FcPlaneBloat ->FxPlaneBloat

Fixed bug:  Writing archive files, archive failed to include electrical
parts of cells that were not rooted in top cell.

TODO: fill pattern editor, fill doesn't change with layer change.

Centralized colinear vertices test function (used in polygon.cc for inline
vertex detection and match_Y in geometry.cc.  The matching conditions for
zoid merging was tightened up, so split/join/split of a round object
would split the same both times.

Previously, split/join would create a slightly different figure due to
zoid merging, which caused trouble for circular jj's being detected as
vias.

The following functions now return scalar 0 instead of an empty handle
if there is nothing found to list.
// (stringlist_handle) ListCellsInMem()
// (stringlist_handle) ListTopCellsInMem()
// (stringlist_handle) ListModCellsInMem()
// (stringlist_handle) ListTopFilesInMem()

todo: remove EDIF from mswxic

added cv_in::mark_top(), where filename is added to symbol.  This is now
always added, ir there is a unique top symbol.  If the cell is altered
on reading, such as by layer filtering, skeleton mode, or scale change,
the SYM_ALTERED flag is set.  This prevents the use of the filename as
the default when saving the cell.

In scripts, it was possible static and global variables set to strings 
would have bad data, as the string could be garbage-collected while
the static/global is still in scope.  This should no longer happen.

Error in dicumentation:
A function definition must appear ahead of the first call

!debug 0x10 : prints estif layer map

-----

Reset with no data caused seg fault.

Dataset name problem.

Need at least 2 conductors + one via.

Objects being saved would have rectangles filtered to MinRectSize.

certain shhapes would foul up manhattanization.

!manh command

// XXX layer specific, also BloatQueue()
// (int) Manhattanize(dimen)
//
// Each selected non-Manhattan polygon or wire is converted to a
// Manhattan representation, similar to the !manh command.  The
// argument is a size in microns representing the smallest dimension
// of the boxes used in the approximation.  The returned value is 0 on
// success, or 1 if there was a runtime error.  This function will
// return 1 if not called in physical mode.
//

TODO:  errors from poly creation in recallSaved create cell.

called fclose twice in fc_dump.

Fixed up some computational geometry numerical problems that showed up
from the fc interface.

Cleaned up signal handling.

!polynum command changed, the vertex numbers now stay displayed when
the window view changes.

new !fxcell command:  !fxcell [cellname]
  This command will create a cell from the contents of the FastCap/FastHenry
  interface, and make it the current cell.  This is similar to the
  behavior after pressing RecallSaved, and as in that case the "real"
  Manhattanized geometry is shown.  If an argument is given, it will
  be used as the cell name, otherwise the name is "$$dataset_name$$",
  where dataset_name is that name of the data set, or "unnamed" if none
  was given.  Any existing cell in memory with the same name will be
  overwritten.

new !manh command:  !manh min_box_size
  This command will applies to selected polygons, on the current layer only
  if layer-specific mode is in effect, and will convert each polygons to a
  Manhattan approximation.  The argument is a size, in microns, of the
  minimum box width/height used to approximate nom-Manhattan parts of the
  polygon.

new !polymanh command:  !polymanh [arg]
  Without an argument, this command will deselect all polygons, and then
  select only those that are Manhattan, on the current layer only if in
  layer-specific mode.  If there is an argument, which can be any word,
  the non-Manhattan polygons will be selected instead.
  

new math func int()

returns the truncated integer value of the argument.

WriteLine and WriteChar:
//
// This function has the unusual property that it will accept the
// arguments in reverse order.
//

// (string) ToFormat(fmtstring, arg_list)
//
// This function returns a string, formatted in the manner of the C
// printf function.  The first argument is a format string, as would
// be given to printf.  Additional arguments (there can be zero or
// more) are the variables that correspond to the format
// specification.  The type and position of the arguments must match
// the format specification, which means that the variables passed
// must resolve to a string or to a numeric scalar.  All of the
// formatting options described in the Unix manual page for printf are
// available, with the following exceptions:
//
//    1) '*' can not be preceded by an integer, i.e., no random argument
//        access for field width.
//    2) "%p" will always print zero.
//
// The function fails if the first argument is not a string or is
// null.
//
---------------------------

Fixed bug: FastCap generation would fault if no via layer.

FastCap coordinates are actual coordinates and not relative to
bounding box.


The Layer() function was not accepting the "split" keyword.


// (string) NewCellName()
//
// This function returns a string which is a valid cell name that does
// not conflict with any cell in the current symbol table.  The cell
// is not actually created.  This can be used with the Edit function
// to open a new cell for editing, similar to the New button in the
// File Menu.  This function never fails.
//


// ClearCell(undoable, layer_list)
//
// This function will clear the content of the present mode
// (electrical or physical) part of the current cell.  If the first
// argument is nonzero, the deletions will be added to the internal
// undo list, otherwise not.  The latter is more efficient, though
// this makes the deletions irreversible.  The second argument, if
// null or empty, indicates that all objects on all layers will be
// deleted.  Otherwise this can be set to a string containing a
// space-separated list of layer names, following an optional special
// character '!' or '^' which must be the first character in the
// string if used.  If the special character does not appear, the
// deletions apply only to the layers listed.  If the special
// character appears, the deletions apply only to the layers not
// listed.  Recall that the internal name for the layer that contains
// subcels ls "$$", thus for example using "! $$" would delete all
// geometry but retain the subcells.
//
// The return value is the number of objects deleted.
//

---------------------------

XicII, Windows programs
The programs that do not use the license server now look for the
LICENSE file only in the startup (.../xictools/progname/startup) and
license (.../xictools/license) directories.  Previously, the entire
library path was searched, plus the current directory.  This would
cause problems if a file named LICENSE was in the current directory,
for example, and was not a valid license file for the current machine.

Updated to gcc-3.3.3 on msw,
Switched to inno-4.2.1 installation program.
    old startup files are not moved to old-config
    can't install if old version (from old installer) is prsent.
    can't install if program is running.

new server command: dieonerror

Afetr this command is sent, a communications error with the client, such as
the client crashing, will cause the daemon to exit.  If normal exit with
the close command, this flag is reset.

mswltab.cc: set win_width, win_height

made layer table pixmap backup a little more efficient,

fixed expose handler bug in main window.

added undo nodes symbln and symbly to prevent strange behavior
when switching to/from symbolic mode in undo/redo

Minor enhancements to make the nodmp property and pop-up work more cleanly,
particularly with symbolic mode.

  1)  An undo node is applied when node mapping is applied or un-applied
      to the current cell, so that the operation can be clearly
      undone/redone.  Previous, the mapping would be undone/redone invisibly
      along with other changes, or not changed it all if no other changes.

  2)  The panel stipp pops up when the side menu button is asserted on,
      and will remain visible until dismissed.  Whether mapping is actually
      applied is indicated by the state of the side menu button, as before.

  3)  The node mapping button is no longer made insensitive when symbolic
      mode is established.  Instead, only the Point button in the panel
      is made insensitive.  The mapping can by turned on/off or edited
      in symbolic mode, unlike before.
   

Clicking with Shift-button1 or Ctrl-button1 in the layer menu acts the
same as button2, i.e., changes layer visibility.  This will be helpful
for users with a 2-button pointing device, which does not have button 2.

----------------------

Holding Shift or Ctrl while pressing button 3 in a drawing window is
now the same as pressing button 2.

Fill pattern editor, new bindings
           x       s        c
b1  rect s t       s        u
b2  rect b t       s        u
b3  line   t       s        u
s|c before b1 => b2

added explicit reinsert function in cddb to avoid generator purge
in db_remove.  This caused crash at Hypres.

new server keyword: noreset
  If given, the server context will not be reset when a close is
  given.

new server keyword: clear
  Clears the database.  Removes layers not read from texh file.
--------------------------

TODO: add !togrid function (Haus). done

Server mode doesnt delete log dir (NFS problem?) ok

Added an internal flag that prevents calling memory management
functions recursively.  This could happen in the signal handlers
if timing was unfortunate, causing a program crash.

server mode, dumpmsg was only working in debug mode (when XTNETDEBUG
is set in the environment), in which case output goes to the screen.
Now, dumpmsg works in any case, output goes to the log file in normal
mode.

An empty line in the internal spice listing could cause faults
b060904-1

In Properties Editor, NO_PHYS properties would cause trouble
if one tries to edit them.
b060904-5

Server mode, crash returning a null string
b060904-3

New '!' command: !togrid
  This will move all vertices in selected boxes, polygons, and wires to the
  nearest snap point, using the grid/snap defined for the main window.
  There is ne effect on subcells or labels.  If the new object can not be
  created due to it having zero area, the old object is untouched.
  Duplicate vertices are removed from the new objects.  Objects with
  vertices that are off-grid can change size and position due to this
  function.

In server mode, the empty log directory would remain after shutdown if
on an NFS share.
-----------------

061504-2
If there is a parse error in a script function definition, that function
would remain in the function table but contain bad pointers.  The function
is now removed from the table and destroyed.

Problems with oasis cell repetitions fixed, oasread.cc line 6980

The functionality associated with the OasWriteRep variable, used when
writing OASIS output from cell hierarchies in memory, has been greatly
enhanced.

variable OasWriteRep: [word] [d] [r] [m=N] [a=N]

If OasWriteRep is not set, subcell and object records are written as
encountered when tarversing the cell structure.  If set, objects and subcells
may be cached, and similar objects and subcells are identified and written
using replication records.  This can greatly reduce file size.

When using replications, the following procdure is used, where "objects"
can apply to subcells as well as geometrical objects.

1) Instead of directly converting each object, the object is saved in a
cache.
2) When the traversal is complete, the cache is processed, and objects
that are identical are identified.
3) For each group of identical objects, those that for a spatially linear,
periodic "run" are extracted into a new run list.
4) For each list of runs, the runs that are spatailly periodic are extracted
into a new array list.
5) Each array is written using a 2-dimensional replication.
6) Each remaining run is written using a 1-dimensional replication.
7) The remaining objects, i.e., those not used in an array or run, are
written using a random replication.

The details of this process, and whether or not it is applied, are controlled
by the OasWriteRep variable.  This variable can be set to a string containing
several tokens, or set as a booloean (i.e., set to nothing).  The tokens
can appear in any order.

[word]  This is a token that is not recognized as one of the others.  It
consists of letters that control the type of object that the replication
process is applied to.  If the letter is present, the corresponding object
type will be processed, otherwise the replication algorithm will not be
applied to that type of object.  The letters are:

   c   subcells
   b   boxes
   p   polygons
   w   wires
   l   labels

For example, "cp" would indicate use of replications for subcells and
polygons only.  If no token of this type is found, then all object types
will be processed.

The remaining tokens are identified by the first letter only, and the
remainder of the token (up to '=' in some cases) is ignored.

   d  (debug)  Some debugging info is printed on the console when processing.

   r  (random) No attempt is made to find runs or arrays, and all similar
               objects are written using random placement replications
               (OASIS REPLICATION type 9) only.
   m=N (minrun=N)
               This sets the minimum number of objects in a run.  The default
               value is three.  There can be no space around the '=', and
               N must be an integer.  This is ignored if r is given.
   a=N (arraymin=N)
               This sets the minimum number of runs in an array.  The default
               value is two.   There can be no space around the '=', and
               N must be an integer.  This is ignored if r is given.

If OasWriteRep is set to an empty string, all objects will be preocesed
for replication, using the default run and array minimums.

Fix som problems reading CTRAPEZOID records.

CTRAPEZOID types 6,7 w < h treated as fatal, spec says w < 2*h but this
seems too restrictive?
CTRAPEZOID types 14,15 w > h treated as fatal, spec says 2*w > h but this
seems too restrictive?

In the script debugger:
  If the script file contains a function definition ahead of all other
  statements, in execute mode the initial line indicator is now on
  the first executable main statement rather than on the function line.

  It is no longer to out (meaningless) breakpoints on lines in
function definitions.  It is not possible to single step in functions.

Fixed situation where use of debugger or abnormal script termination
could crash the program on exit.

Fixed bug that could crash the program due to recursion in memory error
reporting.

new barcode.scr

There can be multiple skeleton mode hierarchies in memory if they all
came from the same file.  If one of the hierarchies was cleared by
(top-level cell) name, the skeleton context was cleared.  This is no
longer true if another skeleton hierarchy remains in memory.

When the SkeletonMode variable was unset, all cells in memory would
revert to normal cells, but with possibly incomplete geometry. The
skeleton mode context was left, however.  So, is SkeletonMode was
set again, a read would fail with "skeleton hierarchy already in memory".
The context is now cleared when the variable is unset.  Note that this
is all very dangerous, since writing a hierarchy with incomplete
geometry over the original archive file could cause loss of data.
It is definitely best to clear the hierarchy from memory before unsetting
the variable.

New '!' commands

!sqdump cellpath

This will save the current contents of the selection list to a native
file provided in cellpath.  Unlike the Create Symbol command in the
Edit Menu, no cell is created in memory.

!cont cellpath

The cellpath is a path to a native symbol file, or the name of a cell
in memory.  The cell will be read if necessary, and the contents of the
cell will be ghost-drawn and "attached" to the mouse pointer.  The
objects will be placed in the current drawing where the user clicks.
This is equivalent to placing the cell and flattening.
----------------

new '!' command: sw

   This command must be initiated when a subwindow (from the Viewport
   command) has the keyboard focus.  It will swap the cells, modes,
   and views between the subwindow and the main window, thus making the
   cell in the subwindow the current cell.

new '!' command: svq [n]

  This will save the current selections into a "register" which can
  be recalled later.  There are ten registers corresponding to given
  digits 0-9, or if no number is given 0 is understood.

  The "registers" are actually just dummy cells in memory, which will
  appear in listings as "$$$$REG0" through "$$$$REG9".  These should not
  be edited directly or instantiated.

new '!' command" rcq [n]

  This will recall the contents of the "register" whose index 0-9 is
  given, "attaching" the objects to the mouse pointer where they can be
  placed by clicking in an active drawing window.  The "register" must
  have been defined previously with the !svq" command.  If no number is
  given, 0 is understood.
--------------

HTML viewer, fixed bug in form handling that caused fault in option menu
setup.

Rearranged struct entries for 64-bit alignment.
Changed CDc::cNumX and Y to ints from shorts.
Changes CDp_branch::r1 and 2 to shorts from ints.

new command: !oom
  This will allocate memory from the system until memory is exhausted,
  and Xic will exit.  This is for testing out-of-memory handling.

More fixes to recursive memory error handler and other things.  The
handler could get into infinite loop.

coresize function wasn't using memory allocation probe.

The Cells Listing pop-up is now a drag source (CHECK MSW).
The Tree pop-up is now a drag source (CHECK MSW).

If Xic dies from out of memory, the current pool size is printed in the
error message.

IsCellInMem, strip_path now called for arg.

fixed gdbexec to use Global.MailAddr

OS X port

Apple's linker does not allow use of internal memory manager.

in drc user tests, the _CurTest variable was not being set, always 0.

The default length for array printing with the Print function is now
set a program startup.  Previously, this was set the first time a script
was run, but not a user-drc script, so that if a user-drc script printed
an array and was called before another script was executed, "..." would
be printed instead of the values.

// (real) GetObjectArea(object_handle)
//
// Return the area in square microns of the object pointed to by the
// handle.  Zero is returned for a defunct handle or upon error.
//

// (real) GetObjectPerim(object_handle)
//
// Return the perimeter in microns of the object pointed to by the
// handle.  Zero is returned for a defunct handle or upon error.
//

// (string) Strchr(string, char)
// 
// The second argument is an integer representing a character.  The
// return value is a pointer into string offset to point to the first
// instance of the character.  If the character is not in the string,
// a null pointer is returned.  This is basically the same as the C
// strchr function.
//

/ (string) Strrchr(string, char)
// 
// The second argument is an integer representing a character.  The
// return value is a pointer into string offset to point to the last
// instance of the character.  If the character is not in the string,
// a null pointer is returned.  This is basically the same as the C
// strrchr function.
//
// (string) Strstr(string, substring)
//
// The second argument is a string which is expected to be a substring
// of the string.  Ihe return value is a pointer into string to the
// start of the first ovvurrence of the substring.  If there are no
// occurrences, a null pointer is returned.  This is equivalent to the
// C strstr function.
//
// (string) Strpath(string)
//
// This returns a pointer to the file name part of a full path given
// in string.
//

BloatObjects
JoinObjects
bad logic: if second arg given, only objects on that layer would be processed.
Now, all objects are processed as per description.

ManhattanizeObjects type "thire"

New test for reentrant hierarchy when instantiating cells. CDs::is_recursive
Changed the testing for transform depth overflow, got rid of
AbortCommand, TCheckPush, TCheck.

Fixed script bug: E.g.,
   s = Strdup(...)
   s = s + 2
would leave bad data in s.

add "-geometry" command line option
fix low-resolution problem.

// JoinLimits(flag)
//
// This is a convenience function to set/unset the variables which
// control the polygon joining process, ie, JoinPolyMaxVerts. 
// JoinPolyMaxQueue, and JoinPolyMaxGroup.  If the argument is zero,
// each of these variables is set to zero, removing all limits.  If
// the argument is nonzero, the variables are unset, meaning that the
// default limits will be applied.  The default limits generally spped
// processing, but will often leave unjoined joinable pieces when
// complex polygons are constructed.  The status of the variables will
// persist after the script terminates.  This function has no return
// value. 
//

the gdb backtrace reporting in 2.5.46 was broken for Linux

in user-defined design rules:
  edge segments are now tested in order, along the direction of the
  orientation (clockwise fro boxes).  Previously, there was no defined order.

  New variables: _CurX1, _CurY1, _CurX2, _CurY2  these contain the
  begin and end coordinates of the edge segment under test.

------------------------------

Todo:  Robin, get "out of paper" message printing.

Todo: when xic starts, look for tmp/xic.xxxx directories and give user
chance to clear them.

in the split functions, now call large_fopen for output channels.

got rid of sdesc pointer in ocopy(),  new sPF::cur_sdesc() returns
sdesc.  This is used only in drc.cc.

Label rotation angles, if non-manhattan, would change if the containing
cell was flattened.

Made permanent the cdstrdb.h database for instance attributes.

New memory management layer for frequently-used structures.  Statistics
can be abtained with "!mmstat".

ms: mswdir.cc, update list_cells()

Fixed Bug:  The Paths command in the Extract Menu was causing occasional
segmentation faults.

Streamlining of transfrom stack function applied in many places, should
improve speed slightly.
----

Add function to modify cell array parameters.

Shishir: change name of cell when reading and cell exists.

There is a new internal data structure for saving information from
a cell heirarchy in compact form.  This is accessible from a new set
of script functions.

This allows very large data files to be scanned, and opened in
skeleton mode.  When opening a file in skeleton mode in the previous
way, the entire hierarchy of cells and instances was saved, minus
only the geometry.  One could still run out of memory with large
hierarchies, since all cells/instances are saved, whether used or
not, and the main database is not efficient for storing the limited
information really needed.  The new functions get around this by
pruning the skeleton to only the cells/instances actualy needed to
represent the data window before actually creating the in-memory
hierarchy.

The FileInfo and !fileinfo functions now use the new hierarchy
representation, and much more information is available.

Bug fixed: delete [] sk_info in ~CDs
bug fixed: CDmmgr delete 0 gave spurrious warning

todo: remap layers during conversion/!assemble

todo: bug in Convert pop-up, entering numbers into Window freezes
FIXED

SkelReadDigest no longer requires skeleton mode.

todo: split functions, use new cx

questions: aliasing in gds/cif cx generation
           label bb handling
           how to remove cx elements while converting to skel

new variable: AutoRename (boolean)
  When set, when reading GDSII or CIF files and a cell is encountered with the
  same name as a cell in memory, the new cell name is automatically changed
  to avoid a clash.  Thus, the MergeControl pop-up never appears when this
  is set.  The new name has an added suffix "$N" where N is an integer.
  When this is set, the alias file is never updated.
  
todo: auto-rename for cgx/oasis

Layer Alias Table functions

new variable: UselayerAlias (boolean)
   When this variable is set, when reading an archive or native file,
   layers encountered are aliased according to entries in an internal
   table of aliases.  This table is manipulated with script functions...
   Aliasing occurs on reading only, after the LayerList is processed,
   if this feature is used.
   phys mode only
   all modes
   !lal command 

Previously, when reading in skeleton mode, text elements (labels) were
never read.  This is no longer true.  By default, labels are read and
contribute to the bounding boxes, and in SkelReadGeom().

New variable: NoReadLabels (boolean)

When this variable is set, text label elements will not be read from
archive files in physical mode.  This may improve efficiency if the
user is concerned with physical layout data only.  In multi-pass read
operations, such as skeleton mode and when using the hierarchy context
structure, the variable state should be the same when reading the
initial context as when reading geometry, otherwise cell bounding
boxes may not be accurate during the geometry read operation.

CD.dFlags replaced by collection of bools.

New set of "Assemble Stream" functions.  These implement a functionality
similar to the !assemble command.  Unlike !assemble, it is possible to
set input conversion modes on the individual files.

mswplace.cc, mswnull.cc 1 << xxx ->MC2_READ_xxx

assemble, "auto rename" always active.

WriteGeomSplit():  if l,b,r,t all 0, will compute BB of cell.
LayerList can now be used.
Bug: GDS channel files were not being null-padded to multiples of
2048 bytes per spec, spurrious error message "junk after physical records".

------
questions: aliasing in gds/cif cx generation
           label bb handling
           how to remove cx elements while converting to skel
           skeleton cells in memory, what should SkeletonMode do?o

//XXX check!!!
On can now have multiple skeleton hierarchies in memory at onee.

Much work to get rid of the static error flag (CD.Status) and associated
BS.

msw: OIfailed in mswxxx.cc


// (int) SkelClear(cellname, revert)
//
// This function clears skeleton hierarchies from memory.  The
// cellname is the name of a top-level skeleton-mode cell, or a null
// string (or 0).  If the name of a cell is given, that cell and its
// descendents are cleared.  Otherwise, all skeleton-mode cells in
// memory are cleared.  If the integer revert is 0, the cells will be
// cleared from memory.  If nonzero, the cells will remain in memory,
// with their present content, but will behave in all respects like
// normal cells.  It is not possible to reestablish skeleton mode for
// such cells.  If the operation succeeds, 1 is returned, otherwose 0
// is returned indicating an error.  The ErrorMsg function can be used
// to obtain an error message in this case.
//


// (int) SaveArchiveContext(cx_handle, name)
//
// Store the context into a database, keyed by name.  The name is an
// arbitrary short string, for example the file name.  The context
// will remain in program memory until it is explicitly removed, or
// ClearAll is called.  Contexts that are not saved are destroyed when
// the handle is closed, or the script terminates.  A context can not
// be stored more than once, and the name must not already be in use
// for context storage.  The function returns 1 if the context was
// successfully stored, 0 otherwise with possibly an error message
// retrievable with ErrorMsg.
//
// (cx_handle) RecallArchiveContext(name, remove)
//
// Recall a context from the database (as saved with
// SaveArchiveContext) and return a handle to it.  If the integer
// remove is nonzero, it is removed from the database, otherwise not. 
// A scalar 0 is returned if the context is not found or some other
// error occurs.
//

SetupSkeleton
// If the boolean value clear is nonzero and the context is not in
// storage (see SaveArchiveContext), the context structure will be
// deleted, and the handle will be closed in either case.  This will
// minimize memory use.
------

AutoRename now included in choice menu in Conversion - Import panel.

doc assemble has auto_rename

GetArchiveContext scale arg

misc bugs fixed in conversions, mostly oasis.

In the Convert/Convert pop-up, the input format no longer has separate
choices for CIF, GDSII, etc., but rather a single entry "archive".
Xic can determine the file type, so there is no need to specify.

The output format meny contains an entry "text" which now works for
cgx and oasis, as well as gdsii.  Only the GDSII text representation can
be back-converted to GDSII, and the other text format outputs are at this
point rather incomplete.

New function
// (int) FromArchive(archive_file, destination)
//
// This function will read an archive (GDSII, CIF, CGX, or OASIS) file
// and translate the contents to another format.  The type of file
// written is implied by the destination.  If the destination is null
// or empty, native cell files will be created in the current
// directory.  If the destination is the name of an existing
// directory, native cell files will be created in that directory. 
// Otherwise, the extension of the destination determines the file
// type: 
//  CGX     .cgx
//  CIF     .cif
//  GDSII   .gds, .str, .strm, .stream
//  OASIS   .oas
// Only these extensions are recognized, however CGX and GDSII allow
// an additional .gz which will imply compression.
//
// The scale factor used can be set with the SetConvertScale function. 
// The windowing and flatting functions will be applied if the
// corresponding flags are set with the SetConvertFlags and
// SetConvertArea functions.  The scale, flags and area rectangle can
// also be set from the Conversion pop-up in Xic.
//
// The value 1 is returned on success, 0 otherwise, with possibly an
// error message available from ErrorMsg.  This function is aliased to
// FromCGX, FromCIF, FromGDS, and FromOASIS for backward
// compatibility.

The FromCGX, FromCIF, FromGDS, and FromOASIS functions remain as aliases
for FromArchive, but the documentation is now gone.


Modified, takes CGX and OASIS as wel as GDSII

// (int) ToTxt(archive_file, text_file)
//
// This command will create an ascii text file text_file from the
// contents of the archive file.  The human-readable text file is
// useful for diagnostics.  If text_file is null or empty, the name is
// derived from the archive_file and given a ".txt" extension.  No
// output is produced for CIF, since these are alread in readable
// format.  The function returns 1 on success, 0 otherwise with an
// error message possibly available from ErrorMsg.
//
-------------------

todo: !check_coinc fuction, select coincident objects/cells

msw: xic:cnvrt ->xic:convt in mswconv.cc

bug filed: pixel editor was not working.

bug when !set LayerTable, strange display of superimposed images due
to backing restore not being refreshed.

LayerTable responds to first letter of "compact", "tiny" now.

///
msw.cc msw_AddDrive()  changed ':' to ';', mozy couldn't find its
database/

mswhelp.cc will show some plain text files as plain text.
***  promlem:  have to click first to get key or mouse wheel events

-----
it was possible to give too large array subscripts in scripts.  Forms like

a[2]
if (a[1000 ...)

no exit with fatal error.  These would previous return an arbitrary value
from memory or seg fault.

Much faster polygon area function added.

layer expression function: edges(dimen, zoid_list)
script func: EdgesZ(dimen, zoid_list)

// (zoidlist) EdgesZ(dimen, zoid_list)
//
// For each zoid in the zoid_list argument, a new zoid is constructed
// from each edge that covers the area within +/- dimen normal to the
// edge.  The list of new zoids is returned, after being
// clipped/merged so that no two elements overlap.  The dimen is given
// in microns.
//

changes to
  layer expr func: bloat(dimen, zoid_list, mode)
  script func:  BloatZ(dimen, zoid_list, mode)
//
// The third argument is an integer that specifies the algorithm to
// use for bloating.  If zero, a fast algorithm is used, that does not
// introduce additional vertices.  If nonzero, a more complex
// algorithm is used, which will round corners when expanding, thus
// converting boxes to polygons (as would be evident when the zoid
// list is joined into polygons).

  script func:  BloatObjects(object_handle, dimen, lname, mode)
//
// The fourth argument is an integer that specifies the algorithm to
// use for bloating.  If zero, a fast algorithm is used, that does not
// introduce additional vertices.  If nonzero, a more complex
// algorithm is used, which will round corners when expanding, thus
// converting boxes to polygons.

changed:  !bloat dimen [mode]   (mode == 0/1)

script func: Bloat(dimen, mode)
//
// The second argument is an integer that specifies the algorithm to
// use for bloating.  If zero, a fast algorithm is used, that does not
// introduce additional vertices.  If nonzero, a more complex
// algorithm is used, which will round corners when expanding, thus
// converting boxes to polygons.

new icons, minor cosmetic changes.

// (object_handle) EdgeObjects(object_handle, dimen, lname, all)
//
// This function creates new polygon copies that cover the edges of
// the figures in the passed handle.  The new polygons are like wires
// with width 2*dimen (dimen is given in microns) centered on the
// figure edge.  If a layer name is passed as a third argument, new
// polygons will be assigned to that layer, which will be created if
// it does not exist.  If the argument is null or empty, new polygons
// will be assigned to the same layer as the original polygon.  If the
// boolean argument all is nonzero, all of the objects in the passed
// list will be processed, otherwise only the object at the head of
// the list will be processed.
//
// The ObjectDelete() function can be called to delete the old
// objects.  The ObjectCopy() function can be called on the returned
// objects to add them to the database.  This function returns a
// handle to the new list upon success, or 0 if there are no objects. 
// The function will fail if the first argument is not a handle to a
// list of objects or copies, or the lname argument is non-null and
// not a vaild layer name.
//
---

new environment variable:  XIC_AUTH_MODE = "Server" or "Local"
for xic, xicii

When the programs look for the license file, if the file is not
found in the startup or license directories, the programs now look
in the home and current direcories, in that order.
-------------

Tweeks to no polygon area function to increase speed and accuracy.

Faster wire area function.

Slightly faster Poly/Point intersect function


// (int) GetPID(parent)
//
// If the boolean argument is zero, this function returns the process
// ID of the currently running Xic process.  If the argument is
// nonzero, the function returns the process ID of the parent process
// (typically a shell).  The process ID is a unique integer assigned
// by the operating system.
//

!ltsort

This will arrange the layers in the layer table in alphabetical order.

Fixed label size bug in gdsii conversion when labels have embedded
newline characters.

BUG: part of the trapezoid merging function was left commented out in
the last release.  This would cause the !join operation to produce
strange (but technically ok) polygons.

scripts: exec keyword

Script execution is a two-step process:  first, the text of the script
is parsed, and executable data structures are created internally, and
second, the execution is performed.  Consider the following script

  Set("ScriptPath", "/path/to/library_dir")
  some_library_function()

Naievely, the first line will set the script path to the directory
containing the "library" file, and the second line will execute a
function from the library.  However, this will not run, since the
library function must be resolved before the parser can process the
function call.  Somehow, we must ensure that the Set line is executed
before the following line is parsed.

The exec keyword will perform this trick.  When an exec keyword is
encountered, the remainder of the line (or to the next semicolon) is
parsed and executed immediately, and is not added to the parse tree
for scheduled execution with the other lines.  Thus, the example above
should be

  exec Set("ScriptPath", "/path/to/library_dir")
  some_library_function()

Multiple exec lines are executed in order of appearance.  Variables can
be used and set, but remember that this will be done before any manipulation
from the normal script lines.  For example, the ScriptPath switch can
be hidden:

  exec tmppath = GetPath("ScriptPath")
  exec Set("ScriptPath", "/path/to/library_dir")
  some_library_function()
  Set("ScriptPath", tmppath)

The tmppath variable will be set first, and used to reset the Script Path
as a final operation.

In server mode, all output from the "stderr" channel is sent to a file
named "daemon_err.log" in the log directory.  Output from the "stdout"
channel (only) goes to daemon_out.log.  Previously, both stderr and stdout
went to a single file, daemon_log.out.

!assemble command and function now prints file name on prompt line when
 streaming.
-----------------------

There is now limited provision for changing cell names while processing
archive files with the Convert menu panels and elsewhere.

New variables:
    CellNamePrefix  (string)
    CellNameSuffix  (string)

These variables are most simply set to a text token that is added to
the beginning or end of cell name strings.  The strings can also be
given in the form

  /str/sub/

Where str and sub are text tokens, separated by forward slash characters
as shown.  In this case if the characters at the beginning/end of the
cell name (for perfix/suffix) match the str, they are replaced by sub.
This is the same action as is used in the !rename command.  The string
token must match exactly - there is no wildcarding.  Either the prefix
or suffix, or both, can be defined.  The suffix substitution occurs after
the prefix substitution.  Either can match the whole cell name if one wants
to change the name of a single cell.

These variables will be used for file reading, writing, and conversion
initiated from the panels in the Convert Menu.  They are also used
in the Edit, OpenCell, FromArchive, ToCGX, ToCIF, ToGDS, ToGDSlibrary,
and ToOASIS script functions, as well as the assemble stream functions
and the !assemble command.

They are ignore when opening a file for editing with the Edit command or
equivalent, and when saving with Save or Save As.


modified doc
// (string) ToFormat(fmtstring, arg_list)
//
// This function returns a string, formatted in the manner of the C
// printf function.  The first argument is a format string, as would
// be given to printf.  Additional arguments (there can be zero or
// more) are the variables that correspond to the format
// specification.  The type and position of the arguments must match
// the format specification, which means that the variables passed
// must resolve to strings or to numeric scalars.  All of the
// formatting options described in the Unix manual page for printf are
// available, with the following exceptions:
//
//    1) No random argument access.
//    2) At most one '*' per substitution.
//    3) "%p" will always print zero.
//    4) "%n" is not supported.
//
// The function fails if the first argument is not a string, is null,
// or there is a syntax error or unsupported construct, or there is a
// type or number mismatch between specification and arguments.
//

The ToFormat function was causing seg faults in 2.5.49

Rewrote ToFormat to avoid stdarg hack.

CellNamePrefix active for StreamWrite, StreamCxWrite


// (int) StreamCxWrite(stream_handle, context_handle, cellname, scale)
//
// This is similar to StreamWrite, however it will add the hierarchy
// under cellname from the context_handle to the stream.  The
// context_handle is obtained from a previous call to
// GetArchiveContext.  As for StreamWrite, cells will be renamed if
// they would cause a conflict.  This function will use CellNamePrefix
// and CellNameSuffix if set, as well as LayerList and UseLayerList.
  The <i>cellname</i>
    must be the name <i>before</i> any aliasing is applied, for
    example with the <a href="GdsInToLower"><b>GdsInToLower</b></a> or
    <b>CellNamePrefix</b> variables.

//
add last sentence to StreamWrite.

// (int) CxEdit(cx_handle, cellname)
//
// This will read the given cell and its descendents into memory and
// open the cell for editing, similar to the Edit function.  The
// return value takes the same values as the Edit function return.  If
// CxSetArea has been called, the hierarchy will contain only those
// cells necessary to describe the specified area, though each cell
// will retain all geometry.

    The <i>cellname</i> must be the name <i>before</i> any aliasing is
    applied, for example with the <a
    href="GdsInToLower"><b>GdsInToLower</b></a> or <a
    href="CellNamePrefix"><b>CellNamePrefix</b></a> variables.  This
    is different from the <tt>Edit</tt> function.

//

for CellNamePrefix
Edit  cellname is aliased
OpenCell cellname is aliased
CxEdit unaliased
StreamCxWrite unalias

Cells read into the database through a context struct had the modified
flag set.  no longer true.
--------------

Turning off terms with subct active in electrical mode would erase all
visible terminals.  Now, the terminals that are subct connections points
remain properly visible and highlighted.

Fixed bug:  In electrical mode, cell connection terminals are supposed
to move if an underlying wire is moved or stretched, or an underlying
subcell or device is moved, to keep its relative position.  This was
not happening, the position remained fixed.

Added some checking to avoid crash caused by particular used-after-free
problem (PurgeTerminalMarks).

a line in a script like
   function (a, b...)
i.e., function name missing, would crash the program.

todo: SetConvetScale descr needs updating

sLcx functions:
 .  scale is multiply of cx scale and scale given to output function
 .  output fuctions write/open only cells/instances included in area config.


// (int) CxWrite(cx_handle, scale, cellname, all, outfile)
//
// This will write the cell named in the cellname string to the output
// file given in outfile.  If the boolean argument all is nonzero, the
// hierarchy under the cell is written, otherwise only the named cell
// is written.  If the outfile is null or empty, native cell files
// will be created in the current directory.  If the outfile is the
// name of an existing directory, native cell files will be created in
// that directory.  Otherwise, the extension of the outfile determines
// the file type:
//  CGX     .cgx
//  CIF     .cif
//  GDSII   .gds, .str, .strm, .stream
//  OASIS   .oas
// Only these extensions are recognized, however CGX and GDSII allow
// an additional .gz which will imply compression.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be written.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext in output.
//
// The cellname must be the name before any aliasing is applied, for
// example with the GdsInToLower or CellNamePrefix variables.
//
// The return value is 1 on success, 0 on error, or -1 if an interrupt
// was received.
//


// (int) CxEdit(cx_handle, cellname)
//
// This will read the given cell and its descendents into memory and
// open the cell for editing, similar to the Edit function.  The
// return value takes the same values as the Edit function return.
//
// The cellname, which can not be null or empty, must be the name of a
// cell in the context before any aliasing is applied, for example
// with the GdsInToLower or CellNamePrefix variables.  This is
// different from the Edit function.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be brought into memory.  Cells will contain
// geometry that is outside of the configuration area, but not contain
// instances that are entirely outside of the configuration area.

// (int) StreamCxWrite(stream_handle, cx_handle, cellname, scale)
//
// This is similar to StreamWrite, however it will add the hierarchy
// under cellname from the context handle to the stream.  The context
// handle is obtained from a previous call to GetArchiveContext.  As
// for StreamWrite, cells will be renamed if they would cause a
// conflict.
//
// The cellname, which can not be null or empty, must be the name of a
// cell in the context before any aliasing is applied, for example
// with the GdsInToLower or CellNamePrefix variables or by the
// automatic name change for conflicts.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be written.  Cells will contain geometry
// that is outside of the configuration area, but not contain
// instances that are entirely outside of the configuration area.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext in output.
//
// The return value is 1 on success, 0 otherwise.
//

check scaling in StreamCxWrite


// (int) CxSetSkipFlag(cx_handle, cellname, mode, skip)
//
// This will set/unset the skip flag in the context for the cell named
// in cellname.  With the skip flag set, the cell is ignored in the
// context, i.e., the cell and its instances will not be included in
// output or when reading into memory.  The mode is an integer:
//  0: alter flag for physical cell only
//  1: alter flag for electrical cell only
// otherwise alter flag for both physical and electrical cells.  The
// last argument is a boolean value:  0 to unset the skip flag,
// nonzero to set it.  The return value is the number of flags altered
// (0-2).
//
// (int) CxSetSkipEmpties(cx_handle, cellname)
//
// This will set the skip flags of all physical cells in the hierarchy
// under cellname that contain no readable geometry or non-empty
// subcells.  This will examine the source file to determine cell
// content, and takes into account the current layer filtering.  This
// can be called before writing or opening the hierarchy to remove
// empty cells.  The return value is 1 on success, 0 otherwise.
//
// (int) CxClearSkipFlags(cx_handle)
//
// This will reset the skip flags for all cells in the context.  The
// return value is 1 on success, 0 otherwise.
//
----
// (int) StartTiming(array)
//
// This will initialize the values in the array, which must have size 3 or
// larger, for later use by the StopTiming function.  The return value is
// always 1.
//
// (int) StopTiming(array)
//
// This will place time differences (in seconds) into the array, since
// the last call to StartTiming (with the same argument).  The array
// must have size 3 or larger.  the components are:
//  0    Elapsed wall-clock time
//  1    Elapsed "user" time
//  2    Elapsed "system" time
// The user time is the time the cpu spent executing in user mode. 
// The system time is the time spent in the system executing on behalf
// of the process.  This uses the UNIX getrusage or times functions,
// which may not be available on all systems.  If support is not
// available, e.g., in Windows, the user and system entries will be
// zero, but the wall-clock time is valid.  This function always
// returns 1.
----


recursive macros in scripts caused stack overflow faults.  E.g.,

    #define macro macro.xxx
    Print("macro")

would fault.  This works as expected now.

also, forms like

#define aaa bbb
#define bbb aaa

Will be expanded to a depth of 20 and the substitution at that depth
will be retained.  There is no error message.

The deallocation action in the internal memory manager is much faster now.
(added not_full_array in cdmmgr)

The !layer command, when using boolean operations, now uses gridding to
improve efficiency for large data sets.  The default grid size is 1000
microns square, which can be changed with the variable

    LayerPartSize (floating-point number)

This can be set to an alternate grid size (in microns).  The cell lower
left corner is on the grid goundary.  The operations are performed
piecewise in each grid area that intersects the cell.

If this variable is set to "0", no grid is used, and operations will
be performed over the entire cell at once (the previous behavior).

// (int) ZtoFile(filename, zoidlist)
//
// Save the zoidlist in a file, whose name is given in the first
// argument.  The zoidlist can be recovered with ZfromFile.  The file
// is in OASIS format, using a single dummy cell (named "zoidlist")
// and layer ("0100"), and uses only TRAPEZOID and CTRAPEZOID geometry
// records.  The function returns 1 if successful, 0 otherwise.
//

// (zoidlist) ZfromFile(filename)
//
// Read the file, which was produced by ZtoFile, and return the list
// of trapezoids it contains.  If an error occurs in reading or an
// interrupt is received, this function will fail (halting the
// script).  Otherwise a zoidlist will always be returned, but the
// list may be empty.
//

order change, Zlist functions

// (zoidlist) GetZref()
//
// This function returns the current reference zoidlist, which will be
// empty if no reference area has been set with SetZref or otherwise.
//

// (int) AdvanceZref(clear)
//
// This function allows iteration over the area of a large cell by
// establishing a grid over the current cell area and incrementally
// setting the reference area (see SetZref) to elements of the grid. 
// The grid is aligned from the lower-left corner and iteration
// advances right and up.  The reference area is set to the
// intersection of the grid element area and the bounding box of the
// current cell.  The size of the square grid elements is given by the
// LayerPartSize variable, or defaults to 1000 microns if this
// variable is not set.  With the boolean argument set to zero, the
// function will set the reference area to the first (lower left) or
// next grid element intersection area and return 1.  The function
// will return zero when it advances past the last grid element that
// overlaps the current cell bounding box, in which case the reference
// area is returned to the default value.  Thus, this function can be
// used in a loop to limit the computation area for each iteration,
// for large cells that would be inefficient to process in one step.
//
// It the argument is nonzero, the internal state is cleared.  This
// should be called if the iteration is no complete and one wishes to
// start a new loop.
//

// (zoidlist) Zhead(zoidlist)
//
// This function will remove the first trapezoid from the passed
// trapezoid list, and return it as a new list.  If the passed list is
// empty, the returned list will be empty.  If the passed list
// contains a single trapezoid, it will become empty.
//

// (int) Zvalues(zoidlist, array)
//
// This function will return the coordinates of the first trapezoid in
// the list in the array, which must have size 6 or larger.  The order
// of the values is
//
//  0 x lower-left
//  1 x lower-right
//  2 y lower
//  3 x upper-left
//  4 x upper-right
//  5 y upper
//
// On succewss, 1 is returned.  If the passed trapezoid list is empty,
// the return value is 0 and the array is untouched.

changed
// (zoidlist) GetZlist(layername, depth)
//
// This function returns a zoidlist from the layer given in the first
// argument, which has the form layername[.cellname].  If the cellname
// extension is not given, the current cell is assumed.  The returned
// list is clipped to the current reference area (see SetZref).  The
// second argument is the hierarchy depth to search, which can be a
// non-negative integer or a string starting with 'a' to indicate
// "all".  If not called in physical mode, an empty list is returned.

// (int) Zlength(zoidlist)
//
// This function returns the number of trapezoids contained in the
// list passed as an argument.
//
---------

memory errors file had quoting problem, partially broke mail

Function changed:

// (int) CxWrite(cx_handle, scale, cellname, array, clip, all, flatten,
// outfile)
//
// This will write the cell named in the cellname string to the output
// file given in outfile.  If the boolean argument all is nonzero, the
// hierarchy under the cell is written, otherwise only the named cell
// is written.  If the outfile is null or empty, native cell files
// will be created in the current directory.  If the outfile is the
// name of an existing directory, native cell files will be created in
// that directory.  Otherwise, the extension of the outfile determines
// the file type:
//  CGX     .cgx
//  CIF     .cif
//  GDSII   .gds, .str, .strm, .stream
//  OASIS   .oas
// Only these extensions are recognized, however CGX and GDSII allow
// an additional .gz which will imply compression.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be written.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext in output.
//
// The cellname must be the name before any aliasing is applied, for
// example with the GdsInToLower or CellNamePrefix variables.
//
// If the array argument is passed 0, no windowing will be used. 
// Otherwise the array should have four components which specify a
// rectangle, in microns, in the coordinates of cellname.  The values
// are
//  array[0]  X left
//  array[1]  Y bottom
//  array[2]  X right
//  array[3]  Y top
// If an array is given, only the objects and subcells needed to
// render the window will be written.  This window should be equal to
// or contained in the window use to configure the context, if any.
//
// If the boolean value clip is nonzero and an array is given, objects
// will be clipped to the window.  Otherwise no clipping is done.
//
// If the boolean value all is nonzero, the hierarchy under cellname
// is written, otherwise not.  If windowing is applied, this applies
// only to cellname, and not subcells.
//
// If the boolean variable flatten is nonzero, the objects in the
// hierarchy under cellname will be written into cellname, i.e.,
// flattened.  The all argument is ignored in this case.  Otherwise,
// no flattening is done.
//
// The return value is 1 on success, 0 on error, or -1 if an interrupt
// was received.
//

// (zoidlist) CxGetZlist(cx_handle, cellname, scale, array, clip, all)
//
// This function will create and return a trapezoid list created from
// objects read from the file associated with the passed context.
//
// The UseLayerList and LayerList variables should be set to specify
// the layer or layers that will be processed.  By default, all layers
// will contribute to the trapezoid list, which will in effect
// represent the union of all geometry.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be processed.
//
// The cellname must be the name before any aliasing is applied, for
// example with the GdsInToLower or CellNamePrefix variables.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext in the output trapezoids.
//
// If the array argument is passed 0, no windowing will be used. 
// Otherwise the array should have four components which specify a
// rectangle, in microns, in the coordinates of cellname.  The values
// are
//  array[0]  X left
//  array[1]  Y bottom
//  array[2]  X right
//  array[3]  Y top
// If an array is given, only the objects and subcells needed to
// render the window will be processed.  This window should be equal
// to or contained in the window use to configure the context, if any.
//
// If the boolean value clip is nonzero and an array is given,
// trapezoids will be clipped to the window.  Otherwise no clipping is
// done.
//
// If the boolean variable all is nonzero, the objects in the
// hierarchy under cellname will be transformed and added to the
// trapezoid list, i.e., the list will be a flat representation of the
// entire hierarchy.  Otherwise, only objects in cellname are
// processed.
//

changed
// (int) StreamCxWrite(stream_handle, cx_handle, cellname, scale, array,
//  clip, all, flaten))
//
// This is similar to StreamWrite, and CxWrite, however it will add
// cellname and optionally its hierarchy from the context handle to
// the stream.  The context handle is obtained from a previous call to
// GetArchiveContext.  As for StreamWrite, cells will be renamed if
// they would cause a conflict.
//
// The cellname, which can not be null or empty, must be the name of a
// cell in the context before any aliasing is applied, for example
// with the GdsInToLower or CellNamePrefix variables or by the
// automatic name change for conflicts.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be written.  Cells will contain geometry
// that is outside of the configuration area, but not contain
// instances that are entirely outside of the configuration area.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext in output.
//
// If the array argument is passed 0, no windowing will be used. 
// Otherwise the array should have four components which specify a
// rectangle, in microns, in the coordinates of cellname.  The values
// are
//  array[0]  X left
//  array[1]  Y bottom
//  array[2]  X right
//  array[3]  Y top
// If an array is given, only the objects and subcells needed to
// render the window will be written.  This window should be equal to
// or contained in the window use to configure the context, if any.
//
// If the boolean value clip is nonzero and an array is given, objects
// will be clipped to the window.  Otherwise no clipping is done.
//
// If the boolean value all is nonzero, the hierarchy under cellname
// is written, otherwise not.  If windowing is applied, this applies
// only to cellname, and not subcells.
//
// If the boolean variable flatten is nonzero, the objects in the
// hierarchy under cellname will be written into cellname, i.e.,
// flattened.  The all argument is ignored in this case.  Otherwise,
// no flattening is done.
//
// The return value is 1 on success, 0 otherwise.
//

The convert functions with windowing/flatening no longer use
skeleton mode by default.  Operation whould be identical.  Set "useold"
to use old algorithms.

The double-linked master references list was replaced with a symbol
table.

The "low-overhead symbol table" was converted to a template class, and
CDsym and CDm no longer derive from an element.

A new CellNameTable was added which stores cell names in a string table.
CDsym and CDm use this table.
The string will save all cell names encountered when reading, and is
cleared only on Clear(0) (if no saved contexts or symboltables) and
ClearAll().

Reading a sLcx uses the string table for cellnames, which allows the
local memory management to manage the symref_t elements.

instances in master are now in a self-keyed table rather than a
double-linked list, saves space.

Checking for interrupt made more efficient

Fixed huge core leak in FlatGenCount()

------

Got rid of regexp.h test and potential use to avoid Linux configure
(non-fatal) error.

modification of CDsym::phys(), etc.

BUG  The spacing parameters in magnified arrays were not written
correctly (not magnified) in gds/oasis/cgx output.

BUG  subcell scaling was completely broken for conversions with
windowing.


// (int) WriteArchiveContext(cx_handle, filename)
//
// This function will write a disk file representation of the archive
// context associated with the handle, into the file whose name is
// given as the second argument.  The file can be subsequently read
// with ReadArchiveContext to recreate the context.  The file has no
// other use and the format is not documented.
//
// The archive context (and thus the file) contains offsets onto the
// target archive, as well as the archive location.  There is no
// checksum or other protection currently, so it is up to the user to
// make sure that the target archive is not moved or modified while
// the context is potentially or actually in use.
//
// The function returns 1 if the file was written successfully, 0
// otherwise, with an error message likely available from GetError.
//

// (cx_handle) ReadArchiveContext(filename)
//
// This function returns a handle to an archive context created from
// the file whose name is passed as an argument.  The file must have
// been created with WriteArchiveContext.  On error, a scalar 0 is
// returned, with an error message probably available from GetError.
//
TODO select/filter by polygon winding
----------
tweeks to line clipping funcs

fixed missing error message in New Symbol.

Fixed very subtle byg in and-not geom function.

New poly-to-zoidlist function, should be a little faster.

New local memory management for the join function, should be a little
faster.

There is a new memory manager mode, whereby for certain frequently-used
list elements, the elements are never freed but are instead "recycled"
when needed.  This should improve performance for some things like
geometry computations, at the cost of keeping memory in use that can
potentially be freed.  This feature is controlled by two commands:

  !mmrecycle [y|n]
  Without an argument, the recycling mode is toggled, otherwise the
  mode is set according to the argument.  Switching recycling off does
  not free the free lists, use !mmclear to reclaim this memory for
  other uses.

  !mmclear
  This will free the free lists that are saved in recycling mode, giving
  the memory back to the system.  This is implicitly called by ClearAll().

document !mmstats

This could be particular to FreeBSD 5.3, but sometimes when a cell is
given on the command line, xic comes up with an empty screen.  This
was fixed.
----

The ReadArchiveContext function had two problems:
 1) An internal table was not checked for rehash, causing hugely inefficient
    operation for large data sets.
 2) Another internal table was doing redundant copying and was therefor
    inefficient.

The WriteArchiveContext function was always returning 0.
-----

TODO: make !mmrecycle automatic during zoidlist ops!
Shishir: zoidlist vs handles, clipping to area in zoidlist

u/l
Updated graphics to support gtk-2.4.14

fix mswdir.cc cells_highlight()

the contents list is now a drag source for the cell (extracted from
the archive).

Trying to load a cell from a device library copy from the Libraries panel
would crash the program.  This is not possible, now produces a strange
error message.

u/l
New menu in font selector, allows setting different fonts.

Now can have font selectors from !logofont and Attributes/Set Font
simultaneously.

Cosmetic changes to device menu.  Colors can be set with
!set pop_colors_dvbg  background  gray90
!set pop_colors_dvfg  foreground  black
!set pop_colors_dvhl  highlight   blue
!set pop_colors_dvsl  selection   gray80

u/l
The linestyle setting and grid editor has some minor bugs, fixed.

New textfile keywords Font1 thru Font6.

u/l
Major changes to font system.
MSW - FNT_XXX indices have changed!
MSW - new xic_bag and MSWdev::New()
MSW - font selector with drop-dn menu
MSW - shapes menu, lower case Sides, make sure help works

New techfile keywords Font1 - Font6.

when dragging text into text editor, pressing Ctrl on drop will insert the
text into the editor at the cursor, otherwise file load popup is loaded.
gtk1: useless, insert path file name
gtk2: can drag text from other windows
MSW:  can drag text from other text windows.  Drop behavior is diferent
    automatically, no Ctrl-C.

>>>>>
gtk2 is a graphical user interface toolkit that is the successor to
gtk1.  It is found on most recent Linux distributions, and is being used
by many applications.  This release of Xic contains a graphical interface
that has been substantially rewritten to support gtk2, though this release
still uses gtk1.

Presently, the xictools are statically linked to gtk1, which require no
further support than the X window system.  Thus, these binaries are highly
portable.

Gtk2, on the other hand, requires a large number of subsidiary
libraries.  It is simply not possible at this time to distribute a
static gtk2 product.  A gtk2-based product will target operation on a
specific operating system target, such as Red Hat Enterprise Linux, or
require the user to install one or more shared libraries on older or
different Linux distributions.  It is anticipated that gtk2 will be
provided only on Linux and freeBSD systems.  Ports to Solaris would
require installation of all of the needed shared libraries, which is a
ridiculous thing to ask of a customer, so gtk1 will continue to be
provided on that platform.

one important internal change induced by gtk2 is a complete change in the
way fonts are defined and used.  Gone are the long "x font descriptors"
and such, replaced by "pango font descriptors".  The defaults are
different, so the visual appearance is somewhat different.  The keywords
in init files that provide font names should indicate pango font names
in the gtk2 releases.

Another important change is that the text window used in text editing
pop-ups and elsewhere is completely different.  The new window is at
once more powerful and less capable than the old version.

1)  The new window can drag/drop selected text.
2)  The new window has no preset control-key operations at present.  Thus,
    it is very limited as a text editor.
<<<<<

new command line option: -Ggeometry_spec, where the geometry_spec is an
X-style window geometry specification.  There is no space between -G and the
specification.  Overrides the XIC_GEOMETRY variable.

new environment variable: XIC_GEOMETRY
set to an X-style geometry string.

If the geometry has been specified, Xic will use it to position and size
the main window (if the window manager permits this).

The geometry specification, used to define window size and position, is
a string in the following form:

WIDTHxHEIGHT+XOFF+YOFF

where WIDTH, HEIGHT, XOFF, and YOFF are numbers representing screen pixels.
The "x" between the WIDTH and HEIGHT  is literal.  A plus sigh '+' or minus
sign '-' must appear ahead of XOFF and YOFF.

+XOFF
    The left edge of the window is to be placed XOFF pixels in from the
    left edge of the screen.
-XOFF
    The right edge of the window is to be placed XOFF pixels in from the
    right edge of the screen.

+YOFF
    The top edge of the window is to be YOFF pixels below the top edge of
    the screen.
-YOFF
    The bottom edge of the window is to be YOFF pixels above the bottom
    edge of the screen.

Fixed bug: a trapezoid list consisting of a single zero-width trapezoid
would crash the function that converts trapezoid lists to polygons.

MSW release, font format change.  The "official" format is now
"face size", but "(size)face" is still recognized.  Tech file not
back compatible for this.
-----------------------------------

The assembly stream functionality has been revised.

The following script functions have been removed:
StreamWrite
StreamCxWrite
StreamFinish

New and modified functions:

  (int) StreamSource(stream_handle, file_or_context, scale, layer_list,
    use_layer_list, layer_aliases, cname_prefix, cname_suffix)

    This function will add a source specification to a stream.  The
    specification can refer to either an archive file, or to a context
    handle.  Upon successful return, the source will be queued for
    writing to the stream (initiated with StreamRun).  Arguments set
    various modes and conditions that will apply during the write.

    stream_handle
      Handle to the stream object.

    file_or_context
      This argument can be either a string giving a path to an archive
      file, or a context handle as returned from GetArchiveContext. 
      If a context is passed, at least one cell instance must be
      specified with StreamInstance.

    scale
      A scale factor applied when writing.  For a context, the scale will
      multiply the scale factor provided to GetArchiveContext in output.

    layer_list
      This can be a string containing a space-separated list of layer
      names.  If 0 is given instead, the argument effectively contains
      the present value of the LayerList "!set" variable.

    use_layer_list
      If this value is a string starting with 'n' or 'N', objects on
      layers found in the layer_list will be skipped in output.  If set
      to any other string, only objects found on layers in the layer_list
      will be written.  If 0 is given, the argument is effectively the
      current value of the UseLayerList variable.

    layer_aliases
      This can be set to a string containing "name=alias" layer name
      subsitiution assignments.  Objects on layer "name" will be written
      on layer "alias".  If 0 is passed instead, and the UseLayerAlias
      variable is currently set, the argument is effectively the current
      contents of the Layer Alias table.

    cname_prefix
      This can be set to a prefix string for cell name modification.  If
      0 is passed, this argument is effectively the current value of the
      CellNamePrefix variable.  Name modification is performed in the
      manner of that variable.

    cname_suffix
      This can be set to a suffix string for cell name modification.  If
      0 is passed, this argument is effectively the current value of the
      CellNameSuffix variable.  Name modification is performed in the
      manner of that variable.

  The function returns one on succes, zero otherwise with an error
  message probably available through GetError.


  (int) StreamInstance(stream_handle, cellname, x, y, my, ang, magn,
    onecell, flatten, array, clip)

    This function will add an instance name to the most recently added
    source file (using StreamSource).  The cellname must match the
    name of a cell found in the archive specified in the source. 
    There are two consequences:  only the named cell and its subcell
    hierarchy will be written to output, and if a top cell was
    specified (with StreamTopCell), an instance of the named cell will
    be placed in the top cell.  The placement is governed by the x, y,
    my, ang, and magn arguments, which are ignored if there is no top
    cell.

    The x,y are the translation coordinates of the cell origin.  The
    my is a flag indicating Y-reflection before rotation.  The ang is
    the rotation angle, in degrees, and must be a multiple of 45
    degrees.  The magn is the scale factor for the cell.

    At least one instance must be specified to a source supplied as a
    context description.  A source must have been specified before
    this function can be called successfully.

    The remaining arguments are:

    onecell
      If the boolean value onecell is nonzero, only the specified cell
      will be written, and not the subcells.

    flatten
      If the boolean variable flatten is nonzero, the objects in the
      hierarchy under cellname will be created in cellname, thus only
      one cell, containing all geometry, will be written (onecell is
      ignored);

    array
      If the array argument is passed 0, no windowing will be used. 
      Otherwise the array should have four components which specify a
      rectangle, in microns, in the coordinates of cellname.  The values
      are
        array[0]  X left
        array[1]  Y bottom
        array[2]  X right
        array[3]  Y top
      If an array is given, only the objects and subcells needed to
      render the window will be written.  This window should be equal to
      or contained in the window used to configure the context, if any.

    clip
      If the boolean value clip is nonzero and an array is given,
      objects will be clipped to the window.  Otherwise no clipping is
      done.

  The function returns one on succes, zero otherwise with an error
  message probably available through GetError.


  (int) StreamRun(stream_handle)

    This function will initiate the writing from the sources
    previously specified with SteamSource into the output file.  The
    real work is done here.  The function returns one on succes, zero
    otherwise with an error message probably available through
    GetError.

The Praesagus merg-tool GUI was written.

BUG: Pressing Ctrl-X caused a GTK error message and did not pop up the
expand panel as it should.  Fixed.

BUG: In gds read, all properties would be ignored.

In Grid pop-up, typo "Soild" fixed.

**MSW PopUpLibraries()  MODE_OFF relist() for LibChangedCallback

In extraction, vias are now recognized at all levels of the hierarchy,
instead of only the cell and its subcells.  This means that patches
of via material not related to any conductor can establish connections
in or between subcells.

More internal code reorganization, invisible to user.
---------------------------------------

When printing bytes read when reading a file, the number was
gibberish.
-------

In the file selector, if the directory becomes deselected, the files
in the listing could not be opened.  Now, the files listing will
disappear if the directory becomes deselected.  Also, the directory
will be deselected if it is collapsed into a parent (and thus becomes
invisible).

Overhaul of the readin logic for native hierarchies and archives.  Some
operations that were deferred to the end of the read are now done during
reading.  Should be more efficient.

Open libraries are now kept in order.  Earlier names will supersede
later ones.

Symbol name resolution

Edit command:
  with path: must be a native symbol cell
  no path: in memory, library reference, native cell file, create

reference in native symbol file: in memory (clobber test), 
  inline library reference, native cell file, create with unread flag set

clicking on library content listing in edit mode:
   same as Edit command, NO PATH so if name is found earlier in search
   earlier reference will be opened!!!


Libraries: only the cell in the selected library reference has name
modified when brought into memory.  Subcells will retain original
name, and there is no aliasing.

assemble stript funcs didnt work .

update help for new assemble file.
cellname in file, SourceInstance is the name *before* aliasing is applied.

the topcell name will be aliased just like any other cell name.

Gone: CellNamePrefix, CellNameSuffix.  These variables have been replaced
by four new variables:
    CellNamePrefixR
    CellNamePrefixW
    CellNameSuffixR
    CellNameSuffixW
The "R" variables modify cell names being read from a file.  The "W"
variables modify cell names being written to a file.  Having two sets
of variables  avoids the too common issue of reading a file into memory
and back out to disk, with the same modification occurring twice.

GetArchiveContext
// The names of cells saved in the context reflect any aliasing that    
// was in force at the time the context was created.  The applicable
// aliasing is the same as if the file is read into memory with the
// Import Control panel in the Convert menu.

// (int) CxEdit(cx_handle, cellname)
cellname is after aliasing.
// The cellname, which can not be null or empty, must be the name of a
// cell in the context.  The is the cell name after any aliasing that
// was in force when the context was created.

// (int) CxWrite(cx_handle, scale, cellname, array, clip, all, flatten,
cellname is after aliasing.

// (int) StreamSource(stream_handle, file_or_context, scale, layer_list,
change ref to CellNamePrefix

// (zoidlist) CxGetZlist(cx_handle, cellname, scale, array, clip, all)
cellname is after aliasing.



Cell Name Aliasing

There is provision for modifying cell names as files are read,
written, or format converted.  Although the functionality is
centralized in the program, bits and pieces of this functionality are
available in numerous commands, and can be set through various panels
and variables.  This section describes this capability, summarized in
a table below.

Aell name changes are never applied to devlice library cell names.

Cell name prefix/suffix modification
  This is controlled by the CellNamePrefixR, CellNameSuffixR variables
  for reading and translation, and the CellNamePrefixW and CellNameSuffixW
  variables for writing.  These allow a prefix or suffix to be added to
  cell names.

Upper casing
  Cell names that are lower case can be converted to upper case.  This
  is available from the GdsOutToUpper variable (writing GDSII only),
  and the assemble operations.

Lower casing
  Cell names that are upper case can be converted to lower case.  This
  is available from the GdsInToLower variable (reading GDSII only),
  and the assemble operations.

Alias file
  When reading and writing GDSII files, an alias file may be read
  to provide a cell name mapping.

AutoRename
  When the AutoRename variable is set, when reading into memory,
  cell names encountered that match the name of a cell already in
  memory will be silently changed.

GDSII conformance
  When writing GDSII, cell names will be forced to conform to the
  GDSII specification.  For format level 3, this limits the length
  to 32 characters.  The character set is limited to alpha-numerics
  plus '?', '_', and '$'.

The Conversion - Import, Conversion - Export, and Conversion panels
available from the Convert Menu each contain a Cell Name Mapping module
for controlling modification of cell names during reading, writing, and
format conversion, respectively.  This module contains the following
controls:

Auto-Rename check box
  This check box is available in the Conversion - Import panel only.
  The state sets the state of, and is initialized from, the AutoRename
  variable.  When set, cell names that clash with the name of a cell in
  memory encountered when a file is being read will be changed to avoid
  a clash.

Prefix and Suffix text entries
  Text entered into these text areas will be added as a prefix or
  suffix to cells encountered.  A limited text substitution mechanism
  is available.  In the Conversion and Conversion - Import panels,
  these text areas control the value (and are initialized from) the
  InCellNamePrefix and InCellNameSuffix variables.  In the Conversion
  - Export panel, these text areas control the value (and are initialized
  from) the InCellNamePrefix and InCellNameSuffix variables.

To Lower and To Upper check boxes
  If set, To Lower will convert upper case cell names to lower case,
  and To Upper will convert lower case cell names to upper.  Mixed case
  cell names are not affected.  Case conversion is performed before any
  applied prefix/suffix.  In the Conversion - Import and Conversion
  panels, these buttons track the state of the InToLower and
  InToUpper variables.  In the Conversion - Export panel, these
  buttons track the state of the OutToLower and OutToUpper variables.

Read Alias and Write Alias check boxes
  These buttons control whether an alias file is read before a file
  is processed, and updated after processing is complete.  In the
  Conversion - Import and Conversion panels, the buttons track the
  InUseAlias variable, snf in the Conversion - Export panel, the
  buttons track the OutUseAlias variable.  Aliasing from the alias
  file is applied before any other name change.


//
//               Front        Back
// Translation   PS,TL,AF     TU,GD (1)    Format translation
// Read File     PS,TL,AF,AR  -            Read to memory
// Read Cx       PS,TL,AF,AR  -            Read to context
// Read Lib      LB,AR        -            Read from library reference
// Write Mem     -            PS,TU,AF,GD  Write archive from memory
// Write Cx      -            PS,TU,AF,GD  Write from context
// Assemble      PS,TL,AF     TU,GD (2)    Assemble multiple archives
//
// Notes:
//  There is never both front end and back end tables used.
//  (1) The TU,GD are actually applied to the front-end aliasing when
//      converting to GDSII.  There is no back-end AliasTab applied.
//  (2) All aliasing is done in the front-end, no back-end AliasTab
//      is applied.  The PS,TL,TU are set by asource_t flags and not
//      the normal global variables.
//  In skeleton mode, the skeleton is establised in memory using the
//  "normal" aliasing.  When reading geometry, file offsets are used
//  to obtain the geometry for each needed cell, based on the memory
//  image.  Thus, cell names in the file are ignored while reading,
//  so it is not necessary to keep the AliasTab.

/*
old vars:
    GdsInToLower
    GdsOutToUpper
    GdsUseAlias
    CellNamePrefix
    CellNameSuffix
new vars:
    InToLower
    InToUpper
    InUseAlias
    InCellNamePrefix
    InCellNameSuffix
    OutToLower
    OutToUpper
    OutUseAlias
    OutCellNamePrefix
    OutCellNameSuffix
*/
NoPopUpLog  added to table
OasWriteRep  added to table



tech file
GdsInToLower -> InToLower
InToLower
GdsOutToUpper ->OutToUpper
OutToUpper

script funcs gone:
// (int) SetMapGDSoutToUpper(state)
// (int) SetMapGDSinToLower(state)

new
// (int) SetMapToUpper(state, rw)
//
// This function sets a flag which causes lower case cell names to be
// mapped to upper case when reading, writing, or format converting
// archive files.  The first argument is a boolean value which if
// nonzero indicates case conversion will be applied, and if zero case
// conversion will be disabled.  The second argument is a boolean
// value that if nonzero will apply case conversion when writing an
// archive file from memory, and if zero indicates that case
// conversion will be appied when reading or format converting archive
// files.
//
// Within Xic, this flag can also be set from the panels available
// from the Convert menu.  The return value is the previous setting of
// the flag.

// (int) SetMapToLower(state, rw)
//
// This function sets a flag which causes upper case cell names to be
// mapped to lower case when reading, writing, or format converting
// archive files.  The first argument is a boolean value which if
// nonzero indicates case conversion will be applied, and if zero case
// conversion will be disabled.  The second argument is a boolean
// value that if nonzero will apply case conversion when writing an
// archive file from memory, and if zero indicates that case
// conversion will be appied when reading or format converting archive
// files.
//
// Within Xic, this flag can also be set from the panels available
// from the Convert menu.  The return value is the previous setting of
// the flag.
//

The Conversion - Import and Conversion panels have a new module for
layer operations.  This contains the following controls:

LayerList text area
  This contains a list of CIF-style layer names.

Layers only check box

Skip layers check box

Use Layer Aliases check box
  When set, the current layer alias table will be applied to layers
  found in the file.  This button tracks the state of the UseLayerAlias
  variable.

Edit Layer Aliases button
  This button brings up a panel for editing the layer alias table.
  The panel contains a listing of two columns: the left column for
  layer names, and the right column for the alias.

  The File menu contains entries for saving the layer alias table
  to a disk file, and for reading the entries from a disk file.

  The Edit menu contains entries to add,  delete, and edit aliases,
  and to select listing layer names in "decimal" form.

  When working with GDSII and other files that use a numeric
  layer/datatype combination to designate layers, the name string
  is in th form of a four-byte upper case hexadecimal integer.
  The two left characters indicate the layer number, zero padded, in the
  range 0-255.  Similarly, the two right characters represent the
  datatype number.  For example, layer 33, datatype 15 has the name
  "210F".

  When providing a name, an alternate "decimal" form can
  be used.  This is "layer,datatype" where the two integers are
  separated by a comma (no space).  Thus, "33,15" is an equivalent way
  to specify the layer name for the example above.  Internally, the
  layer name is always stored as the hex name.

  If the Decimal Form entry is active, the decimal notation will be
  used in the listing for applicable layers.  Otherwise, the hex form
  will be listed.

new variable NumToTxtCells (integer)
  When converting GDSII or CGX to a text-mode representation file,
  writing will stop after the number of cells given in this variable
  have been processed.  Setting to zero will show only the file header
  records.  If negative or the variable is unset, the entire file
  will be written.  In the case of GDSII, such files are not back-convertable
  to GDSII.

  GdsMunit (real)
  When writing GDSII, the normal MUNITS value (1e-9) is multiplied by
  this factor when written to the physical mode part of the file. 
  This should be accompanied by a compensating scale factor change in
  order to keep the file scaling constant, unless a change of scale is
  desired.  The acceptable range is 0.01 - 100.0.  This will apply to
  *all* GDSII files written.




in help windows Options menu,
  Find Text
    This enables searching for text in the window.  A dialog window
    appears, into which a regular expression is entered.  Text
    matching the regular expression, if any, is selected and scrolled
    into view, on pressing Find Text or the Enter key.  The text is
    searched from the top line in view or the line following an
    existing selection, toward the end of text.  Additional matches
    can be found by pressing the Find Text button repeatedly.  The
    search is case-insensitive.

At startup, an new initialization is read, if it exists.  The file name
is ".xicinit", and it will be found in the current or home directories.
Unlike the .xicstart file, this is read before the the technology file,
and any other initialization files.  It consists of script language
statements, and can be used to set variables, such as paths, or perform
other initialization.  Unlike the .xicstart file, which is read after
other files, the .xicinit file can be used to set the path to find the
technology file.
----

When responding to the prompt for the Save As command, giving a directory
name will now allow saving the entrire current cell hierarchy as native cell
files in that directory.  In particular, giving "." will allow saving in
the current directory.

The scale factor in the Conversion - Import panel now applies to reading
native cell files.

redeclaration of an array in scripts to a size larger than the current
array size is no longer an error.  The array will be resized to the new
size.

OMG! the symref_t management was broken in MSW.
----------------------------

When using the vertex editing feature on the polygon and wire creation
commands, after moving a vertex the object now remains selected.

The sensitivity of the windowing buttons is now disabled when "text" is
the output format.
--

Assemble, moved aliasing to back end.

TODO, move translation to back end?

FIX bug:  files list, master and contents, click on content list with
overwrite popup causes crash.  strangeness with dragging icon.

modal Merge and Save popups now really modal.
MSW make this so.
It was possible to crash the program with the Content Listing, which
wasn't locked out when the Merge Control pop-up was visible.

The Tree pop-up has been enhanced a bit.  The entries are now sorted
alphabetically.  There is a new label area that provides progress feedback
when there is long processing time building the internal tree, and in
the end shows the total number of "nodes" (selectable lines) and the
hierarchy depth.

The format of the context file has changed to allow info struct and
electrical mode to be included.  The new format is not backwards
compatible, but present releases can read prefious files.

New:
// (int) CxOpenFlat(cx_handle, scale, cellname, array, clip)
//
// This will read the cell named in the cellname string and its
// subcells into memory, creating a flat cell with the same name.  If
// a cell named cellname already exists in memory, it will be
// overwritten.
//
// If the context has been configured for area with CxSetArea for the
// cell, only the cells and instances needed to display the
// configuration area will be read.
//
// The scale will multiply the scale factor provided to
// GetArchiveContext.
//
// The cellname, which can not be null or empty, must be the name of a
// cell in the context.  This is the cell name after any aliasing that
// was in force when the context was created.
//
// If the array argument is passed 0, no windowing will be used. 
// Otherwise the array should have four components which specify a
// rectangle, in microns, in the coordinates of cellname.  The values
// are
//  array[0]  X left
//  array[1]  Y bottom
//  array[2]  X right
//  array[3]  Y top
// If an array is given, only the objects and subcells needed to
// render the window will be read.  This window should be equal to
// or contained in the window used to configure the context, if any.
//
// If the boolean value clip is nonzero and an array is given, objects
// will be clipped to the window.  Otherwise no clipping is done.
//
// The return value is 1 on success, 0 on error, or -1 if an interrupt
// was received.
//

changed (perm removed)
// (int) CxSetArea(cx_handle, cellname, l, b, r, t)
//
// This will configure the context so that only cells and instances
// that overlap the rectangle given by the last four arguments, when
// reflected to the coordinates of cellname, will be active.  The
// top-level cell is taken as cellname.  Thus, the hierarchy is
// effectively "pruned", leaving only elements required to represent
// the area supplied in cellname.
//
// The coordinates are given in microns.  One is returned on success,
// zero otherwise.
//

changed (clear removed)
// (int) CxSetupSkeleton(cx_handle, cellname, l, b, r, t)
//
// This function will create a skeleton hierarchy in memory from the
// context, using the area configuration if applied.  If no area
// configuration was applied, the entire hierarchy under cellname is
// created.
//
// The cell created for cellname becomes the current cell, and the
// skeleton mode functions can be used in the normal way.  The
// original archive file must remain available and not be modified, as
// cells are accessed through offsets into the file saved in the
// context when geometry is read.
//
// The l, b, r, t parameters set the bounding box that will be applied
// when reading geometry (i.e., an implicit call to SkelSetDataWin
// with these parameters).  These should be the same as or a
// sub-rectangle of the bounding box passed to CxSetArea, in microns,
// if an area configuration was applied.  Otherwise, the rectangle
// should intersect with the bounding box of cellname.
// 
// The return value has the same interpretation as the return from the
// Edit command, with one indicating success and 0 failure but other
// values may appear in strange cases.
//

The default LayerPartSize has bee reduced to 20 microns from 1000 microns.

// (int) AdvanceZref(clear)
//
// LayerPartSize variable, or defaults to 20 microns if this
// variable is not set.

The Merge Control pop-up would not appear under Windows.

The Master/Edit button logic wasn't right in the Files Listing under Windows.

Fixed problem with backup file creation, Windows only.
----

// (real) Zarea(zoidlist)
//
// This function returns the total area of the trapezoids contained in
// the list passed as an argument.  This does not account for
// overlapping trapezoids, call GeomOR first if overlapping trapezoids
// are present (lists returned from the script functions have already
// been clipped/merged unless otherwise noted).
//
----

Revised interrupt handling during long operations.

When the "wait" cursor is active when the mouse pointer is in a drawing
window, Xic is "busy".  When busy, Xic locks out all key press events except
for ctrl-C, and all mouse button events.  If a locked-out event is received,
a pop-up will appear that informs the user that Xic is busy and to use
Ctrl-C to abort the operation.  This pop-up will disappear after three
seconds (trying to destroy it with the mouse will simply cause it to
stay up longer).

When Xic is busy and Ctrl-C is pressed, the operation is paused, and the
used is asked whether to abort of continue on the prompt line.  While
waiting for input, most buttons are desensitized.  Those that are not
are the Help Menu, View/Allocation, and Attributes/Freeze.  Thus, these
features are available during the pause.

All other events are dispatched normally while busy, so that visual
updates should happen fairly quickly.  Unlike previous releases, there is
no attempt to save unhandled events and handle them later.

ADD DOC TEXT about not using .gz files for archive context.

When using local validation, XT_LICENSE_PATH can be set to the full
path to the license file.  This file only will be used, the regular
search is suppressed.

key.h
key.h is not used on the client side when interacting with the license
server.  key.h must be consistent between the LICENSE file and the
code that processes the license file.
THIS WAS STUPID, the app should match key.h used by the server.

Extraction function pop-ups had memory issue.

MSW: in Print pop-up, the single-line printers list that had to be
stepped through has been replaced with a drop-down menu.

Big rewrite for CD autonomy, got rid of virtual functions, etc.

There is now a log file produced when the !assemble command is run.  This
is named "assemble.log" and is written in the current directory.
-----------------

TODO:
Force terminal and node names to be the same.
When using Push, save the instance pointer, and add the parent node to the
connected terminal display in the node name editor.  Color code?

Changed LayerPartSize to 100 microns

test toZlistR for subcells

removed slope cache from Zoid.

Electrical mode cell bounding box now includes virtual terminals

Pointer problem in new virtual functions caused seg faults.

revised the "virtual terminal" capability.  Virtual terminals are
electrical mode cell terminals that have no underlying attached geometry,
and are used when the contents of the cell is not available for processing
by Xic, i.e., the cell is a "black box" with possibly an include file
spice netlist.  These terminals are created in the subct command by
holding Ctrl while clicking on a terminal location.

Virtual terminals of the top-level cell are rendered as a beer-barrel
shape rather than as a square, for visual differentiation.

Fixed bug: All of the defined virtual terminals would be erased if any
cell object was deleted.

The cell bounding box will now include all virtual (as well as regular)
terminals.

All terminal centers are now "hot spots" which can be clicked on for
node hypertext, such as when in the plot/iplot mode, or when creating
labels.  Previously, only locations on objects were sensitive.

--
If a double character operator (e.g., ==, !=, <=, etc) was not followed by
a space, the parse would fail.

A line beginning with any of these is considered a comment
#define STOPCHARS ";:(+-*/=!~&|#^"

The forms "repeat (expression)" and "return (expression)" would fail when
the expression is surrounded by parentheses as shown.  These forms are now
accepted.
-----------------------------------

added sleep to malloc fail.

When Conversions or Conversions - Import pops down, the layer alias editor
is also popped down.  Previously, it was left visible, but could cause
fault when popped down.
***MSW check this

Note: layer aliasing/filtering occurs before mapping to tech file layers.
change this?  add note in docs.

The second-level memory manager was rewritten to improve performance.

The internal data structure representing labels was modified to reduce
memory consumption in physical mode.

modified:
// (int) Label(text, x, y, [width, height, xform])
//
// This function creates a label on the current layer.  The function
// takes a variable number of arguments, but the first three must be
// present.  The first argument is of string type and contains the
// label text.  The next two arguments specify the x and y coordinates
// of the reference point, which is dependent on the current
// justification, as set with the Justify() function or the optional
// xform arguemnt.  The default is the lower-left corner of the
// bounding box.
//
// The remaining arguments are optional.  The width and height specify
// the size of the bounding box into which the text will be rendered,
// in microns.  if both are zero or negative or not given, a default
// size will be used.  If only one is given a value greater than zero,
// the other will be computed using a default aspect ratio.  If both
// are greater than zero, the text will be squeezed or streatehed to
// conform. 
//
// The xform is an integer whose bits set transformation and
// justification attributes, and if given the Justify function and
// UseTransform function settings will be ignored, and these
// attributes will be set from xfrom.  If xform is not given, the
// functions will set the justification and transformation.  The bits
// in xform have the following significance:
//
//    bits    description
//    0-1     0-no rotation, 1-90, 2-180, 3-270.
//    2       mirror y after rotation
//    3       mirror x after rotation and mirror y
//    4       shift rotation to 45, 135, 225, 315
//    5-6     horiz justification 00,11 left, 01 center, 10 right
//    7-8     vert justification 00,11 bottom, 01 center, 10 top
// 
// This function always returns 1.
//

// (int) Logo(string, x, y, [width, height])
//
// This creates and places physical text, i.e., text that is
// constructed with database polygons that will appear in the mask
// layout.  The function takes a variable number of arguments, but the
// first three must be present.  The first argument is of string type
// and contains the label text.  The next two arguments specify the x
// and y coordinates of the reference point, which is dependent on the
// current justification, as set with the Justify() function.  The
// default is the lower-left corner of the bounding box.  The text
// will be transformed according to the current transform.
//
// The remaining arguments are optional.  The width and height specify
// the approximate size of the rendered text.  Unlike the Label
// function, the text aspect ratio is fixed.  The first of height or
// width which is positive will be used to set the "pixel" size used
// to render the text, by dividing this value by the character cell
// height or width of the default font.  Thus, the rendered text size
// will only be accurate for this font, and will scale with the number
// of pixels used in the "pretty" fonts.  One must experiment with a
// chosen font to obtain accurate sizing.  If neither parameter is
// given and positive, a default size will be used.
//
// This provides the functionality of the logo menu button in Xic, and
// is sensitive to the following variables:
//
//  LogoEndStyle
//  LogoPathWidth
//  LogoManhattan
//  LogoPretty
//  LogoPrettyFont
//  LogoToFile
//
// This function always returns 1.
//

!logofont command:  the informational label was not being printed, so there
was no used feedback when a button was pressed.

MSW: check this, also SaveFileDlg to sSFD.

Logo always used cur transform
// (int) UseTransform(enable, x, y)
//
// This command enables and disables use of the current transform in
// the ShowGhost() function, as well as the functions that create
// objects:  Box(), Polygon(), Arc(), Wire(), and Label().  The
// functions Move(), Copy(), Logo(), and Place() naturally use the
// current transform and are unaffected by this function.
//

New functions:

// AddMark(type, arguments...)
//
// This function will add a "user mark" to a display list, which is
// rendered as highlighting in the current cell.  These can be used
// for illustrative purposes.  The marks are not included in the
// design database, and will disappear when a new current cell is
// chosen.  The arguments that follow the type argument vary depending
// upon the type.  The type argument can be an integer code, or a
// string whose first character signifies the type.  The return value,
// if nonzero, is a unique mark id, which can be passed to EraseMark
// to erase the mark.  A zero return indicates that an error occurred.
//
// The table below describes the marks available.  All coordinates and
// dimensions are in microns, in the coordinate system of the curent
// cell.  Each mark takes an optional attribute argument, which is an
// integer whose set bits indicate a display property.  These bits are
//
// bit 0:  Draw with a textured (dashed) line if set, otherwise use a
//         solid line.
// bit 1:  Cause the mark to blink, using the selection colors.
// bit 2:  Render the mark in an alternate color (bit 1 is ignored).
//
// Type: 1 or "l"
// Arguments: x1, y1, x2, y2 [, attribute]
// Draw a line segment form x1,y1 to x2,y2.
// 
// Type: 2 or "b"
// Arguments: l, b, r, t [, attribute]
// Draw an open box, l,b is lower-left corner and r,t is upper-right
// corner.
// 
// Type: 3 or "t"
// Arguments: xl, xr, yl [, yu, attribute]
// Draw an open triangle.  The two lower vertices are xl,yl and xr,yl. 
// The third vertex is (xl+xr)/2,yu.  If yu is not given, it is set to
// make the triangle equilateral.
// 
// Type: 4 or "c"
// Arguments: xc, yc, rad [, attribute]
// Draw a circle of radius rad centered at xc,yc.
// 
// Type: 5 or "p"
// Arguments: numverts, xy_array [, attribute]
// Draw an open polygon or path.  The number of vertices is given
// first, followed by an array of size 2*numverts or larger that
// contains the vertex coordinates as x-y pairs.  For a polygon, The
// vertex list should be closed, i.e., the first and last vertices
// listed (and counted) should be the same.
// 
// Type: 6 or "s"
// Arguments: string, x, y [, width, height, xform, attribute]
// Draw a text string.  The string is followed by the coordinates of
// the reference point, which for default justification is the
// lower-left corner of the bounding box.  The width, height, and
// xform arguments are analogous to those of the Label script
// function, providing the rendering size and justification and
// transformation information.  Unlike the Label function, the settings
// of the Justify and UseTransform functions are ignored,
// transformation and justification must be set through the xform
// argument.
//

// (int) EraseMark(id)
//
// Remove a mark from the "user marks" display list.  The argument is
// the id number returned from AddMark.  If zero is passed instead,
// all marks will be erased.  The return value is 1 if any marks were
// erased.
//
----------------------------------

In scripts, using "return" without a following expression would cause
the script to halt, with no message.

Modifications to computational geometry functions to reduce execution time.

New context read/flatten methodology employed in read_flat().  If variable
"old_flat" is set, the old method will be used.

The Solaris release was broken.

A new qsort function was hard coded, replacing the pathetic glibc
qsort in Linux releases.
-----

fixes to oasis reader for polygons, compatibility with anuvad-0.2.

trying to read an archive file consisting only of cells that are
already in memory and not top-level cells would fail.

the symbol merge pop up interrupt logic was incorrect, allowing Xic
to get into an unresponsive mode.

---
Previously,
if an negative path width was encountered in a gdsii file, xic would
not read the wire, and emit a warning message in the log file.
Now, Xic will take the path width as relative and create the wire,
also issuing a warning.

Note:
  GDSII constucts absolute magnification, absolute angle, and
  absolute path width are not supported in Xic.  The values are
  taken as relative, and a warning is issued.  These are not
  supported by other file formats in a portable way, and should
  be considered obsolete.

Change to wire storage to reduce memory use.
-------------------------------

When reading or converting an archive file, warning messages are no
longer printed on the prompt line.  These can be read in the log file,
which will be shown if any warnings or errors occur.

BOX records in GDSII files are now converted as BOUNDARY records, with
the BOXTYPE ignored, and a warning message is issued in the log file.
Previously, BOX records were ignored.

Modified, no_undo variable added
// Layer(string, depth, flat, undoable)
//
// This is very similar to the !layer command.  The string is of the
// form
//
//   "[join|split|splitv] new_layer_name [=] layer_expression".
//
// The first token of the string can be "split" or "join" to indicate
// whether the created geometry is in the form of a set of trapezoids
// or a minimal number of complex polygons, respectively.  If this
// optional keyword is missing, the default is to use the joined form. 
// The join operation is sensitive to the JoinMax...  variables.  The
// equal sign after the new layer name is optional.
//
// The depth is the search depth, which can be an integer which sets
// the maximum depth to search (0 means search the current cell only,
// 1 means search the current cell plus the subcells, etc., and a
// negative integer sets the depth to search the entire hierarchy). 
// This argument can also be a string starting with 'a' such as "a" or
// "all" which indicates to search the entire hierarchy.
//
// The flat argument is a flag (0 or not 0).  If flat is nonzero, the
// layer is created in the current cell using geometry to depth. 
// Otherwise, the layer is created in each subcell to depth, using
// geometry only from the cell.
//
// The undoable argument is also a flag, and if nonzero the
// operation will be undoable with the Undo command or function. 
// If zero, the operation will not be undable, but execution may be
// faster and memory use lower.
//
// There is no return value; the function either succeeds or will
// terminate the script on error.
//

the override_busy flag was stuck on, means that wait cursor didn't
appear (or worse?)

// (object_handle) FindPath(x, y, depth, use_extract)
//
// This function returns a handle to a list of copies of physical
// conducting objects in a wire net.  The x,y point (microns, in the
// physical part of the current cell) should intersect a conducting
// object, and the list will consist of this object plus all connected
// objects.  The depth argument is an integer or a string beginning
// with "a" for "all" gives the hierarchy search depth.  Only objects
// in cells to this depth will be considered for addition in the list
// (0 means objects in the current cell only).  If the boolean value
// use_extract is nonzero, the main extraction functions will be used
// to determine the connectivity.  If the value is zero, the
// connectivity is established through geometry.  This is similar the
// the Show Paths and Quick Paths commands.
//
// The return value is a handle to a list of object copies, or 0 if no
// objects are found.
//

bug: it was possible for Xic to hang when displaying cell arrays.

Xic no longer tries to draw highlighting when busy, avoiding munging
the screen in some operations, such as flattening.

----------------------
Add SetLayerXXX functions

Tweeked hardcopy interrupt handling.
**check MSW print interrupt handling, versatec.
 
drcrule.cc, geomtree.cc

Work on DRC, second part of corner overlap test now called as a supplement
to cwt/cst.  The bloat 0 is now correct.

The check for empty symbols was broken.

The trapezoid clip-out function failed for certain special cases.

memory manager would give spurrious warnings (mmap blocks).
---------------------------------

// (string) SetCurLayerExKeyword(string)
//
// The string argument is an extraction keyword and associated text,
// as would appear in a layer block in the technology file.  The
// specification will be applied to the current layer, overriding
// existing settings and possibly causing incompatible or redundant
// existing keywords to be deleted.  This is similar to the editing
// functions of the Edit Extraction command in the Extract Menu.
//
// The return is a status or error string, which may be null.
//
// The following keywords can be specified:
//    Conductor
//    Routing
//    GroundPlane
//    GroundPlaneDark
//    GroundPlaneClear
//    TermDefault
//    Contact
//    Via
//    DarkField
//    Symbolic
//    Resistance
//    Capacitance
//    Tranline
//    Thickness
//    Rho
//    Sigma
//    EpsRel
//    Lambda
//

// (int) RemoveCurLayerExKeyword(string)
//
// This will remove the specification for the extract keyword given in
// the argument from the current layer.  The argument must be one of
// the keywords listed for SetCurLayerExKeyword.  The return value is
// 1 if a specification was removed, 0 otherwise.
//

The Home function wouldn't work if the image was already scaled correctly
but the vertical offset was not the "home" position.

Computation graphics functions modified to use C++ exception handling instead of
variable passing for interrupt handling (not visible to user).

Improved trapezoid bloating algorithm.  The "mode 0" algorithm is now internal,
bypassing the DRC functions, so is much faster and does not create a temp
layer.  The original "mode 0" is now "mode 3".

Fixed bug in trapezoid merge that could hang program.

Also changed for layer experssions
// (zoidlist) EdgesZ(dimen, zoid_list, mode)
//
// This returns a list of zoids that in some way describe edges in the
// zoid list passed.  There are currently three modes, 0-2 as set by
// the third argument.  The dimen is given in microns.
//
// mode 0
// The zoid list is logically merged into distinct polygons, and a
// "halo" extending outside of the polygon by width dimen (positive
// value taken) is constructed.  The trapezoids describing the halo
// are returned.
//
// mode 1
// The zoid list is logically merged into distinct polygons, and a
// wire object is constructed using each polygon vertex list.  The
// wire width is twice the dimen value passed.  The trapezoid list
// representing the wire area is returned.  This will fail and give
// strange shapes if the dimensions of a polygon are smaller than the
// wire width.
//
// mode 2
// For each zoid in the zoid_list argument, a new zoid is constructed
// from each edge that covers the area within +/- dimen normal to the
// edge.  The list of new zoids is returned.
//
--------------------

Fixed GTK error messages if Working popup was dismissed manually.

cd_context.cc
        new char[sizeof(numtab_t) + (hashmask-1)*sizeof(ntel_t*)];
to
        new char[sizeof(numtab_t) + hashmask*sizeof(ntel_t*)];

extif defaults limits changed.

The NewCurLayer function, etc. will no longer create a new layer
with a name already in the layer table.  Also applies when reading
archive file.

Fixed core leak when setting variables.

Fixed geometric bug in Extract RLC partitioning.

Fixed bug: It was possible (but unlikely) to overflow an internal
buffer when displaying polygons, which could cause instability.

highlight text should scale better for deep-submicron features.

Created yank.scr for xic/scripts.
TODO!!! add this to package lists.

Revised preferences.scr script.

Fixed malloc recursion memory error when the OS sends the app a SIGTERM
due to excessive memory consumption.

In scripts, the tests  (zlist == 0), (zlist != 0) are now accepted.
Note that (!zlist) is an incorrect test for an empty zlist, it will
invert the zlist and return true if the inverted list is not empty.

add doc about fastcap subs/ins/metal case.

partition edit message now gives interface/conduftor displayed.

Show Tree was generating GTK error messages.


// (real) ExtractRL(conductor_zoidlist, layername, term_zoidlist1,
//    term_zoidlist2, r_or_l)
// 
// This will use the square-counting system to estimate the resistance
// or inductance of a conducting object with respect to two terminals.
// The first argument is a trapezoid list representing a single
// conducting area, on the layer given in the second argument.  The
// layer keywords set electrical parameters used in the estimation.
// 
// For Resistance:
//   The Resistance layer keyword gives the ohms-per-square of the
//   material.  If not set, a value of 1.0 is assumed.
// 
// For Inductance:
//   The Tranline keyword supplies the appropriate parameters.  In
//   this case, the material is assumed to be over a ground plane
//   covered by dielectric.
// 
// The next two arguments are trapezoid lists representing the two
// terminals.  In the computation, the terminal areas are clipped by
// the body area.  The final argument is a boolean which if nonzero
// indicates inductance estimation, and zero indicates resistance
// estimation.
// 
// The algorithm is most efficient if all coordinates are on some
// grid.  This provide for efficient tiling of the structure.
// 
// The return value is the estimated resistance or inductance.  The
// function will fail (terminating the script) if an error is
// encountered.
//

// (int) ReadSPtable(filename)
// 
// This function reads a specification file for a spatial parameter
// table.  A spatial parameter table is a 2-d array of floating point
// values, which can be accessed via x/y coordinate pairs.  The user
// can define any number of such tables, each of which is given a
// unique identifying keyword.
// 
// The tables are input through a file, which uses the following format:
// 
// keyword X DX NX Y DY NY
// X Y value
// ...
// 
// Blank lines and lines that begin with punctuation are ignored.
// There is one "header" line with the following entries:
//   keyword:       Arbitrary word for identification.  An existing
//                  database with the same identifier will be replaced.
//   X              Reference coordinate in microns.
//   DX             Grid spacing in X direction, in microns, must be > 0.
//   NX             Number of grid cells in X direction, must be > 0.
//   Y              Reference coordinate in microns.
//   DY             Grid spacing in Y direction, in microns, must be > 0.
//   NY             Number of grid cells in Y direction, must be > 0.
// 
// The header line is followed by data lines that supply a value to
// the cells.  The X,Y given in microns specifies the cell.  A second
// access to a cell will simply overwrite the data value for that
// cell.  Unwritten cells will have a zero value.
// 
// The function returns 1 on success, 0 otherwise with an error
// message available from the getError function.
//

// (int) ClearSPtable(name)
// 
// This will destroy the spatial parameter table whose keyword matches
// the string given.  If a numeric 0 (NULL) or a null string is
// passed, all spatial parameter tables will be destroyed.  The return
// value is the number of tables destroyed.
//

// (real) GetSPdata(name, x, y)
//
// This function returns the value from the spatial parameter table
// keyed by name, at coordinate x,y given in microns.  If the table is
// not found or x,y is out of range, 0 is returned.
//

// (int) SetSPdata(name, x, y, value)
//
// This function will set the data cell corresponding to x,y (in
// microns) of the named spatial parameter table to the value.  The
// return value is 1 if successful, 0 if the table can't be found, x,y
// is out of range, or some other error occurs.
//

The StringHandle function was returning a list of strings in reverse order.
The strings are now returned in normal order.

// (int) ListReverse(stringlist_handle)
//
// This function reverses the order of strings in the stringlist
// handle passed.  If the operation succeeds the return value is 1, or
// if the list is empty or an error occurs the value is 0.
//

!fx dumpc now takes a "-s" option:  !fx dumpc [-s] [filename]

This will append to or create two files:  filename.top and
filename.bot.  If the files exist, they will be appended to. 
Concatenating the two files (e.g.  cat file.top file.bot > file.lst)
will produce a standard unified list file.  This option enables
output from different fastcap preprocessor runs to be combined.

!fx setref cellname

This will set the "reference cell".  The reference cell is a flat cell
in memory containing objects identical to those saved in the preprocessor,
and is used to supply group numbers which will be used in fastcap
output.

!fx area string
string = "left,bottom right,top"

This sets the minimum computation area, should be called before objects
are added.

Windows Only
The install program was modified to ensure that new executables are actually
installed, and old binaries are moved to directories bin/xic_old and
bin/wrspice_old.

Previously, when installing an update without removing the existing
installation, it was likely that the new executable would not actually be
installed.  Now, the install is forced, even if Windows does not think
the the new executable is actually "newer".
-------------------------

New menu command in subwindows: Show Location
keyword: lshow

When this subwindow menu button is active, and both the subwindow and
the main window are in physical mode and displaying the same cell, an
outline box is drawn in the main window around the area displayed in
the subwindow.  This indicates the position of the subwindow display,
assuming that the subwindow is showing a zoomed-in part of the display
in the main window.


In the Quick Paths command, invisible layers are now ignored.  Invisible
layers are included in the Show Paths command.  This is true also in the
script functions FindPath and ExtractRL.

Fixed error in 7214 pseudo-prop from library (Filipov).

Oasis reader would conplain and set pathtype 0 wires to pathtype 2.


// (real) ExtractRL(conductor_zoidlist, layername, r_or_l, array, term, ...)
// 
// This will use the square-counting system to estimate the resistance
// or inductance of a conducting object with respect to two or more
// terminals.  The first argument is a trapezoid list representing a
// single conducting area, on the layer given in the second argument.
// The layer keywords set electrical parameters used in the
// estimation.
//
// For Resistance:
//   The Resistance layer keyword gives the ohms-per-square of the
//   material.  If not set, a value of 1.0 is assumed.
//
// For Inductance:
//   The Tranline keyword supplies the appropriate parameters.  In
//   this case, the material is assumed to be over a ground plane
//   covered by dielectric.
// 
// The third argument is a boolean which if nonzero indicates
// inductance estimation, and zero indicates resistance estimation.
//
// The fourth argument is an array which will hold the return values,
// which will be resized if necessary.  The zeroth component of the
// array gives the number of returned values, which are returned in
// the rest of the array.  If there are two terminals, the number of
// returned values is 1.  For more than two terminals, the number of
// returned values is n*(n-1)/2, where n is the number of terminals.
// The values are the effective two-terminal decomposition for
// terminals i,j (i != j) in the order, e.g., for n = 4, 01, 02, 03,
// 12, 13, 23.
//
// The following arguments are trapezoid lists representing the
// terminals.  Arguments that are not trapezoid lists will be ignored.
// There must be at least two terminals passed.  Terminal areas should
// be spatially disjoint, and in the computation, the terminal areas
// are clipped by the conductor area.  Terminals are assigned numbers
// in left-to-right order.
//
// The algorithm is most efficient if all coordinates are on some
// grid.  This provide for efficient tiling of the structure.
//
// Structures that require a very large number of tiles may require
// excessive time and memory to compute, and/or suffer from a loss of
// accuracy.  The approximate threshold is 1e5 tiling squares.
// Non-Manhattan shapes have strict internal limiting of tile count.
// Manhattan structures can require an arbitrarily large number of
// tiles, thus the potential for resource overuse.
//
// The return value is always 1.  The function will fail (terminating
// the script) if an error is encountered.
// ExtractNetResistance(x, y, spicefile, array, term, ...)
//
// This function will extract resistance of a conductor net, taking
// into account multiple conducting layers connected by vias.  The
// resistance decomposition of each conducting object and its vias
// and/or terminals is computed using the algorthm used by the
// ExtractRL function.  The resistance of the connected network is
// then computed, with respect to the terminals specified.
//
// The first two arguments are a coordinate point that is expected to
// fall on a wire net (similar to the FindPath function).  The net is
// recognized using the Quick Paths algorithm.  Invisible layers are
// not included.
//
// The third argument is a string giving a file name, which will
// contain a generated SPICE listing representing the extracted
// resistor network.  In the SPICE file, each terminal and each via
// are assigned node numbers.  A comment indicates the range of
// numbers used for terminals.  If this argument is 0 (NULL) or an
// empty string, no SPICE file is written.
//
// The fourth argument is an array which will hold the return values,
// which will be resized if necessary.  The zeroth component of the
// array gives the number of returned values, which are returned in
// the rest of the array.  If there are two terminals, the number of
// returned values is 1.  For more than two terminals, the number of
// returned values is n*(n-1)/2, where n is the number of terminals.
// The values are the effective two-terminal decomposition for
// terminals i,j (i != j) in the order, e.g., for n = 4, 01, 02, 03,
// 12, 13, 23.
//
// The following arguments are trapezoid lists representing the
// terminals.  Arguments that are not trapezoid lists will be ignored.
// There must be at least two terminals passed.  Terminal areas should
// be spatially disjoint, and in the computation, the terminal areas
// are clipped by the conductor area.  Terminals are assigned numbers
// in left-to-right order.
//
// The return value is always 1.  The function will fail (terminating
// the script) if an error is encountered.
//

// ExtractNetResistance(x, y, spicefile, array, term, ...)
//
// This function will extract resistance of a conductor net, taking
// into account multiple conducting layers connected by vias.  The
// resistance decomposition of each conducting object and its vias
// and/or terminals is computed using the algorthm used by the
// ExtractRL function.  The resistance of the connected network is
// then computed, with respect to the terminals specified.
//
// The first two arguments are a coordinate point that is expected to
// fall on a wire net (similar to the FindPath function).  The net is
// recognized using the Quick Paths algorithm.  Invisible layers are
// not included.
//
// The third argument is a string giving a file name, which will
// contain a generated SPICE listing representing the extracted
// resistor network.  In the SPICE file, each terminal and each via
// are assigned node numbers.  A comment indicates the range of
// numbers used for terminals.  If this argument is 0 (NULL) or an
// empty string, no SPICE file is written.
//
// The fourth argument is an array which will hold the return values,
// which will be resized if necessary.  The zeroth component of the
// array gives the number of returned values, which are returned in
// the rest of the array.  If there are two terminals, the number of
// returned values is 1.  For more than two terminals, the number of
// returned values is n*(n-1)/2, where n is the number of terminals.
// The values are the effective two-terminal decomposition for
// terminals i,j (i != j) in the order, e.g., for n = 4, 01, 02, 03,
// 12, 13, 23.
//
// The following arguments are trapezoid lists representing the
// terminals.  Arguments that are not trapezoid lists will be ignored.
// There must be at least two terminals passed.  Terminal areas should
// be spatially disjoint, and in the computation, the terminal areas
// are clipped by the conductor area.  Terminals are assigned numbers
// in left-to-right order.
//
// The return value is always 1.  The function will fail (terminating
// the script) if an error is encountered.
//

In Windows, entering forms like "../../dir/file" to the Edit command
prompt could hang the program.
-----------------------------

The zlib header was wrong, so compressed OASIS files were not compatible
with other tools (anuvad-0.2).

The reader can now handle per-cell and other compression.

The compression scheme has changed.  Previously virtually the entire file
was placed in one CBLOCK record.  This violates the OASIS spec, which states
that CELL records can't be in a CBLOCK.  Now, cells are compressed
individually.

Previously, when OasNameTab was set, the cell names were placed in a
non-strict table referenced in the START record.  Now, cell names are
stored in a strict mode table referenced in the END record, same as
anuvad.

The current release can not read old compressed files, and vice-versa.

From the Convert panel, when converting from OASIS to text, if the
oasis2ascii program from SoftJin (in the free anuvad package) is found,
it will be used to do the convertion.  The Anuvad output is far more
complete than the internal ascii output, and it can be back-converted to
OASIS with ascii2oasis, which is also part of anuvad.

Supporting variables:

   AnuvadPath  (pathname)
     This gives the path to the directory containing the anuvad
     executables.  If not set, /usr/local/bin is assumed.

   Oasis2AsciiArgs
     This can be set to arguments that will be passed to oasis2ascii,
     which can alter the output format (see the anuvad documantation).

When wiriting OASIS with StripForExport on, i.e., writing physical data only,
and OasNameTab is set, the offset table is placed in the END record.
With StripForExport not set, in general we write two sequential OASIS
databases into the file, the first for physical data, the second for
electrical.  In this case, the offset table is placed in the START
record.  PAD records are added to avoid overwriting data since this
is a non-sequential operation.

The name tables are written just ahead of the END record in all
cases (when tables are used).

For OasNameTab, tables are used in the physical part only.

Using oasis2ascii, cell count (variable name?) is ignored.  Only the
physical part is listed.

The support for anuvad oasis2ascii has been removed.

The text output from OASIS files is now a far richer format.  The format
is that same as used by anuvad-0.2.

new variables

reading
ignore checksum  OasReadNoChecksum

writing
checksum type    OasWriteChecksum
use compression  OasWriteCompressed
use tables       OasWriteNameTab
use repetitions  OasWriteRep

printing
wrap lines       OasPrintNoWrap
print addresses  OasPrintOffset

// gone
#define VA_OasCompress        "OasCompress"
#define VA_OasNameTab         "OasNameTab"

WriteRep and WriteChecksum now have corresponding buttons in the
Conversion - Export panel.

The OasNameTab will now use tables for all text strings and not just
cell names.

The OASIS i/o now can handle the checksum.
------------
the Conversion panel now has buttons for
   OasWriteCompressed
   OasWriteNameTab
   OasWriteChecksum
   OasPrintNoWrap
   OsePrintOffset

The OASIS spec does not prevent <name> records from appearing after
references in the file.  In this case, the reader is forced to look ahead
on the file to satisfy the reference, which is inefficient.  Previously,
Xic would fial on these files with an error message.  Now, a look-ahead
is done, so that such files are readable.   This is an inefficient way to
save data, and Xic will never produce such files.

The final message from the converters was not being printed on-screen.

---
Tfil bug:  crash in Quick Paths in layer-specific mode fixed.
-----------------------

The oasis writer will now use type 3 point lists for coordinates that
define angles that are multiples of 45 degrees.

Modal variables used more extensively in OASIS output.

The !compare function was broken.  It works again now, with some minor
improvements including final prompt to view file.

!compare [-l layer_list] [-t obj_types] [-s] [-g] file1 [file2] [-c cell ...]

This function compares the geometry and instance placements in two cell
hierarchies, on of which is in an archive file and the other is in memory or
in another archive file.  The results are written to a log file.

Options:
  -l layer_list
   The layer_list is a list of layers, which must be quoted if more than one
   layer appears.  If no layer_list is given, all layers will be checked
   for differences.

  -s
  If a layer_list is given, differences will be recorded in all layers
  *except* the layers in the layer_list.

  -t obj_types
  The obj_types ia a word containing any or all of the letters {c,b,p,w,l}
  which indicate cells, boxes, polygons, wires, and labels.  The letters
  indicate the types of objects that will be considered.  If this option
  is not given, the default is "cbpw", i.e., labels are ignored.

  When -g is given (see below) only 'c' is recognized, "bpw" is assumed.
  That is, when using geometric comparison, 'c' will control whether
  or not to compare subcell instances, and boxes, polygons, and wires
  will always be tested.

  -g
  If set, the objects on the comparison layer are converted to a trapezoid
  list, and geometric operations on the trapezoid lists are used for the
  comparison.  Labels are ignored in this mode, and subcells are treated
  "normally".  If not set, objects are compared directly, so differences
  will be recorded even if the resulting geometry is the same, e.g., cells
  with and without !split will show many differences.  Subcells are
  always checked directly, thus an array vs. individual placements will
  indicate differences.

  -c cell...
  This option must appear last in the command line.  The tokens following
  -c are cell names.  If these are given, only the listed cells will be
  considered, otherwise all cells will be considered.

  There must be at least one archive file name given.  If a second archive
  file name is found, comparison is between the two hierarchies.  Otherwise,
  the second hierarchy is expected to exist in memory.

  Only the cells for the current mode (electrical or physical) are
  considered.

  The results are written to a file named "diff.log" in the current
  directory.  Each object or region that appears in one cell and not the
  other corresponding cell is written in a CIF-like format to the log
  file.
   
(Pavel) The first time that a variable si set, it is not expanded for
env variables.

****
int
CellDiff(fname, fname, cellname, layer_list, skip, types, geom, h_array)

H(h_array[0]) -> list12
H(h_array[1]) -> list21

int
CellComp(fname, fname, cellname, layer_list, skip, types, geom)
-1 error
0 no diffs
1 different

Fixed OASIS error reading vertical TRAPEZOID records.

There is a new caching subsystem in the OASIS writer, used to detect
repetitions and for optimal ordering.  Behavior is identical to the
old caching system when writing from memory, but the new system will
also work in direct conversions.

There is a new "OASIS: find repetitions" check box in the Conversion
panel which enables the repetitions cache durint translations to OASIS.
This is tied to the similar button in the Conversion - Export panel,
and sets/unsets the OasWriteRep variable.

Some new variables that control esoteric aspects of OASIS writer:
    OasNoTrapezoids  (boolean)
      The normal behavior is to check 3 and 4 sided polygons to see
      if they can be written as (more compact) TRAPEZOID or CTRAPEZOID
      records.  Setting this variable will suppress this, providing
      slightly faster conversion at the cost of file size.

    OasWireToBox
      The normal behavior is to leave wires alone, preserving
      data-type integrity.  However, space can be saved by writing
      two-vertex rectangular wires as boxes.  Setting this variable
      will enable this, which may reduce file size at the expense of
      slightly more conversion time.

    OasNoGCDcheck
      This applies only when repetitions are being used (OasWriteRep is
      set).  Normally, a greatest common divisor is computed, and if
      larger than unity type 10 repetitions are converted to type 11.
      This can reduce file size.  If this variable is set, the GCD is
      not computed, probably increasing file size but reducing conversion
      time.

!compare:
  -d  Don't record the actual differences, only whether or not the cells
      differ.

The Label and Logo script functions were broken.

Two-column status print (bytes read / bytes written) during format
conversions.

When receiving a selection in the prompt line, such as by clicking with
button 2:
  old behavior:  move cursor to click location, add selection there
  new behavior:  add selection at cursor

The prompt line auto-scrolling was broken (no clear before redraw)
 MSW CHECK THIS

---

In ObjectCopy function, if the objects are copies they can now be copied
to any cell.  Previously, they were restricted to being copied into the
cell of origin, like non-copies.
ObjectCopyToLayer


// (string) ObjectString(object_handle)
//
// This function returns a CIF-like string describing the object
// pointed to by the given object handle.  This provides all of the
// geometric information for the object.  Strings of this format can
// be reconverted to object copies with the ObjectCopyFromString
// function.
//
// On error or for an empty handle, a null string is returned.  The
// function will fail if the argument is not a handle to an object
// list.
//

// (object_handle) ObjectCopyFromString(string, layer)
//
// This function will create an object copy from the CIF-like string,
// as generated by the ObjectString function.  Boxes, polygons, and
// wires are supported, labels and subcells will not return a handle. 
// The object will be associated with the layer named in the second
// argument.  The layer will be created if it does not exist.  Only
// physical layers are accepted.
//
// On success, a handle to an object list containing the new copy is
// returned.  On error, a scalar zero is returned.  The function will
// fail if the string is null or a new layer cannot be created.
//
// CxCompare(cx_handle1, cx_handle2, cellname, layer_list, obj_types,
//  skip_layers, geometric, array)
//
// This will compare the contents of the given cell, somewhat similar
// to the !compare command, but unlike the command, only one cell is
// compared.
//
//   cx_handle1     Handle to an archive context.
//   cx_handle2     Handle to an archive context, or zero.  If zero, the
//                  cell should exist in memory.
//   cellname       Name of cell to compare.
//   layer_list     String of space-separated layer names, or zero which
//                  implies all layers.
//   obj_types      String consisting of the layers c,b,p,w,l, which
//                  determines objects to consider (subcells, boxes, polygons,
//                  wires, and labels), or zero.  If zero, "cbpw" is the
//                  default, i.e., labels are ignored.  If the geometric
//                  argument is nonzero, all but 'c' will be ignored, and
//                  boxes, polygons, and wires will be compared.
//   skip_layers    If this boolean value is nonzero and a layer_list
//                  was given, the layers in the list will be skipped.
//                  Otherwise, only the layers in the list will be compared
//                  (all layers if layer_list is passed zero).
//   geometric      If this boolean value is nonzero, a geometric comparison
//                  will be performed, otherwise objects are compared
//                  directly.
//   array          This is a two-element or larger array, or zero.  If
//                  an array is passed, upon return the elements are
//                  handles to lists of box, polygon, and wire object copies
//                  (labels and subcells are not returned): array[0] contains
//                  a list of objects in handle1 and not in handle2, and
//                  array[1] contains objects in handle2 and not in handle1.
//                  The H function must be used on the array elements to
//                  access the handles.  If the argument is passed zero, no
//                  object lists are returned.
//
// The scalar return can take the following values:
//   -1             An error occurred, with a message possibly available
//                  from the GetError function.
//    0             Successful comparison, no differences found.
//    1             Successful comparson, differences found.
//    2             The cell was not found in handle1.
//    3             The cell was not found in handle2.
//    4             The cell was not found in either handle.
//

new command:  !zs
Change the view in the current window to show all selected objects.

In the polygn and wires commands, if the vertex editor is active, i.e. a
polygon or wire is shown with the vertices marked, clicking with the Ctrl
button pressed will start a new polygon or wire, overriding the vertex
editor.  This can be used to start a new polygon at a marked vertex location,
for example.  Without Ctrl pressed, the vertex editor would have precedence
and would delete the marked vertex instead of starting a new polygon or wire.

----

In spin command, angle is now printed in main window lower-left corner.
MSW - doesn't work!!!!!!!

The Rename function in the cells menu and similar functions were broken.

!compare: properties are ignored.
-e : expand arrays
-r max_errors

CxCompare:
// When comparing subcells, arrays will be expanded into individual
// instances before comparison, avoiding false differences between
// arrayed and unarrayed equivalents.  The returned handles (if any)
// contain all differences without limit.  Properties are ignored.

Subtle bug found in geometrical ordering functions.
--------

smktemp, register_tmpfile_delete moved out of applications and
into ginterf.  Ditto for err_printf and out_perror.
GRregisterMainContext must be called for err_printf.

todo - strip tabs in color name list.

Big edit change, got rid of enum boolean { False, True }

new font handler: fontutil.cc/h

mozy-qt into ginterf, major rewrite of gtkhelp.cc to use broken-out
classes.

file selectors and path list poll the cwd and will update automatically
if chdir called, good riddance to change_cwd().

huge rewrite og all graphics and organization of ginterf library.

The file selector has a new "Filter" menu.  This allows the filename
filter to be made visible.  The filename filter is a "combo" menu
that contains six entries.  Each entry consists of a name terminated
wilt a colon (':'), followed by "globbing" tokens, or nothing.  The
first two choices ("all:" and "archive:") are fixed and cannot be
edited.  The remaining four can be edited by the user.  These can be
set to any shell-like file matching tokens.

rules
the string up through the first colon is ignored.  If there is no colon
present, the entire string is used.

If the used part of the string is empty, all files are matched.

The string contains space-separated tokens for file matching, just as
used in a shell command line:  * matches 0 or more chars, ? matches
1 or more chars. [], { }, etc.  Other text must match exactly.

The menus are now defined in common code instead of the toolkit-
specific code.

TODO  PopUpExpand window-specific?
TODO if subwin pups up partially off-screen, the off-screen part contains
rubbish.

TODO li CIF file, semicolon optinal after comment?  without it file doesn't
read.

A semicolon following a CIF comment is now optional.  Previously, a
semicolon following a comment was required, or the file read would
abort with mysterious errors.  This is for compatibility with parsers
used by other vendors.

int hc driver Boxes functions, second two numbers w/h or x/y ?

Masoud bug:  In electrical mode, when prompting for file/cell names with
the Edit command or others, clicking on a cell in the layout will
enter the cell name into the prompt line, the same as in physical mode.
Previously, a random hypertext node or device name would be entered,
which is useless in this context.

New layers are now generated in CD package.  Unused layers are now stored
in CD.  Changes to CDif.

Xic has undergone a substantial revision of the user interface system.
The original motivation was to support QT, a graphics toolkit which
advertises platform independence.  After many weeks of work to adapt to
QT, It has been decided that QT is not at this time a viable option
for Xic, due to performance, flexibility, and distribution issues.
Nevertheless, this work contributed to a much better architecture for
the graphics system, which has been adopted in the Gtk and Windows
releases.

---
tiff output was broken since LZW compression was disabled in some
labrary releases due to legal issues.  Tiff output now uses deflate
compression.

The html viewer can now display tiff and pnm/ppm images.

// int PlaceTemplateArgs(cellname, args)
//
// This sets the default template parameters used when instantiating
// the template cell given in cellname.  The second argument is a
// string giving the comma-separated name=value pairs that will be
// applied, when the cell is instantiated with the Place function or
// otherwise.  Note that in graphical mode, the given string will be
// the default string when the user is prompted to enter the
// parameters.  This function should be used when placing template
// cells in batch or server mode, and applies only to subsequent Place
// calls.  Additional calls to Place will use these parameters for
// cellname, until changed with another call to this function.  In
// graphical mode, if the user modifies the string, the modified
// string will be used in subsequent placements.
//
// The return value is 1 unless the cellname is null or empty, in
// which case 0 is returned.

// (bool) UpdateNative(dir)
//
// This will write to disk all of the modified cells in the current
// hierarchy as native cell files in the directory given as the
// argument.  If the argument is null or empty, cells will be written
// in the current directory.  The return value is the number of cells
// written.
//
// Note that only modified or internally created cells will be
// written.  To write all cells as native cell files, use the ToXIC
// function.

The cell properties editor was not displaying properties correctly,
no properties would be found until a property is added.

Small change to the Properties Editor, pseudo-properties and template
properties can be changed with Edit.  Previously, these would only work
with Add.  The pseudo-property must be selected before Edit is pressed.
The up/down keys only cycle through the real properties.

The !symtab command would likely crash the program, switching to a
named table, then back to the default, then back to the named table
would access a bad pointer.

When switching between symbol tables, the cell being edited is now
remembered and reverted to.

!summary
  The user is given a chance to view the file.  Warning: this file might be
huge.

!fileinfo changed:
  !fileinfo filename [flags] [outfilename]

The output goes to outfilename if given, "xic_fileinfo.log" otherwise.
The user is given the chance to view the file.

FileInfo output format

coordinates now are in microns

INFO_TOPCELLS
  List the top-level cells, i.e., the cells in the file that are not
  used as a subcell by another cell in the file.  If INFO_ALLCELLS is
  also given, only the names are listed, otherwise the cells are listed
  including the INFO_INSTANCES, INFO_BBS, and INFO_FLAGS fields.

INFO_ALLCELLS
  All cells found in the file are listed by name, including the
  INFO_INSTANCES, INFO_BBS, and INFO_FLAGS fields if these flags
  are also given.

INFO_INSTANCES
  For each cell, the subcells used in the cell are listed.  The subcell
  names are indented and listed below the cell name.

INFO_BBS
  For each cell the bounding box is shown, in LBRT form.
  For subcells, the position, transformation, and array parameters are shown.
  Coordinates are given in microns.  The subcell transformation and array
  parameters are represented by a concatenation of the following tokens,
  which follow the subcell reference position.  These are similar to the
  transformation tokens found in CIF, and have the same meanings.
  MY    Mirror about the x-axis.
  Ri,j  Rotate by an angle given by the vector i,j.
  Mmag  Magnify by mag.
  Anx,ny,dx,dy  Specifies an array, nx X ny with spacings dx, dy.

INFO_FLAGS
  For cells, the "area_ok" flag is shown.  This will be set when the
  area configuration has been applied, and the cell is included within
  the hierarchy needed to represent the configured area.  This will be
  zero in FileInfo and similar calls.

  For instances, a similar flag is shown.  If set, the instance is included
  in the configuration area.  This will be zero in FileInfo and similar
  calls.

if flags passed 0, set to ~INFO_FLAGS

CtrlShift-A-F  (set view action) works now.

New feature.
The last six '!' commands entered into the prompt area are remembered,
and can be recalled with
    !#[n]
The n is an optional integer 0-5, and if not given will be taken as 0.
The n'th previous command will be printed in the prompt area, where it
can be edited and re-executed.
Each '!' command given, including those from !#, will be pushed onto the
history list in the 0 position if it is not the same as the previous command.

Updates to the File Selector (Unix/Linux only)

When the pointer is over a file name in the file listing, info about the file
is now printed in the label area (if the label area is visible).  This
is a string very similar to the "ls -l" file listing in Unix/Linux.
It provides:
  1)  the permission bit settings and file type codes as in "ls -l"
  2)  the owner and group
  3)  the file size in bytes
  4)  the last modification date and time

There is a new "Show Label" command in the Listing menu.  When set, the
label area is visible.  The label area contains the root directory and
current directory, or the file info string.  By default, the label area
is shown when the pop-up is created from an Open or Open File menu button,
but is not shown when the pop-up appears when soliciting a file name on
the prompt line (such as in the Edit command).

The file listing is now automatically updated when a new filter is selected,
and when Enter is pressed when editing a filter string.

// int PlaceTemplateArgs(cellname, args)
if both args are 0, the table will be destroyed.
if second arg is 0, cellname will be removed from table.
mappngs destroyed when script terminates.
// int PlaceTemplateArgs(cell, args)
//
// This sets the default template parameters used when instantiating
// the template cell named in cell.  The second argument is a string
// giving the comma-separated name=value pairs that will be applied, 
// when the cell is instantiated with the Place function or otherwise.
// Note that in graphical mode, the given string will be the default
// string when the user is prompted to enter the parameters.  This
// function should be used when placing template cells in batch or
// server mode, and applies only to subsequent Place calls.
// Additional calls to Place will use these parameters for cell, until
// changed with another call to this function.  In graphical mode, if
// the user modifies the string, the modified string will be used in
// subsequent placements.
//
// This function actually manages an internal table of 
// cellname/argument list associations.  If 0 is given for both
// arguments, the table will be cleared.  If the second argument is 0,
// the entry for the first argument, if any, will be removed from the
// table.  The table is cleared when the script terminates.
//
// The return value is always 1.

the DRCcheckArea function would likely crash if no file_handle was
 given.

When the RLC Ectraction panel was popped down, if the terminal or
partition was active, it would remain active, causing trouble.  These are
now terminated when the panel pops down.
--------------------------------------------------------------------------

GJC mos transistors with a jog.

1)  the device contact boxes are clipped against each other so as to not
overlap.
2)  there is a new "BodyMinDimen" keyword that is the minimum height or width
of the trapezoids representing the device body.  This is used in
Device Block reasurements.

These are to support MOS devices with bends or jogs in the gate.  Assuming
the gate is constant width, one can use the following to get more accurate
MOS lingth/width parameters:
Length = BodyMinWidth
Width = BodyArea/BodyMinWidth


The GRpkg::SidChildHandler was broken, fastcap exec failed (Haus).

Frozen windows now display rulers and window viewport indicators.

New feature:  Frozen subwindows now display the viewport of the main window,
sort of the reverse of the Show Location function for subwindows.  This allows
a useful trick for viewing huge cells.

Suppose that you have a large design which takes a long time to render,
and you wish to examine a small part of this design (you know the approximate
coordinates).  Freeze the main window and read in the design.  Bring up
a subwindow by clicking twice outside of the cell boundary, so that the
subwindow is empty.  Freeze the subwindow, then press the Home key with
the cursor in the subwindow to center and fully view the top cell
boundary.  Use the grid and/or rulers to determine the region of interest.
Drag with button three to define a rectangle in the subwindow surrounding
the region of interest, then click with button 3 in the center of the main
window.  Un-freeze the main window, and this region will be displayed.
The region shown in the main window is shown with a dotted yellow outline
in the frozen subwindow.

Bug fixes and tweeks to the Extraction system.
1) Using the "clear" function with "Source Physical" or "Source SPICE"
was causing funny behavior and program crashes.  This should work
properly now.
2) If the internal extraction cannot complete due to an error, or if
an important error is identified such as problems in the technology
file setup, a window containing the associate.log file will pop up.
This will contain messages which should help identify the problem.
Note that lack of association is not considered an error.  It is up to
the user to make sure that the electrical and physical designs are
consistent, and that terminals get placed correctly.

The !! command input functionality was broken.

Set(name, string) will now unset the variable name if string is null, as it
presently does with the constant 0.

The Push and Pop script functions now implicitly call Commit, which avoids
subtle bugs in recursive scripts.

The !fileinfo command and CxInfo script function have some additional
information.  In the INFO_OBJCOUNTS output, the average number of
vertices, which applies to both polygons and wires, is printed.

There are two new flags:
INFO_ESTCXSIZE
    Print the size in Kb of the "archive context" structure used to
    obtain the file information.

INFO_ESTSIZE
    Print the estimated memory required to read the entire file into Xic.
    The system must be able to provide at least this much memory for
    the read to succeed.

Encountering an out-of-range layer number when reading GDSII is no longer
a fatal error.  Instead, a warning is issued, and the read continues with
the high byte set to zero.  The same applies to datatype numbers.

Revised error message handline in Device block parser.

Fixed bug, a bad Contact spec in a Device block would crash the program.

Modified resistance extraction, avoids inefficiency for resistor
contacts that cover entire resistor strip and can be much faster in certain
cases.

New variable:  FullWinCursor (boolean)
When this variable is set, the default cursor consists of horizontal and
vertical lines that extend completely across the drawing window.  The lines
intersect at the nearest snap point in the current window.

New example script for distrib: fullcursor.scr, toggles above variable.
-----------------------

FixMe:  Device block Merge keyword, unrecognized arg is now an error.
doc indicates that this case is ignored.
fixed.

In SPICE decks generated by Xic, there is a new directive ".spinclude".
This can be added by the user in a spicetext label.

Ordinarily, Xic will expand all .include directives as a final step before
shipping the SPICE text to WRspice, i.e., the .include line will be replaced
with the text of the included file.  This operation is performed recursively.

This is to accommodate the case where WRspice is running on a remote system,
and the user's files are located on the local system.  The .spinclude
pseudo-directive will simply be changed to ".include" in the spice text
shipped to WRspice, and WRspice will be expected to handle the following
file name.

Even if WRspice is running on the local system, .spinclude will allow the
file name to be resolved by the WRspice sourcepath, which is unknown to
Xic.

WRspice release 2.2.60 and later handle .spinclude as a synonym for
.include.

new FileInfo flag: F_INFO_OFFSET
This applies to F_INFO_TOPCELLS and F_INFO_ALLCELLS.  When set, the cell
name is followed by the offset of the cell definition record in the
archive file.  This is given as a decimal number enclosed in square
brackets.

new FileInfo flag: F_INFO_OFFSORT
This applies to F_INFO_TOPCELLS and F_INFO_ALLCELLS.  When set, the cells
are listed in ascending order in the file offset, i.e., the order in which
the cell definitions appear in the file.  If not set, the cells are listed
alphbetically.

The flag values have changed, to make the ordering more sane.  This affects
the script functions.

/*  This is the old order
#define F_INFO_FILENAME     0x1
#define F_INFO_FILETYPE     0x2
#define F_INFO_OBJCOUNTS    0x4
#define F_INFO_RECCOUNTS    0x8
#define F_INFO_LAYERS       0x10
#define F_INFO_ESTSKSIZE    0x20
#define F_INFO_TOPCELLS     0x40
#define F_INFO_ALLCELLS     0x80
#define F_INFO_INSTANCES    0x100
#define F_INFO_BBS          0x200
#define F_INFO_FLAGS        0x400
#define F_INFO_ESTCXSIZE    0x800
#define F_INFO_ESTSIZE      0x1000
#define F_INFO_OFFSET       0x2000
#define F_INFO_OFFSORT      0x4000
*/

#define F_INFO_FILENAME     0x1
#define F_INFO_FILETYPE     0x2
#define F_INFO_OBJCOUNTS    0x4
#define F_INFO_RECCOUNTS    0x8
#define F_INFO_ESTSIZE      0x10
#define F_INFO_ESTCXSIZE    0x20
#define F_INFO_ESTSKSIZE    0x40
#define F_INFO_LAYERS       0x80
#define F_INFO_TOPCELLS     0x100
#define F_INFO_ALLCELLS     0x200
#define F_INFO_OFFSORT      0x400
#define F_INFO_OFFSET       0x800
#define F_INFO_INSTANCES    0x1000
#define F_INFO_BBS          0x2000
#define F_INFO_FLAGS        0x4000

Don't know if this is a bug or just never worked:  Setting one of
    case GhostColor:
    case HighlightingColor:
    case SelectColor1:
    case SelectColor2:
    case MarkerColor:
    case InstanceBBColor:
    case InstanceNameColor:
    case CoarseGridColor:
    case AltCoarseGridColor:
    case FineGridColor:
    case AltFineGridColor:
from the tech file didn't work.  The Exec/Phys variants, e.g.
PhysGhostColor, would work.

Now, if one sets one of these colors, and the associated elec and phys
colors are the same, the elec and phys colors will take the new value.

todo:  When one changes a Param/Model/Value property of a cell, look thru
all the instances.  If no such property exists, or it exists and has the
old value create/change the instance property to have the new value.

Previously, when a Param property was applied to a cell, Param properties
in its instances were not changed.  A Param property is copied from
the cell to its instance only when an instance is placed.

Presently, whenever a Param property is changed in the cell, using the
Cell properties editor or otherwise, all instances of the cell are
examined and the param property is updated.
1) If an instance has no Param property or the instance Param property
text is the same as the old cell Param property, or there was no
previous cell Param property, the instance property is updated to
contain a copy of the new param property.
2) If a cell Param property is deleted, Param properties found in
the instances with matching text will also be deleted.

Probably fixed a subtle and infrequent bug in "Postscript bitmap color, encoded"
printing.  Sometimes, printing would fault with a segmentation error.
There was an out-of-range read access at an address below the data array,
which I suspect caused the problem, but I was never able to duplicate the
fault.
------------------------------------

Fixed core leak in layer expression parse tree create/destroy.

changed:
// (cx_handle) GetArchiveContext(filename, scale, save_pcinfo)
//
// This function returns a handle to a context representation obtained
// from the archive file given as the argument.  The file is opened
// from the library search path, if a full path is not provided.  The
// context representation in a data structure that provides
// information about the hierarchy in compact form, and does not use
// that main database.  The second argument is a scale factor that
// will be applied as the file is read, and must be between .001 and
// 1000.  The third argument is a boolean that causes the context to
// store extra per-cell information.  This information is used by the
// CxEstFlatMemoryUse function, and the argument should be nonzero if
// this function is going to be used with the returned context. 
// Otherwise, the third argument can be zero.
//
// The returned handle can be passed to other functions that require
// this data type.  The Close() function can be used to delete the
// context structure and free the handle.
//
// The names of cells saved in the context reflect any aliasing that
// was in force at the time the context was created.  The applicable
// aliasing is the same as if the file is read into memory with the
// Import Control panel in the Convert menu.
//
// The context refers to physical information only.
//

new:
// (real) CxEstFlatMemoryUse(cx_handle, cellname, array, counts_array)
//
// This function will return an estimate of the memory required to
// perform an OpenFlat call.  The first argument must have been
// obtained from a GetArchiveContext call with the save_pcinfo
// argument set true (nonzero).  The second argument is the name of
// the cell in the context to takes as the top-level cell.  If 0 is
// passed for this argument, the top-level cell of the context which
// appears first in the archive file will be used.
//
// The third argument is an array of size four or larger that contains
// the rectangular area as passed to the OpenFlat call.  The
// components are
//  array[0]  X left
//  array[1]  Y bottom
//  array[2]  X right
//  array[3]  Y top
// This argument can also be zero to indicate that the full area of
// the top level cell is to be considered.
//
// The final argument is also an array of size four or larger, or
// zero.  If an array is passed, and the function succeeds, the
// components are filled with the following values:
//  counts_array[0]  estimated total box count
//  counts_array[1]  estimated total polygon count
//  counts_array[2]  estimated total wire count
//  counts_array[3]  estimated total vertex count
// These are counts of objects that would be saved in the top-level
// cell during the OpenFlat call.  These are estimates, based on area
// normalization, and do not include any clipping or merging.  The
// vertex count is an estimate of the total number of polygon and wire
// vertices.
//
// The return value is an estimate, in megabytes, of the incremental
// memory required to perform the OpenFlat call.  This does not
// include normal overhead.

OpenFlat, add
// Before calling OpenFlat, the memory use can be estimated by calling
// the CxEstFlatMemoryUse function.

Obscure feature:
   If a boolean true is passed as the last arg to GetArchiveContext
   (listFSAF) then the counts in the context represent only those
   objects on layers that pass any layer filtering from the
   LayerList/UseLayerList variables.  Furthermore, in this case, the
   cell bounding boxes represent only objects on these layers, and
   subcells.  In this mode, any read with the context should use the
   same layer filtering, or the bounding boxes of cells in memory
   won't match those computed in the context.  CxEstFlatMemoryUse will
   report only the size potentially occupied by objects on these
   layers.  If this argument is false, the counts and bounding boxes
   represent all layers, i.e., layer filtering is ignored.

OpenFlat:  cellname can be 0, in which case the first top-level cell
found in the file will be used.

todo: make the dump command expand .include lines, same as sent to
spice?

takes 0 as cellname arg: (fix docs)
CxOpenFlat
CxOpenFlatDb
CxWrite
CxCellBB
CxSetArea
CxSetSkipFlag
CxSetSkipEmpties
CxEdit
CxSetupSkeleton

Temporary:  set FasterReadFlat for CxOpenFlat to use new func

In setup_extract (GJC):
   Keep the virtual terminals for lower-level circuits.  If these aren't
set, they may move to wrong nets, depending on connections.
The SYM_LIBGATE flag is set or unset here also.  The flag is set if
the cell contains virtual terminals and no regular terminals.

TODO, make expand mode-specific. (done)
TODO, !help undefined_word no feedback! (works ok now?)

Fixed bug: Peek command layer sequencing wasn't working right.

write description of LVS file format.

TODO: figure out best way to set/use SYM_LIBGATE
EX.ExtractGates not used

TODO: make attributes/Mark physical only, revise message. (done)
More of the display choices, in particular the expansion level, ane now
mode-specific, i.e., there are separate values for electrical and physical
modes.  The following new techfile keywords are recognized and potentially
created.

PhysExpand
ElecExpand
PhysDisplayAllText
ElecDisplayAllText
PhysLabelAllInstances
ElecLabelAllInstances
PhysShowContext
ElecShowContext
PhysShowTinyBB
ElecShowTinyBB

It not takes at least two chars to match a command internal name as an
accelerator.  It was too confusing to enter a command or mode after a
single character was typed, especially if the character press was
unintended.

Previous, the accelerators "sc" and "ph" would both toggle the display
mode in the main window.  Now, sc goes to electrical mode only, ph
goes to physical mode only.


The GDSII format does not support cell properties.  An extension is
used to store cell properties in electrical mode, but this extension would
destroy protability if used in physical mode.  The lack of cell property
support in physical mode breaks template cells.

Now, cell properties are saved in a dummy label.  This label is written
on layer/datatype 0/0 at the origin, and has text "CELL PROPERTIES".
This will be invisible to Xic users, but will be visible in other tools.
The label is created in cells that have cell properties, and the cell
properties are applied to the label.  The Xic reader will ignore these
labels but apply the attached properties to the cell.

This will not be written if StripForExport is set.

There is a new "Flags" cell property that can be applied to physical cells:
value 7105
The string can take one of two forms:  a hex number, or a
space-separated list of string tokens.
The tokens and corresponding bits are 
bit 0    OPAQUE   When set, the cell is "opaque" with regard to extraction.
                  The cell will look like a black box with terminals.
bit 1    CONNECTOR  Not implemented, don't use.
bit 2    USER0    User flag, not used by Xic.  These flags can be used
                  for whatever purpose the user dreams up.
bit 3    USER1
bit 4    USER2
bit 5    USER3
bit 6    USER4
bit 7    USER5

This property can be set in physical mode with the Cell Properties
editor.

!mmstats entries (is this documented?)
col 1: internal data struct name
col 2: sz, size of struct in bytes
col 3: fl, full block list length
col 4: fh, hashing width for full blocks
col 5: nfl, non-full block list length
col 6: nfh, hashing width for non-full blocks
col 7: u, bytes in use
col 8: nu, bytes available but not in use

New variable:  ExtractOpaque (boolean)
When set, Xic will ignore the OPAQUE flag and attempt to do extraction on
the contents of opawue cells.

change the counts in cv_info to int64_t.

Revised most script functions for properties,  in "Property Management by
Handles", and "Other Property Management Functions".  Mostly updated
description, but fixed up property number handling.

In the Cell Properties editor, the "Template" entry in the Add menu has been
renamed "Tmpl Script".

-----
TODO: improve ContactsOverlap

The BodyMinDim was giving incorrect results on occasion, the internal
trapezoid list needed to be merged.

The BodyMinDim would fail when the device was merged (returning zero).
----

When a cell is placed as an instance (once) and the instance was subsequently
deleted or the operation undone, the cell (now having no instances) was
not being recognized as a top-level cell.  Thus, a cell in memory could not
be deleted if it ever was instantiated.

Cell mapping for !compare, update docs to state that cell names must be
the same.

WRspice recognizes the spice command ".splib" as a synonym for ".lib".
This is for compatibility with Xic, similar to ".spinclude".  Xic will
expand .lib and .include lines in the deck before sending to spice,
so that the files are sought on the machine running Xic, not the machine
running WRspice, which may be diferent.  Xic will convert ".spinclude"
to ".include" and ".splib" to ".lib" before sending to WRspice, but not
expand the files.  In this case, WRspice will handle the file inclusions.

---

Fixed a logic problem in extraction.  Suppose that there are two device
blocks with the same name (but different prefixes).  Only one of the
devices could be associated with electrical devices of that name, leading
to LVS errors if both device types exist.  Now, this and similar
situations should work correctly.

In the LVS output file:
  The device terminals are now listed in the device associations block,
  for each device.  The terminal name and group number are to the
  left of the colon.  If the group is associated, the associated electrical
  node number (in parentheses) and name are given to the right of the colon.

  The subcircuit terminals are now listed in the subcircuit associations
  block.  The terminal name and group are to the left of the colon.
  If the group is associated, the associated electrical
  node number (in parentheses) and name are given to the right of the colon.

  Previously, if all electrical nets, devices, and subcircuits were
  associated, LVS would pass.  This could give false positives.  Now,
  LVS will fail in this case if any physical device or subcircuit instance
  is connected to an unassociated group.  Thus, unassociated groups are
  ok as long as they don't connect to devices or subcircuits.

fixed bugs:
  CoreSize script function integer overflow with more than 2Gb
  allocated.

  CxEstFlatMemoryUse script function counts_array totals were bogus.

  LVS would core dump if an electrical cell had fewer terminals than
  the physical version of the cell.

-------

The Print function from the text editor/file browser/mail client
would crash the program (Gtk versions only).

The LVS output had a logic shortcoming which was indicating a pass
condition when there were actually errors.  Even if all devices and
subcircuits are associated, the list of terminals references by each
group/net might differ, which was not being checked for.  There is
a new block in the output file XXX explain.

Note that the chip.gds example file now fails LVS.

In extraction, formal terminals will use a CONDUCTOR layer if the
associated net has no objects on a ROUTING layer.  Previously,
formal terminals would never use a non-ROUTING layer (in spite of
misleading message in the associate.log file).

The LVS output contains a field listing the formal terminals.  The
first column is the terminal name, the second column is the associated
group number (you can find the electrical node from the group/net
mapping table).  If association failed for the terminal, i.e., Xic
was unable to place the terminal in the layout, the word
"UNINITIALIZED" will appear in the third column.  This will cause
LVS to fail for the cell.

---

Fixed a bug that would cause crashes in extraction/lvs if the schematic
was changed between runs.

The subcircuit associations block in LVS output was printing incorrect
net names.

The subcircuit associations block in LVS output has a new format.

TODO: function to convert closed wire paths to polys.
TODO: make max round sides settable.

Fixed bug:  terminal lists in extraction wouldn't be updated if
 schematic changed.

The default maximum number of sides for round objects is not 255.

New variable: MaxRoundSides (integer >= 8)
This sets the maximum number of sides that can be used when creating
round objects.  This allows the user to bypass the built-in limit when
necessary.


The cell formal terminals have a new flag, which will now be saved in
cell files if set.  The purpose of this flag is to prevent Xic from
reassigning the physical location of the terminal.

This flag will be set whenever the terminal is moved by the user in
physical mode, with the Edit Terminals command.  Once moved, the terminal
should always remain in that location (which had better be correct for
extraction/LVS to succeed).

This flag can be cleared with the Edit Terminals command.  The pop-up that
appears when a terminal is clicked on contains a "Location fixed" check
box.

It is usually not necessary to place terminals manually.  Exceptions are
cells with ambiguous connections points.  For example, suppose a cell
contains a single resistor, with contacts "C1" and "C2" to the resistor.
Xic will assign the physical locations of the terminals arbitrarily, which
may not be the locations expected in a parent cell.  For example, if the
physical resistor is a vertical strip, a parent cell may expect C1 above
C2, whereas Xic might have assigned the reverse.  Now, the user can
move the terminals to the expected locations, bypassing the assignment in
Xic.

// (int) CreateSymbol(symname, [orig_x, orig_y])
//
// This will create a new symbol from the contents of the selection
// queue, with the given name, which can not already be in use.  The
// new cell is created in memory only, with the modified flag set so
// as to generate a reminder to the user to save the cell to disk when
// exiting Xic.  This provides functionality similar to the Create
// Cell button in the Edit Menu.
//
// If the optional coordinate pair orig_x and orig_y are given (in
// microns), then this point will be the new cell origin in physical
// mode only.  Otherwise, the lower-left corner of the bounding box of
// the objects will be the new cell origin.  In electrical mode, the
// cell origin is selected to keep contacts on-grid, and the origin
// arguments are ignored.

New variable:  CrsymOverwrite (boolean)
When set, The Create Symbol operation in the Edit Menu and the
CreateSymbol script function can overwrite cells already in memory.

The 45 constraint has been removed in the stretch command.  Constraining
the angle to the vertex being moved makes no sense.

New ! command:  !path2poly

This will convert selected wires to polygons representing the wire
path.  The first and last vertex of the wire must be the same.  The
width and end style of the wire are ignored.  The polygon represents
the internal area specified by the path vertices.

New ! command:  !poly2path

This will convert selected polygons to wires.  The wires have zero width,
and the first and last points are the same.  The wires follow the polygon
boundary.
------

Fixed bug: modification count of empty native cell not being reset
on write.

Gtk version: sometimes the top outline of newly created or placed
boxes wouldn't be drawn, should be fixed (call Update in dsp_box.cc).

Added an additional stage to association to catch and possibly
correct errors.

LVS can now generally be stopped with Ctrl-C.

New Variable: PhysGridOrigin (float)x (float)y
This will set the origin of the displayed grid in physical-mode
windows.  The x and y are two floating-point numbers in microns.
This applies only to the displayed grid, and specifically not to
the grid/snap used when creating or locating objects.

When an offset is active, the word "PhGridOffs" will be displayed
in the status area.
-----

New variable:  GroundPlaneGlobal (boolean)
  When set, every object in every cell on a clear-field ground plane
  layer is assigned to group 0.  If not set, only the largest area group
  on this layer in the top-level cell, is assigned to group 0.

Modification to tech file keywords:
GroundPlane [Global]
GroundPlaneDark [Global] (alias)
If the keyword Global appears, then the GroundPlaneGlobal variable will be set,
and every object on the layer will be assigned to group 0 during extraction.
----------

The resistance/inductance extractor was extensively modified to enhance
speed and flexibility.  There are four new associated variables.

Resistance extraction works by dividing the resistor logically into a regular
grid.  The center of each grid is a "node" that is connected by resistance
to adjacent nodes.  Thus, the problem becomes one of solving a large
lumped resistor mesh.

Best accuracy is obtained when the grid falls on all the resistor and contact
boundaries.  It is not possible to find such a grid in general, however
if a layout grid is used and all corners are on-grid, and all edges are
Manhattan, then tiling will be possible.  It may be the case that tiling
is possible, but the tile is so small that the computation time is
unacceptable.

For structures that can't be tiled efficiently, a set of edge-dependent
hueristics is used to modify the matrix elements to account for the
local area deficit or surplus.

There are four variables that can be used to configure the extractor.
The default values lean toward speed over accuracy.  By default,
tiling is not attempted, and the grid spacing will be selected so that
each resistor contains 1000 grid cells.


New Variable:  RLSolverDelta (floating point value >= 0.01)
It this value is set, the extractor will assume this grid spacing.  The
number of grid cells enclosed in the device will increase for physically
larger devices, so that larger devices will take longer to extract.
If this variable is set, the other RLSolver variables are ignored.
Setting this variable may be appropriate if all resistors are "small" and
dimensions conform to a layout grid.

New Variable:  RLSolverTryTile (boolean)
If set, the extractor will attempt to use a grid that will fall on every
edge of the device body and contacts.  The device and contact areas must be
Manhattan for this to work.  If such a grid can be found, and the number of
grid cells is a reasonable number, this will give the most accurate result.

New Variable:  RLSolverGridPoints  (integer 10-100000)
When not tiling (RLSolverTryTile is not set),
this sets the number of grid points used for resistance/inductance
extraction.  This number will be the same for all device structures, so that
computation time per device is nearly constant.  Higher numbers give
better accuracy but take longer.  The default value if not set is 1000.

New Variable:  RLSolverMaxPoints  (integer 1000-100000)
When tiling (RLSolverTryTile is set), the maximum number of grid cells
is limited to this value.  If the tile is too small, it will be increased
in size to keep the count below this value, in which case the tiling
will not have succeeded so there may be a small loss of accuracy.  Using
a large number of grid points can take a long time.  The default value
is 50,000.

Dismissing the html view text window (as for the !set listing) would
sometimes cause a fault.

Exiting the application with the window X button would potentially miss
certain changes made in the present command, exiting without saving.
-----

The association algorithm now uses a deterministic approach to resolving
symmetry.  When no further associations can be made because of multiple
possibilities of the same weight, Xic will inititate a "symmetry trial"
for each possibility.  If the trial fails, the associatiations made during
the trial are undone, and the next possibility tried.  The symmetry trials
are nested.  It there is an exact solution for association, Xic should
now find it.

Bad Bug:  If a command that uses the prompt line in editing mode is
started and the presently active command performs a redisplay on exit,
Xic could lock up, with every key or mouse press causing a message to
appear "Working, press Ctrl-C to exit." (but Ctrl-C does nothing).
This was noticed while in the Show Paths/Quick Paths command, and
giving the Edit command (typing "edi") while a path was displayed.
*** command idle proc is now a timeout proc.
CHECK MSW! (same problem)
----

The Quick Paths/Show Paths commands have a new feature.  When a path
is displayed, the user can click on two objects in the path, and only
the "subpath" connecting the two objects will be highlighted.  If the
two objects are connected in multiple ways, the algorithm will select
one (which may not be the most direct).  If Shift is held while clicking
on an object in the path, the object will be deselected and not considered
as part of the path.  This can be used to coerce a desired subpath.
When a subpath is displayed, clicking on any non-selected object will
display the full path containing that object.

The default selection logic when multiple objects/cells are clicked in has
changed.  Now, only one object will be selected.  By repeatedly clicking
in the same location, successive different objects under the pointer will
be selected.  Previously, all objects under the pointer would be selected.
If you don't like the new logic, the previous ligic can be restored by
setting the variable NoAltSelection.

New variable: NoAltSelection (boolean)
When set, the legacy logic is used for mouse click selection operations.

It is now impossible to select an object or subcell with mouse
operations whose boundary is completely invisible in all display windows.
Such objects can be deselected, however.


doc:  PictorialDevs General Vis to SideMenu
      selection stuff to Selections

The current transform values are now stored in CD.

New function:
// (zoidlist) TransformZ(zoid_list, refx, refy, newx, newy)
//
// Return a transformed copy of the passed trapezoid list.  The
// transform should have been set previously with SetTransform or
// equivalent.  The original list is not touched and can be closed if
// no longer needed.  The function internally converts each input
// trapezoid to a polygon, applies the transformation to the polygon
// coordinates, then decomposes the polygons into a new trapezoid
// list, which is returned.
//
// The remaining arguments are "reference" and "new" coordinates,
// which provide for translations.  The reference point is the point
// about which rotations and mirroring are performed, and is
// translated to the new location, if different.
//

If LVS fails, the associations from the "best" trial are now restored
on exit.

New ! command:  ushow [types]

This command will highlight unassociated objects.  These are objects
in physical mode that have no identified electrical counterpart, and
vice-versa.

The types argument is a word containing characters that indicate the
object types to display:
    g or n      groups/nodes
    d           devices
    s or c      subcells/subcircuits

If this argument is omitted, "gds" is the effective value, which will
show all unassociated groups, devices, and subcircuits.

The command works in physical and electrical modes.  Display windows
will highlight the appropriate unassociated objects for the window's
display mode.

The highlighting is removed on a deselect operation, with the side
menu button or otherwise.  Mostly, the objects are simply selected,
however objects such as physical devices use other highlighting code.

New variable:  NoPermute (boolean)
When this variable is set, the association algorithm will not attempt
to iterate through the combinations when searching for a solution.
Many circuits do not require a permutation search, however some
circuits, and in particular circuits where the wiring is incomplete,
may require a lot of time for the permutation search.  Of course, if
a permutation search is needed and not performed, LVS will fail.
This variable is mostly for debugging, or for cases when association
is not needed.

Permutes are also skipped if a device or subcircuit is found that
can not possibly be associated.

----

Fixed a help viewer problem (Unix/Linux only) that would cause a munged
display when jumping across a large file through named anchors.

Cleaned up the user menu command organizing a bit.
1) Duplicate script names are no longer added to menus.
2) The string placed in the button for a top-level submenu is the name
of the menu file with the ".scm" stripped off.  The libname token
given in the file ( "(Library libname);" ) is ignored.
3) Lower-level submenus use the name token provided in the parent
submenu as the button text.
4) in submenu files, a line containing the single word "nosort" will
skip alphabetical sorting of the entries, the entries will appear in the
same order as given.  Entries in the top level of the use menu are always
sorted.

The Script debugger should now save the file by default back to the
original file (if possible).  The original file will be retained with
a ".bak" extension.

Script execution has the following priority when names clash:
1) scripts defined with the !script command.
2) scripts found in the script search path and menus
3) scripts found in the technology file.

Thus, technology file script definitions can be easily overridden by
a user-generated substitute.  If the !script command is used to undefine
a script that is also defined in the tech file, the tech file definition
returns instead of deleting the script entirely.

The file ptr when writing files from the script debugger was not being
closed, meaning that the file could be incomplete until the application
terminates.
-----------------

BIG changes to cd library, see cd/NOTES.
Middling changes to parser:
   move static things to SIinterp
   no SIinterp in library
   move sBLK functions to SIinterp

Similar changes to DSP.

Fixed bug, html view would crash on png images.

After moving a terminal in physical mode, the extraction will be re-run.

Fixed bug:  The selection mechanism could hang the program.

Switching to/from the full screen cursor should no longer leave a
cursor image on-screen.
---------------------------

A bug in the Windows release would crash the program at times during
screen refresh.

The plot and iplot button logic was not quite right.

----------------------------
During association, spurious  messages
"XXX is not associable, skipping permutations"
could be put in the associate.log file.

If adding a prefix or suffix in cell r/w, the prefix or suffix is now not
added to names that already have this prefix/suffix.

Assemble changes:
name aliasing is no applied to the top-level cells.
it is now possible to specify a name change via "Place cellname [newname]"
if the same cell name is named more than once:
    if it is different from the previous spec, it and its hierarchy will
      be auto-renamed and placed.  Otherwise, it will be a simple instance
      of the previously processed cell.
    different means any of the following differ between the specs:
       newname
       NoEmpties
       Flatten
       window usage
       window, if using window
       clip
    
Final "ext" arg now gone.
// (int) StreamSource(stream_handle, file_or_context, scale, layer_list,
//     use_layer_list, layer_aliases, cname_prefix, cname_suffix, ccvt)

!assemble Extract keyword now does nothing (but still accepted).  Extraction
is performed if any cells are given.

Fixed a bug that would cause crashes in certain commands, such as stretch,
when interactive DRC is enabled.
---

New no_empties variable
// (int) CxWrite(cx_handle, scale, cellname, array, clip, all, flatten,
// no_empties, outfile)

// (int) CxSetSkipEmpties(cx_handle, cellname, [left, bottom, right, top])
//
// This will set the skip flags of all physical cells in the hierarchy
// under cellname that contain no readable geometry or non-empty
// subcells.  If the optional box coordinates are given (in microns),
// the skip flags will be set for cells that have no geometry or
// subcells containing geometry that would appear in the area given,
// reflected to the top-level cell of the hierarchy.  This is useful
// when windowing is to be employed with clipping but not flattening,
// which can generate empty cells that otherwise wouldn't be caught.
//
// This will examine the source file to determine cell content, and
// takes into account the current layer filtering.  It can be called
// before writing (though CxWrite has its own flag for this purpose)
// or opening the hierarchy to remove empty cells.  The return value
// is 1 on success, 0 otherwise.
//

// (int) SetConvertFlags(use_window, clip, flatten, no_empties)
//
// This function sets the status of flags used in format conversions. 
// The four arguments coorespond to the Use Window, Clip to Window,
// Flatten Hierarchy, and No Empties buttons in the Conversion pop-up. 
// A nonzero integer value will set the flag, 0 will reset the flag.
//
// This function returns the previous value of the internal variable
// that contains the flags.  The bits are:
//    flatten       0x1
//    use_window    0x2
//    clip          0x4
//    no_empties    0x8


New !assemble file keyword:
    PlaceTop [placement_name]
// # The PlaceTop line is equivalent to a Place line, except that it
// # will automatically select the first top-level cell found in the
// # source.  It is equivalent to the Place line with the name of
// # this cell as the first argument.  This is convenient when the
// # cell name is unknown,
-----------------------

// (int) CxOpenOdb(cx_handle, scale, cellname, array, clip, dbname)
//
// This function will create a "special database" of the objects read
// through the handle.  The coordinates will be scaled by scale as
// read.  The cellname is the name of the top-level whose hierarchy
// is to be read from the context.  If this argument is zero, the
// first top-level cell found in the corresponding archive file will
// be understood.  The array, if not 0, is an array of four values or
// larger giving a rectangular area of cellname to read.  The values
// are in microns, in order L,B,R,T.  If zero, the entire cell
// bounding box is understood.  If the boolean value clip is nonzero,
// objects will be clipped to the array, if given.  The dbname is a
// string which names the database.  This can be any short name
// string.  The database can be retrieved or cleared using this name.
//
// The return value is 1 on success, 0 otherwise.

// (int) CxOpenZdb(cx_handle, scale, cellname, array, clip, dbname)
//
// This function will create a "special database" of the trapezoid
// representations of objects read through the handle.  The
// coordinates will be scaled by scale as read.  The cellname is the
// name of the top-level whose hierarchy is to be read from the
// context.  If this argument is zero, the first top-level cell found
// in the corresponding archive file will be understood.  The array,
// if not 0, is an array of four values or larger giving a
// rectangular area of cellname to read.  The values are in microns,
// in order L,B,R,T.  If zero, the entire cell bounding box is
// understood.  If the boolean value clip is nonzero, trapezoids will
// be clipped to the array, if given.  The dbname is a string which
// names the database.  This can be any short name string.  The
// database can be retrieved or cleared using this name.
//
// The return value is 1 on success, 0 otherwise.

// (object_handle) GetObjectsOdb(dbname, layer_name, array)
//
// This returns a handle to a list of objects, extracted from a named
// database created with CxOpenOdb.  The first argument is a database
// name string as given to CxOpenOdb (This function will not work
// with CxOpenZdb).  The second argument is a string containing a
// space-separated list of layer names, or 0.  Objects for each of
// the given layers will be obtained.  Objects on the same layer will
// be grouped together, and groups ordered as in the layer_list.  If
// this argument is 0, all layers will be used, ordered bottom-up as
// in the layer table.  The third argument is an array, as passed to
// CxOpenOdb, or 0.  If 0, all objects for the specified layers in
// the database will be retrieved.  Otherwise, only those objects
// with bounding boxes that overlap the array rectangle with nonzero
// area will be retrieved.  The objects retrieved are copies of the
// database objects, which are not affected.

// (zoidlist) GetZlistDb(dbname, layer_name, zoidlist)
//
// This returns a zoidlist associated with a layer, extracted from a
// named database created with CxOpenOdb or CXOpenZdb.  The first
// argument is a database name string as given to CxOpenOdb or
// CxOpenZdb.  The second argument is the associated layer name.  The
// third argument is an array, as passed to the CxOpenOdb or
// CxOpenZdb function, or 0.  If 0, all trapezoids for the layer in
// the database will be retrieved.  Otherwise, only those trapezoids
// with bounding boxes that overlap the array rectangle with nonzero
// area will be retrieved.  The trapezoids retrieved are copies of
// those in the database, the database objects are not affected.  If
// the database was created from CxOpenOdb, the objects in the
// database are used to generate the trapezoids.  Otherwise, the
// trapezoids are copies of those in the database.

// DestroyDb(name)
//
// This function will free and clear the special database named in the
// argument.  This is the database name as given to CxOpenOdb or
// CxOpebZdb.  If the argument is 0, then all special databases will
// be freed and cleared.  This function always returns 1.

// CxShowDb(dbname, array)
//
// This function will pop up a window displaying the area given in
// the array of the special database named in dbname.  This database
// must have been opened with CxOpenOdb or CxOpenZdb.  The array
// argument is in the same format as passed to CxOpenDb or CxOpenZdb. 
// If passed 0, the bounding box containing all objects in the
// database is understood.  The return value is the window number of
// the new window (1-4) or -1 if an error occurred.

new zdb_t, same as odb_t for Zoids.

New FileInfo flag: DEPTHCNTS
When given, a table of instance counts for hierarchy depth is printed.
In the counts, single instances and arrays receive a unit count.

// ShowSymbolic(show)
//
// This sets of unsets symbolic display mode of the electrical part
// of the current cell, according to the state of the boolean
// argument.  The return value is always 1.  The function has no
// effect if an active symbolic representation of the cell does not
// exist.
//


Converted DspIf interface to register functions.

Got rid of crypt directory.  This is not in parser, executables in src/bin.

new file: dsp_hlpr.h.  cdxic.h is no longer used in dsp.


// (zoidlist) RepartitionZ(zoid_list)
//
// This is a rather obscure function that conditions a list of
// trapezoids so that the area covered will be constructed with
// trapezoids that are as long (horizontally) as possible.  Logically,
// this is what would happen if the initial trapezoid list was
// converted to distinct polygons, then split back into trapezoids.
//

New cell properties storage mechanism in GDSII files.
The GDSII format has no provision for storing properties of cell definitions.
In Electrical mode, a format extension is used.  We can't use extensions
in physical mode, since that would make the files non-portable, so we have
to fake it.

In previous releases, the cell properties were applied to a dummy label
on layer/datatype 0/0 with text "CELL_PROPERTIES".  This label would be
created in cells with properties and written in GDSII output.  When reading
in the GDSII file, the label would be ignored, and the properties from the
label object would be applied to the containing cell.

However, when using direct conversions, the file would be converted
as-is, so that if converting to Xoc native cell files (for example),
the converted cells would contain the "CELL_PROPERTIES" labels and would
not have the properties set.

The present release no longer creates a "CELL_PROPERTIES" label.  Instead,
it creates a "SNAPNODE" record with a PLEX number 0xffffff, on layer 0
with nodetype 0.  This is an obscure data type that is more likely to be
invisible in the database.  Unlike a label, it should not be visible in
most readers.

The present release reader will still process the CELL_PROPERTIES label
if found, for backwards compatibility.  In addidion, it will also process
these labels, and the node records, when doing direct conversions, so
that the properties are assigned correctly in this case.

Neither is generated if strip for export active.

Files read with older versions will not process cell properties, and will
have "unsupported record type PLEX" warnings in the log file.

The grid was not being saved in created files in some places.

The !fileinfo command will now separate list cells that are unresolved,
i.e., instantiated but not defined in the file.

The default value for the MaxPrpLabelLen value is not 256.  This effectively
disables the "feature" where long properties are not shown as text but
as a small box.  Users found this confusing.  A better way to hide long
labels is to convert to a "long text" label.  This can be done on a
per-label basis.
1) Select the label.
2) Press the side menu "label" button (with the black 'T').
3) Press the gray 'L' button that appears to the left of the prompt line.
This will cause the text editor to appear, loaded with the label text.
If there is no 'L' button, then the property can't use long text, which
is true for properties that are "always" short, such as for device and model
names.
4) In the text editor, press Save in the File menu.  The editor will
disappear, and the label displayed on-screen will have changed to "[texx]".

To convert back to a normal label:
1) Select the long-text label ("[text]").
2) Press the side menu "label" button  (with the black 'T').
3) With the cursor under "[text]" on the prompt line, press the Delete
key.  The full label text will appear on the prompt line.
4) Press Enter.  The label will be shown normally.

* The html viewer would crash in named anchor sybtax errors.

The gds-text reader is now in a separate file.
----------------------------------------------

Added range args to the archive-to-text functions.  Only GDS works
presently.  When using the Convert panel, the used will be prompted
for the string.

The NumToTxtCells will cause this string to default to "-c value".

additional arg:
// (int) ToTxt(archive_file, text_file, cmdargs)
//
// This command will create an ascii text file text_file from the
// contents of the archive file.  The human-readable text file is
// useful for diagnostics.  If text_file is null or empty, the name is
// derived from the archive_file and given a ".txt" extension.  No
// output is produced for CIF, since these are already in readable
// format.

// The third argument is a string, which can be passed to specify the
// range of the conversion.  If this argument is passed 0, or the
// string is null or empty, the entire archive file will be converted. 
// The string is in the form
//
//   [start_offs[-end_offs]] [-r rec_count] [-c cell_count]
//
// The square brackets indicate optional terms.  The meanings are
//
//   start_offs
//     An integer, in decimal or "0x" hex format (a hex digit
//     preceded by "0x").  The printing will begin at the first record
//     with offset greater than or equal to this value.
//
//   end_offs
//     An integer in decimal or "0x" hex format.  If this value
//     is greater than start_offs, the last record printed is at most
//     the one containing this offset.
//
//   rec_count
//     A positive integer, at most this many records will be printed.
//
//   cell_count
//     A non-negative integer, At most the records for this many
//     cell definitions will be printed.  If given as 0, the records
//     from the start_offs to the next cell definition will be
//     printed.
//
// The function returns 1 on success, 0 otherwise with an error
// message possibly available from ErrorMsg.

Misc. numerical bug fixes in the FastHenry interface.

todo: extract, save the trials and results, and reestablish the one with
 the best match if all fail.
todo:
XICP_INST and name_map && sNameMap, WTF?

TODO: mouse-wheel scrolling
TODO MSW license file doesn't work for multiple machines? (Eric N)
TODO:  clearly state windowing before scaling.
TODO: script functons
  obj_handle->db
  list layers
  db->obj_handle (all layers)
TODO: make Convert Import layer list work with layer table names.
TODO:  make is possible to write flat and/or windowed archives from
    database.
TODO: comparison function for areas of different layout files.
-----------------------

Xic can now handle semi-transparently GDSII layers/datatypes in the
range 0-65535.  The Cadence documentation for the GDSII format specifies
that these numbers should be in the range 0-255, however the file
format reserves 16 bits for these values and some vendors have supported
an extended range.

All of the inputs to Xic can now take 0-65535 as the range for layer and
datatype.  This includes the Stream keywords in the technology file,
and inputs to the various conversion functions.

The hex code for a layer/datatype can take one of two forms:
    LLDD
    LLLLDDDD
where in either case the Ls are hex numbers representing the layer, and
the Ds represent the datatype.  The equivalent decimal notation L,D also
applies, with L and D in the range 0-65535.

When reading an archive file and a layer or datatype is encountered in
the non-standard range that can't be mapped to an existing layer, the
following happens:
   1) A Ned Xic layer is created, with a unique four-character (non-hex)
      name.
   2) The "longname" field of the new layer is assigned the 8-character
      hex code (LLLLDDDD).
   3) The internal GDSII input/output layer mappings are applied to the
      layer.

Thus, unlike the in-range case, created layers don't have a hex name,
as non-standard values don't fit into four characters, but instead the
longname takes the hex value.  This will also be the case for in-range
values if the hex name layer alread exists and has a non-compatible
mapping.

A warning message is inserted into the translation log file on the first
occurrence of each layer/datatype pair containing non-standard values.

The longname for a layer can be seen with the Convert/Edit Parameters
menu selection.


for !fileinfo, the flags argument can now be a space or comma-separated
list of tokens (the list should be quoted if it contains space).  The
tokens can be *hex* integers, or the following keyword equivalents:
    filename,     0x1
    filetype,     0x2
    objcounts,    0x4
    reccounts,    0x8
    estsize,      0x10
    estcxsize,    0x20
    estsksize,    0x40
    layers,       0x80
    topcells,     0x100
    allcells,     0x200
    offsort,      0x400
    offset,       0x800
    instances,    0x1000
    bbs,          0x2000
    flags,        0x4000
    depthcnts,    0x8000
    unresolved,   0x10000
    all,          -1),

If not given or given as 0, all flags except for allcells, instances, and
flags are taken as set.  This avoids printing the lengthly cells/instances
list by default.  The keyword all or value -1 can be used to obtain all
available information.

// (string) FileInfo(filename, handle_or_filename, flags)
// The third argument is an integer or string that specifies the
// information to return.  See the description of the CxInfo function
// for information about this argument and the corresponding output.

// (string) CxInfo(cx_handle, handle_or_filename, flags)
changes made

bug fixed: in layer expressions, unary minus was not being recignized,
so e.g., !layer new = bloat(-0.1, "CWP", 1) would give a parse error
(the work-around was to use 0-0.1)

In erase command, for polys, each poly that is is partially erased has
the remaining pieces joined.  Previously, the pieces became separate
objects.
rewrite to use zoid clipping.

The spatial model binning for mos L/W parameters, as in WRspice,
should now work from Xic.
todo TEST THIS

The internal functions that inplement the !bloat command operation have
been revised.

The mode integer is now interpreted as follows:
   bits 0-1    values 0-4 specify the algorithm mode, as in previous
               releases.
   bit 2       When set, the return is the edge trapezoid collection,
               used to for the bloated objects.  This only works for
               modes 0-2 and when bit 3 is not set.
   bit 3       When set, the mode calls the "old" bloating algorithms,
               as used in previous releases.

The new algorothm works as follows.
1)  The collection of objects to bloat are converted to a trapezoid
    representation.
2)  The resulting trapezoid list is grouped into multiple lists of
    spatially disjoint lists, where each list is mutually connected
    and no trapezoid touches or overlaps andother trapezoid from
    another list.
3)  For each list, the line segments representing the trapezoids are
    tabulated.
4)  The edge list is clipped against itself to remove mutually
    overlapping regions.  The remaining edges are the "external"
    edges, where one side is area outside of the trapezoid group.
5)  Each edge is converted to a rectangle that covers the edge and
    extends +/- the bloat width normal from the edge (note that these
    rectangles are rotated by an arbitrary angle, depending on the
    angle of the line segment).
6)  The rectangles are converted to trapezoids.  The non-Manhattan
    rotated rectangles are represented by three trapezoids.
7)  A polygon, implemented as trapezoids, is added at each vertex,
    to fill in the transition between edge segments.
    The list of all these trapezoids represents a path along the
    external edges of the original trapezoid group.
8)  If the bloat value is positive, the edge list is or'ed with the
    original trapezoid list.  If the bloat value is negative, the
    edge list is clipped from the original trapezoid group.
    if bit 3 is set, this step is skipped, and the edge list is passed
    to the next step.
9)  The resulting trapezoid list is merged into polygons, representing
    the operation result.

bloat mode 0:
    The polygon to fill the empty area at a vertex between the segment
    rectangles is computed exactly.

    If a trapezoid group is entirely Manhattan, meaning that all edges
    are horizinatl or vertical, no vertex additions take place.  Instead,
    the vertical line segments are extended by the (positive) bloat
    dimension.  Thus, bloated Mnahattan objects always remain Manhattan.

bloat mode 1:
    This mode is faster, but is not recommended for non-Manhattan
    geometry.  The vertical segment ends are extended by the bloat dimension
    to cover (assumed) Manhattan corners.  Non-Mahhattan segments are
    added as a single trapezoid with a width computed from the bloat
    dimension.  Note that this can cause small protrusions and other
    anomalies to appear after bloating.

bloat mode 2:
    This is the same as bloat mode 0, however the corners of Manhattan
    and non-Manhattan objects will be treated the same.  The corners of
    positive-bloated boxes will be rounded, unlike mode 0.

bloat mode 3:
    In this mode, bits 2 and 3 are ignored.  The algorithm is the same
    as the previous mode 3, where the DRC system is used to implement the
    bloat.  This is very slow, but takes into account objects in the database
    that are not selected, unlike other modes.
    

New modality in the !checkgrid command.

The !checkgrid command is really two commands in one.  The first mode
checks objects in the current cell, and will mark off-grid vertices
on-screen.  The second mode will check vertices to all levels of the
hierarchy.

If the first character of the argument string is '-', the second mode
will be used.  An argument containing a single '-' is valid to enforce
this.  The other possible arguments are listed below.  All of these are
optional.

The command will look at objects in the hierarchy, and if an object vertex
would appear off-grid in the top-level cell, it will be listed in an
output file.

-l layer_list

The argument is a space-separated list of layer names, which should be
quoted if it contains more than one entry.  Only objects on the listed
layers will be checked, or if -s is also given objects on layers not
listed will be checked.  If no given, all layers will be used.

-s

If a layer_list was given, objects on these layers will be ignored.

-g spacing

The spacing, in microns, is the assumed grid spacing.  If not given,
the value from the current grid setting will be used.

-b L,B,R,T

This specifies a retangular region in the current cell where testable
objects will be searched for.  If not given, the entire cell will be
searched.  The coordinates are in microns, separated by commas with no
white space.

-t bpw_string

This is a string consisting of one or more of the letters "b", "p", and
"w".  This indicates the type of objects to test: boxes, polygons, and
wires.  If not given, "bpw" is assumed.

Note: only the lower left and upper right vertices of boxes are tested,
since the other two are redundant.

-d depth

This sets the maximum hierarchy depth to search for objects.  If not given,
all levels of the hierarchy will be searched.  A zero value would search
only the current cell.

-f output_file_name

This sets the name of the output file, which will contain a sorted list
of ogg-grid vertices.  If not given, the name of the current cell,
suffixed with "_vertices.log", will be used.  If the name is "stdout",
output will go to the standard output (console window).

---------------------------

FOO!  the CV flags has to fit in a byte, was defined
#define CVskip  0x1
#define CVcif   0x4
#define CVsrf   0x8
#define CVbb    0x10
#define CVbbok  0x20
#define CVaset  0x40
#define CVaok   0x80
#define CVgeom  0x100

increased the field size to a short int


Touch-ups for device merging in extract.  Shorted devices are now
never merged (these could cause errors).  The assumed nodes are
printed in Compute Params, since these may be ambiguous.

When resistor networks are merged, Xic will merge series resistors
if there are no other connections at the common node.  Sometimes,
this will lead to a configuration that is not intended or desired,
for example when the desired end terminal of the network is connected
to two resistors only, that node might be merged away.  One way to
prevent this from happening is to use temporary virtual terminals.
1) switch to electrical mode.
2) enter the subct command.
2) press Ctrl and click anywhere in the drawing window.  A terminal
marker will appear.  Press Enter, and switch back to Physcal mode.
3) Select Extract/Edit Terminals.  A terminal mark should appear
   to the lower left of the bounding box of the current cell.
4) Use Shift-button1 to move the terminal mark to the desired
   network end terminal metal.

This node now has a (phony) terminal, so it won't be merged.
Don't forget to go back and delete the terminal when done.

The internal database for instance transforms and array specs was
revised.  The new archive requires less memory.

The instance transformation lists used in archive context structs
uses a new compressed format by default.  This can shrink the memory
used by the context by 50% or more, but requires a little more
computational overhead.

The archive files written by the WriteArchiveContext script function or
similar use the compressed transformation lists by default.  These
files have a new magic number and can not be read by older versions of
Xic.

There is a new variable:
    (boolean) NoCompressContext
When set, archive context structs will not use compression, and files
produced by WriteArchiveContext will be backwards compatible (though
probably larger).

reltag.h is now included in CD.  There is a new preprocessor symbol
defined in cd.h:  CD_RELEASE_NUM.  This is set to a number
25<release>[.<re-release index>].  This is a number composed from the
CVS release tag, e.g., xic-2-5-66-1 -> 2566.1, xic-2-5-67 -> 2567.
Later releases will always have a CD_RELEASE_NUM larger than earlier
releases.  This is intended to be used to enforce versioning in
third-party applications that import CD.


New keyword to the !fx command (FastCap/FastHenry interface)

!fx merge save_file

This will merge the contents of the file into the present database.  If
there are presently no objects in the database, this is the same as
!fx recall.

In general, all existing partitioning will be lost.  This is always
true of FastHenry data.  The polygons from the file will be merged
with existing polygons on the same layer if they touch or overlap,
or added if they are isolated.  All partitioning will be recreated.

For FastCap data, it is possible for some of the existing partitioning
to be retained.  This requires:
1) imported polygons can touch but do not overlap existing polygons
   on the same layer (this is automatically applied).
2) Via areas must be defined entirely in one data set or the other,
   e.g., the top and bottom layers can't be in different datasets.
   If they are, the via won't be created.  It is up to the user to enforce
   this.

If these conditions apply, then the existing partitioning of the conducting
objects will be retained.  The dielectric interface partitioning, however,
is not retained, and will be recreated.  The user must refine this if
necessary.

This functionality is available only from the !fx command, and not the
graphical pop-up.
----

new command: !attrclear

Clears the internal database used to consolidate instance attributes.
For debugging.

new command: !stclear

Clears the string table, for debugging purposes.

The files listing should now show symbolic links.

Hi Arthur,

I'm looking at the issue that you reported.  I remember now that I saw 
this before and it drove me nuts trying to get around this.  It is
just how the Windows widget works.

The window for the pop-up menu is a fixed height, but the entries can
scroll (but this is not obvious).  When there are more than about 10
entries, there will be unseen entries on the top or bottom.  There are
two ways to scroll the entries (tha I know of):
1) Press and hold the mouse button on the menu down button on the place
   panel next to the master name.  Then, move the pointer near the top 
   or bottom of the menu that pops up.  This should cause the entries
   to scroll, in the direction that makes the unseen entries at the    
   top or bottom to become visible.  Release the mouse button with the
   pointer over the chosen item.
2) Click on the menu down button on the place panel.  The menu will
   appear.  When the menu is visible, pressing the up or down arrow
   keys will scroll the menu entries.  Click on the item to choose.

I can't figure out how to scroll with the mouse in #2 above, perhaps
there is a way.  This is how Microsoft designed this component, and
it is not apparent how to/if I can change the behavior.

Using either of these methods you should be able to scroll up to the
"New Entry" entry.

Regards,
Steve


The constraint logic was turned back on during stretch.  Add some doc
since Constrain-45 can be counter-intuitive.

update to transform stack, new file cd_transform.h.  Transform no longer
uses malloc.

Script syntax change:
Handle variables and relational binary operators (==, !=, <, <=, >, >=).
Previously, the handle was treated as a scalar, with the value being
an internal id number assigned to the handle.

This is still true when two handles are applied to the relational operators.
Thus, one can tell if two handles are identical (point to the same data).
One can also tell which handle was created later, which will be the larger
value since the internal ids are assigend sequentially.

However, when a handle and a scalar are applied to these operators,
both are interpreted as booleans.  If the handle is active and points to data,
it is true.  If the scalar is nonzero when rounded to an integer, it is
true.  Actually, the "scalar" can be any object type that can be interpreted
as a boolean.  A string is true unless it is null, for example.

This solves a problem:

Consider a handle h.  One can iterate through the list of items that the
handle references with

    while (h)
        (do something)
        h++
    end

However, the form

    while (h != 0)
        (do something)
        h++
    end

would previously cause an infinite loop.  Now, both forms are equivalent.


Modified the !area command:
If nothing is selected, acts as before.  Otherwise it separately
reports the total area of all geometry and all subcells currently
selected, in square microns.  Areas are totals of each selected
object or subcell, overlap is not taken into account.
Labels are ignored.

New command: !perim
The total perimeter, in microns, of all selected objects and subcells
is printed.
-----

Bug fixed: electical mode bas broken due to new layer cache table in
GDSII/OASIS reading.

Bug Fixed:  Cell properties in GDS were not being cleared in electrical
mode due to new SNAPNODE processing code.


The multi-mapping capability, where there is not a 1-1 correspondence
between objects in files and objects in the database, is now controlled
by a variable and is disabled by default.  It is possible to set up
the GDSII/OASIS layer/datatype mapping so that
1.  Objects on a given layer/datatype found in a file can be mapped to
    (created in) more than one Xic layers.
2.  Objects on a given Xic layer can be written multiple times in
    GDSII/OASIS output, using a different layer/datatype combination
    for each instance of the object.

The use of multi-mapping can have serious consequences over a cycle of
reading a file into Xic and writing an updated file, namely the number
of objects will multiply.  It is possible that the user may
inadvertently apply the same GDSII mapping to two layers in the tech
file, for example, and find later that there are many coincident
objects generated.  For this reason, this feature is turned off by
default.

New variable:  MultiMapOk (boolean)
When set, multiple input/output GDSII layer/datatype mapping to Xic
layers is enabled (as was always the case in Xic releases prior to
2.5.67-5).  This allows objects in GDSII/OASIS files to be created on
more than one Xic layers, and objects on Xic layers to be instantiated
more than once in GDSII/OASIS output files (each with a different
layer/datatype).  When not set, each object is created or written once
only, using the forst mapping in the list that applies (First layer or
StreamOut keyword found).


The CellThreshold is effectively 1.0 in electrical mode.

Fixed problem with converted label size in oasis->other formats.

Fixed problem with cif-> other format conversion.

Updated hlpsrv, hlp2html, xtjobs to compile again and seemingly run.
-----------------

Fixed bug: crash on conversions with windowing and no flattening.

read_flat was broken for polys

in GDSII/OASIS, end style 4 wires are now converted to end style 0 (flush
ends).  Previously, these were converted to end stule 3 (extended ends).
This was a problem since not all endsyyle 4 wires could be represented as
endstyle 2.  Fixed a bug where if a two-vertex wire had identical endpoints,
the bounding box computation would be bogus.

In Paths/Quick Paths, Xic is now "working" while the path is being
extracted.  Previously, it was possible to start a new path extraction
before the previous extraction was complete, which could cause faults.

Fixed a lot of problems in pathfinder, including some memory issues
which would cause faults.

Revised the build environment to support Apple OS X universal binaries.

Fixed a bug that could cause instability when moving objects.


---
OasWriteRep x option 10 - 50000, max objects held before flush;
default 5000.

New variable: OasWriteUseFastSort (boolean)
   When set, writing OASIS may be faster at the expense of file
   size.  This was the the only mode in previous releases.  The
   present release defaults to using a somewhat slower but more
   effecitve algorithm, which should produce smaller files.

New variable: OasWriteNoXicTextPrps (boolean)
   When set, properties that are added to labels that are used by Xic
   are not written.  These are
   XXX   this contains a test string containing values for the source
         GDSII file that are not used by Xic.  It is used when back-
         converting to GDSII;
   YYY   This contains the size and transform used by Xic for rendering
         the label.

The file header information is now cached in the archive context,
avoiding having to read this again when the file is read through
the context.
