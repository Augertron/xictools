
//-------------------------------------------------------------------------
//  xclient.cc
//-------------------------------------------------------------------------
//  Demo client for Xic server access
//  Whiteley Research Inc. - public domain free software, no restrictions
//  January 19, 2003
//  Updated: February 12, 2008
//  $Id: xclient.cc,v 1.6 2015/11/01 22:22:32 stevew Exp $
//-------------------------------------------------------------------------
//
// This is an example illustrating how to interface to an Xic server
// in C/C++.  Although written in C++, translation to C should be
// straightforward.  The program generated by this file simply
// connects to an Xic server, and allows the user to interact.  This
// file is an example only, but can serve as a starting point for
// creating an interface for your proprietary application.

// To compile:
//    Linux/FreeBSD:   gcc -o xclient xclient.cc
//    Solaris:         gcc -o xclient xclient.cc -lnsl -lsocket
//    mingw:           gcc -o xclient xclient.cc -lwsock32 -lws2_32
//
// To run: 
//    start Xic server with xic -S
//    xclient [hostname] [portnum]
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <errno.h>
#include <ctype.h>
#ifdef WIN32
#include <winsock2.h>
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#endif

// These might already be defined in sys/types.h
typedef int int32_t;
typedef unsigned int u_int32_t;

// The WIN32 defines are for the MINGW version of gcc running on
// Windows.

#ifdef WIN32
#define CLOSESOCKET(x) shutdown(x, SD_SEND), closesocket(x)
#else
#define CLOSESOCKET(x) close(x)
#endif

// Port and service name used by Xic in server mode.
#define XIC_SERVICE     "xic"
#define XIC_PORT        6115
// These are registered with IANA.

// Response codes used in server replies.
enum RSPtype
{
    RSP_OK,
    RSP_MORE,
    RSP_ERR,
    RSP_SCALAR,
    RSP_STRING,
    RSP_ARRAY,
    RSP_ZLIST,
    RSP_LEXPR,
    RSP_HANDLE,
    RSP_GEOM,
    RSP_CMPLX
};

// This is ored with the RSPtype to indicate a "longform" return.
//
#define LONGFORM_FLAG 0x80


// Open a connection to the Xic server running on host through the
// given port.  Either argument can be 0, in which case a default is
// assumed.  On success, a socket descriptor is returned, otherwise -1
// is returned.
//
int
open_xic(const char *host, int port)
{
#ifdef WIN32
    // initialize winsock
    WSADATA wsadata;
    if (WSAStartup(MAKEWORD(2, 2), &wsadata) != 0) {
        fprintf(stderr,
            "Windows Socket Architecture initialization failed.\n");
        return (-1);
    }
#endif

    if (!host)
        host = "localhost";
    if (port <= 0) {
        servent *sp = getservbyname(XIC_SERVICE, "tcp");
        if (sp)
            port = sp->s_port;
    }
    if (port <= 0)
        port = XIC_PORT;

    hostent *hent = gethostbyname(host);
    if (!hent) {
        perror("gethostbyname");
        return (-1);
    }

    int sd = socket(AF_INET, SOCK_STREAM, 0);
    if (sd < 0) {
        perror("socket");
        return (-1);
    }
    sockaddr_in skt;
    memset(&skt, 0, sizeof(sockaddr_in));
    memcpy(&skt.sin_addr, hent->h_addr, hent->h_length);
    skt.sin_family = AF_INET;
    skt.sin_port = htons(port);
    if (connect(sd, (sockaddr*)&skt, sizeof(skt)) < 0) {
        perror("connect");
        CLOSESOCKET(sd);
        return (-1);
    }
    return (sd);
}


// Send a message to the Xic server.
//
int
to_xic(int skt, char *string)
{
    if (!string)
        return (-1);
    return (send(skt, string, strlen(string), 0));
}


// The return from the server may specify a variable, so we define a
// structure here to describe the variable.  The variable can have
// the following types:
//  notype          variable not typed, generally undefined
//  scalar          a single floating-point value
//  string          a text string
//  array           an array of floating-point values
//  zlist           a list of trapezoids
//  lexpr           a layer expression (returned as a string)
//  handle          a handle to an object
//  comples         a complex number (2 floating-point values)

// The type field.
//
enum Vtype
{
    Vnotype,
    Vscalar,
    Vstring,
    Varray,
    Vzlist,
    Vlexpr,
    Vhandle,
    Vcmplx
};

// Trapezoid
//
struct Zoid
{
    int xll;
    int xlr;
    int yl;
    int xul;
    int xur;
    int yu;
};

// Complex number.
//
struct Cmplx
{
    double real;
    double imag;
};

// Description of a variable.
//
struct Variable
{
    Vtype type;
    int asize;
    bool data_ok;
    union {
        double value;
        Cmplx cx;
        int handle;
        char *string;
        double *values;
        Zoid *zoids;
    } content;
};


// Data Conversion and Byte Order
//
// When the server is using binary mode, the ancient problem of
// byte-order arises.  Xic uses "network byte order" for integers,
// which is the networking standard and conversion functions (man
// byteorder) exist for any sane operating system.  Floating point
// data doesn't seem to have the same level of support, so we have to
// roll our own (ntohd() below).  The user need only remember the
// following:
// for integers: apply ntohl()
// for doubles:  apply ntohd()

// Note: IEEE floating point is assumed here!

// Convert from "network byte order" which is defined here as
// the same order Sun (sparc) uses (reverse that of I386)
//
static double
ntohd(double dn)
{
    union { double d; unsigned char s[8]; } u, uh;
    u.d = 1.0;
    if (u.s[7]) {
        // This means MSB's are at top address on this host, reverse
        // bytes.
        u.d = dn;
        unsigned char *s = uh.s;
        for (int i = 7; i >= 0; i--)
            *s++ = u.s[i];
        return (uh.d);
    }
    else
        return (dn);
}


// Read nbytes bytes from skt.  This won't quit until it gets
// nbytes bytes, or the socket is closed or an error occurs.
//
static bool
read_n_bytes(int skt, unsigned char *buf, int nbytes)
{
    unsigned char *s = buf;
    while (nbytes) {
        int ret = recv(skt, s, nbytes, 0);
        if (ret < 0) {
            if (errno != EINTR) {
                // read error
                fprintf(stderr, "read_n_bytes: read error\n");
                return (false);
            }
            // got interrupt, retry
            continue;
        }
        if (ret == 0) {
            // server has closed connection
            fprintf(stderr, "read_n_bytes: connection closed\n");
            return (false);
        }
        nbytes -= ret;
        s += ret;
    }
    return (true);
}


// This will read a response from the server, based on the server's
// protocol.
//
// Response messages:
//    numeric vals are MSB first, strings include trailing \0
//  (int32) 0                               ok
//  (int32) 1                               in block, waiting for "end"
//  (int32) 2                               error
//  (int32) 3 (double64) <val>              scalar data
//  (int32) 4 (int32) <strlen+1> <string>   string data
//  (int32) 5 (int32) <numelts>  <values>   array data
//  (int32) 6 (int32) <numzds>   <values>   zlist data
//  (int32) 7 (int32) <strlen+1> <string>   lexpr data
//  (int32) 8 (int32) <id>                  handle data
//  (int32) 9 (int32) <datalen>  <data>     geom data
//  (int32) 10 (2*double64) <real><imag>    complex data
//
static bool
read_msg(int skt, int *id_ret, int *size_ret,
    unsigned char **msg_ret)
{
    *id_ret = -1;
    *size_ret = 0;
    *msg_ret = 0;

    int32_t id;
    if (!read_n_bytes(skt, (unsigned char*)&id, 4))
        return (false);
    id = ntohl(id);
    bool longform = false;
    if (id & LONGFORM_FLAG) {
        longform = true;
        id &= ~LONGFORM_FLAG;
    }
    if (id < RSP_OK || id > RSP_GEOM) {
        fprintf(stderr, "read_msg: unexpected message id %d\n", id);
        return (false);
    }

    *id_ret = id;
    if (id >= RSP_OK && id <= RSP_ERR)
        return (true);
    if (!longform && id != RSP_GEOM)
        return (true);

    if (id == RSP_SCALAR) {
        // Scalar data.
        unsigned char *msg = new unsigned char[8];
        if (!read_n_bytes(skt, msg, 8))
            return (false);
        *size_ret = 8;
        *msg_ret = msg;
        return (true);
    }

    int32_t size;
    if (!read_n_bytes(skt, (unsigned char*)&size, 4))
        return (false);
    size = ntohl(size);

    if (id == RSP_STRING || id == RSP_LEXPR || id == RSP_GEOM) {
        // String data, size includes null terminator.
        // Lexpr data, size includes null terminator.
        // Geom data.
        if (size < 0) {
            fprintf(stderr, "read_msg: inconsistent record size\n");
            return (false);
        }
        // We'll accept a null string, though this shouldn't happen.
        if (size > 0) {
            unsigned char *msg = new unsigned char[size];
            if (!read_n_bytes(skt, msg, size))
                return (false);
            *msg_ret = msg;
        }
        *size_ret = size;
    }
    else if (id == RSP_ARRAY) {
        // Array data, size is number of elements.
        if (size < 0) {
            fprintf(stderr, "read_msg: inconsistent record size\n");
            return (false);
        }
        // We'll accept a null array, though this shouldn't happen.
        if (size > 0) {
            size *= 8;  // size in bytes
            unsigned char *msg = new unsigned char[size];
            if (!read_n_bytes(skt, msg, size))
                return (false);
            *msg_ret = msg;
        }
        *size_ret = size;
    }
    else if (id == RSP_ZLIST) {
        // Trapezoid data, size is number of trapezoids.
        if (size < 0) {
            fprintf(stderr, "read_msg: inconsistent record size\n");
            return (false);
        }
        // We'll accept a null list, though this shouldn't happen.
        if (size > 0) {
            size *= 24;  // 6*4 bytes per trapezoid
            unsigned char *msg = new unsigned char[size];
            if (!read_n_bytes(skt, msg, size))
                return (false);
            *msg_ret = msg;
        }
        *size_ret = size;
    }
    else if (id == RSP_HANDLE) {
        // Handle data, size is handle id.
        *size_ret = size;
    }
    else if (id == RSP_CMPLX) {
        // Complex data.
        unsigned char *msg = new unsigned char[16];
        if (!read_n_bytes(skt, msg, 16))
            return (false);
        *size_ret = 16;
        *msg_ret = msg;
    }
    return (true);
}


// This function reads the response from the Xic server, and if the
// response describes a variable, the variable data are filled in. 
// The return value is a code indicating the response type:
//
int
from_xic(int skt, Variable *v)
{
    // Set the variable to "undefined" and initialize
    v->type = Vnotype;
    v->asize = 0;
    v->data_ok = false;
    v->content.value = 0.0;

    // Read the message.
    int id, nbytes;
    unsigned char *msg;
    if (!read_msg(skt, &id, &nbytes, &msg))
        // socket read error
        return (-1);

    if (id == RSP_OK)
        // "ok", return
        ;
    else if (id == RSP_MORE)
        // "more", return
        ;
    else if (id == RSP_ERR)
        // "error", return
        ;
    else if (id == RSP_SCALAR) {
        // "scalar"
        v->type = Vscalar;
        if (nbytes == 8) {
            v->content.value = ntohd(*(double*)msg);
            v->data_ok = true;
        }
    }
    else if (id == RSP_STRING) {
        // "string"
        v->type = Vstring;
        if (nbytes > 0 && msg) {
            // The size includes the null terminator.
            char *str = new char[nbytes];
            memcpy(str, msg, nbytes);
            v->content.string = str;
            v->data_ok = true;
        }
    }
    else if (id == RSP_ARRAY) {
        // "array"
        v->type = Varray;
        if (nbytes >= 8 && msg) {
            // Each element is 8 bytes.
            int asize = nbytes/8;
            double *arry = new double[asize];
            unsigned char *p = msg;
            for (int i = 0; i < asize; i++) {
                arry[i] = ntohd(*(double*)p);
                p += 8;
            }
            v->asize = asize;
            v->content.values = arry;
            v->data_ok = true;
        }
    }
    else if (id == RSP_ZLIST) {
        // "zlist"
        v->type = Vzlist;
        if (nbytes >= 24 && msg) {
            // Each element is 24 bytes (6x4).
            unsigned char *p = msg;
            int sz = nbytes/24;
            Zoid *z = new Zoid[sz];
            for (int i = 0; i < sz; i++) {
                z[i].xll = ntohl(*(int32_t*)p);
                p += 4;
                z[i].xlr = ntohl(*(int32_t*)p);
                p += 4;
                z[i].yl = ntohl(*(int32_t*)p);
                p += 4;
                z[i].xul = ntohl(*(int32_t*)p);
                p += 4;
                z[i].xur = ntohl(*(int32_t*)p);
                p += 4;
                z[i].yu = ntohl(*(int32_t*)p);
                p += 4;
            }
            v->asize = sz;
            v->content.zoids = z;
            v->data_ok = true;
        }
    }
    else if (id == RSP_LEXPR) {
        // lexpr", looks like a string
        v->type = Vlexpr;
        if (nbytes > 0 && msg) {
            char *str = new char[nbytes];
            memcpy(str, msg, nbytes);
            v->content.string = str;
            v->data_ok = true;
        }
    }
    else if (id == RSP_HANDLE) {
        // handle
        v->type = Vhandle;
        if (nbytes > 0) {
            v->content.handle = nbytes;
            v->data_ok = true;
        }
    }
    else if (id == RSP_GEOM) {
        // geometry stream data from "geom" command.
        if (nbytes > 8 && msg) {
            int32_t *ii = (int32_t*)msg;
            int csz = ii[0];
            csz = ntohl(csz);
            int usz = ii[1];
            usz = ntohl(usz);
            // csz: compressed size of data
            // usz: uncompressed size of data
            // The data starts at msg+8, the length is csz if nonzero,
            // else usz, and is also nbytes-8.
            // If csz is 0, the data are not compressed.
            // The data consists of OASIS geometry records, as in a
            // CBLOCK if csz is nonzero.

            // Here, we compose a dummy variable to return.
            v->type = Vstring;
            char tbuf[128];
            sprintf(tbuf, "geometry stream csz=%d usz=%d", csz, usz);
            v->content.string = strdup(tbuf);
            v->data_ok = true;
        }
    }
    else if (id == RSP_CMPLX) {
        // "complex"
        v->type = Vcmplx;
        if (nbytes == 16) {
            v->content.cx.real = ntohd(*(double*)msg);
            v->content.cx.imag = ntohd(*(double*)(msg+8));
            v->data_ok = true;
        }
    }

    delete [] msg;
    return (id);
}


// The main function.  The invocation is
//  progname [hostname] [portnum]
//
int
main(int argc, char **argv)
{
    char *hostname = 0;
    if (argc > 1)
        hostname = argv[1];
    int port = 0;
    if (argc > 2)
        port = atoi(argv[2]);
    int skt = open_xic(hostname, port);
    if (skt < 0) {
        fprintf(stderr, "Open failed, exiting.\n");
        return (1);
    }

    // drain initial prompt
    Variable v;
    int rsp = from_xic(skt, &v);
    if (rsp < 0) {
        fprintf(stderr, "Recv failed, exiting.\n");
        return (1);
    }

    fprintf(stdout, "ok> ");
    fflush(stdout);

    char buf[256];
    char *msg = 0;
    for (;;) {

        // Get a line of input
        fgets(buf, 256, stdin);

        if (buf[0] == 0x1b) {  // Esc
            char c = 0;
            send(skt, &c, 1, MSG_OOB);
            fprintf(stdout, "interrupted> ");
            continue;
        }

        // strip line termination
        char *t = buf + strlen(buf) - 1;
        while (t >= buf && (*t == '\n' || *t == '\r'))
            t--;

        // Allow line concatenation with trailing backslash
        bool saveline = false;
        if (*t == '\\') {
            *t = '\n';
            saveline = true;
        }
        else {
            // add network line termination
            t++;
            *t++ = '\r';
            *t++ = '\n';
        }
        *t = 0;

        if (!msg) {
            msg = new char[strlen(buf) + 1];
            strcpy(msg, buf);
        }
        else {
            t = new char[strlen(msg) + strlen(buf) + 1];
            strcpy(t, msg);
            strcat(t, buf);
            delete [] msg;
            msg = t;
        }
        if (saveline)
            continue;

        // Send line to Xic
        if (to_xic(skt, msg) < 0) {
            fprintf(stderr, "Send failed, exiting.\n");
            return (1);
        }

        // Read and process the response.  Here is where the user can add
        // code to make use of returned data.  In this example, we simply
        // print the data type and a bit of the data (if any).

        rsp = from_xic(skt, &v);

        // It is important to do a read on the socket after issuing a
        // kill command, otherwise if we shut down our end too early,
        // the server will get a closed connection error and not die.

        if (!strncmp(msg, "close", 5) || !strncmp(msg, "kill", 4))
            break;
        delete [] msg;
        msg = 0;

        if (rsp < 0) {
            fprintf(stderr, "Recv failed, exiting.\n");
            return (1);
        }
        if (rsp == RSP_OK)
            fprintf(stdout, "ok> ");
        else if (rsp == RSP_MORE)
            fprintf(stdout, "-?> ");
        else if (rsp == RSP_ERR)
            fprintf(stdout, "error> ");
        else if (rsp == RSP_SCALAR) {
            if (v.data_ok)
                fprintf(stdout, "scalar %g\nok> ", v.content.value);
            else
                fprintf(stdout, "scalar\nok> ");
        }
        else if (rsp == RSP_STRING) {
            if (v.data_ok) {
                int n = strlen(v.content.string);
                if (n > 64)
                    strcpy(v.content.string + 61, "...");
                fprintf(stdout, "string %s\nok> ", v.content.string);
                delete [] v.content.string;
            }
            else
                fprintf(stdout, "string\nok> ");
        }
        else if (rsp == RSP_ARRAY) {
            if (v.data_ok) {
                fprintf(stdout, "array, %d values: ", v.asize);
                for (int i = 0; i < 5; i++) {
                    if (i == v.asize)
                        break;
                    fprintf(stdout, " %g", v.content.values[i]);
                }
                if (v.asize > 5)
                    fprintf(stdout, "...");
                fprintf(stdout, "\nok> ");
                delete [] v.content.values;
            }
            else
                fprintf(stdout, "array\nok> ");
        }
        else if (rsp == RSP_ZLIST) {
            if (v.data_ok) {
                fprintf(stdout, "zlist, %d zoids: ", v.asize);
                if (v.asize) {
                    Zoid *z = v.content.zoids;
                    fprintf(stdout, "%d %d %d %d %d %d", z->xll, z->xlr,
                        z->yl, z->xul, z->xur, z->yu);
                    if (v.asize > 1)
                        fprintf(stdout, " ...");
                }
                fprintf(stdout, "\nok> ");
                delete [] v.content.zoids;
            }
            else
                fprintf(stdout, "zlist\nok> ");
        }
        else if (rsp == RSP_LEXPR) {
            if (v.data_ok) {
                fprintf(stdout, "lexpr %s\nok> ", v.content.string);
                delete [] v.content.string;
            }
            else
                fprintf(stdout, "lexpr\nok> ");
        }
        else if (rsp == RSP_HANDLE) {
            if (v.data_ok)
                fprintf(stdout, "handle %d\nok> ", v.content.handle);
            else
                fprintf(stdout, "handle\nok> ");
        }
        else if (rsp == RSP_GEOM) {
            if (v.data_ok) {
                fprintf(stdout, "%s\nok> ", v.content.string);
                delete [] v.content.string;
            }
            else
                fprintf(stdout, "geom\nok> ");
        }
        else if (rsp == RSP_CMPLX) {
            if (v.data_ok) {
                fprintf(stdout, "complex (%g,%g)\nok> ", v.content.cx.real,
                    v.content.cx.imag);
            }
            else
                fprintf(stdout, "complex\nok> ");
        }
        fflush(stdout);
    }
    CLOSESOCKET(skt);
    return (0);
}

