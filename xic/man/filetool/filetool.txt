
FileTool Reference Manual
Whiteley Research Inc.
Sunnyvale CA

DRAFT 0 4/7/09
Whiteley Research Inc. Proprietary - Not for Distribution
$Id: filetool.txt,v 1.2 2009/04/08 05:39:25 stevew Exp $


Contents
--------

1       Introduction

2       Command Line Options
        2.1     Setting Variables

3       Assemble Script File Evaluation

4       Obtaining File Infromation

5       ASCII Text Representation of Layout Files

6       Layout File Comparison
        6.1     Common Options
        6.2     Per-Cell Object Mode Options
        6.3     Per-Cell Geometry Mode Options
        6.4     Flat Mode Options

7       Layout File Splitting

8       Layout File Merging and Translation
        8.1     Assemble File and Option Argument Format
            8.1.1   Header Block
            8.1.2   Source Blocks
            8.1.3   Source Block Directives
            8.1.4   Placement Blocks
            8.1.5   Placement Block Directives


1. Introduction
---------------

The FileTool is a command-line program for analysis and manipulation
of layout files.  It is intended to be incorporated in the user's
automation scripts to implement complicated manipulations on layout
files, and as an aid to understanding content and diagnosing problems
with layout files.

Here are some of the tasks that the FileTool can perform:

  o  Print information about a layout file: statistics, layers used,
     top-level cell, etc.

  o  Translate layout files, or parts of layout files, to an ASCII
     text representation.

  o  Compare two layout files, listing the differences.

  o  Split a layout file into multiple files, each representing 
     a portion of the original layout.

  o  Combine cells from multiple layout files into a single file.

  o  Convert between file formats (CIF, CGX, GDSII, OASIS are
     supported).

  o  When writing, many different translation modes are available:
     layer filtering and aliasing, cell name mapping operations, windowing
     with or without clipping, flattening, scaling, empty cell removal.

  o  Generate or process assemble scripts as used by the Xic
     !assemble command.

The file formats supported by the FileTool are:

GDSII
The industry standard stream format.  Any release level is supported for
input.  For output, the default release level is 7, but this can be
set to earlier levels.  Compressed (gzipped) GDSII files can be read
or written.

OASIS
The emerging standard, which provides more compact data files than
GDSII.  Any conforming OASIS file can be read as input.  A number of
options affect OASIS output.

CGX
A compact data representation developed by Whiteley Research Inc.
Compressed (gzipped) CGX files can be read or written.

CIF
The obsolete but still used CIF format.  Any known dialect should work
as input.  The output dialect can be selected via options.

Input files can be any of these file types, the format is recognized
by context.  Output files can also be any of these file types, but the
format is specified by the extension of the file name.

The operations can be saved to a script file, or read from a script
file.  The script file format is the same as used by the !assemble
command in Xic, thus scripts generated by the FileTool can be executed
in Xic.


2. Command Line Options
-----------------------

If FileTool is executed without arguments, a synopsis of available
command line options is printed.  Otherwise, the arguments are given
in one of the following forms.

filetool
  [-set var[=value] ...]
  -eval script_file_to_read |
  -info layout_file [flags] |
  -text layout_file [text_opts] |
  -comp layout_file1 layout_file2 [comp_opts] |
  -split split_opts |
  translate_opts


2.1 Setting Variables
---------------------

There are a number of internal variables which control various properties
of the file readers/writers, translation modes, etc.  These are the same
variables as used in Xic.  In some cases, these variables are overridden
by command line options, but in cases where no applicable option exists,
these variables can be set to provide the desired effect.

The -set options must appear first on the command line, and unlike the
other "main" directives in the listing above, can appear ahead of the
other directives.  These are optional.

The format can take two forms: either a single -set option followed by
a quoted list of name=value pairs:

   -set "name1=value1 name2 name3=value3 ..."

or, each name=value pair can have its own "-set":

   -set name1=value1 -set name2 -set name3=value3

Note that the value part is optional, for boolean variables.  The token
following each "-set" must not contain white space, or be quoted if
it contains white space, e.g.,

   -set "name = value"

is legitimate.

The following variables have relevance:

XXXXXXX list variables


3. Assemble Script File Evaluation
----------------------------------

Assemble script files can be produced by Xic, and contain a
specification for complicated operations on layout files, such as
merging several files into a single output file, while creating a new
top-level cell to contain instances of the cells read from input. 
These files can be evaluaated with the FileTool.

The command is of the form

    filetool [-set variables] -eval script_file

The FileTool will read and execute the script, reading input and
generating output as per the directives in the script file.

The script file format is described in 8.1.


4. Obtaining File Information
-----------------------------

In this mode, the FileTool will read a layout file, and print useful
information about the file.  The command line for this mode is

    filetool [-set variables] -info filename [flags]

It is unlikely that the -set variables will be used with this option,
though the layer filtering options may apply on occasion.

The optional following argument is an integer or string which
determines the type of information to return.  If an integer, the bits
are flags that control the possible data fields and printing modes. 
The string form is a space or comma-separated list of text tokens
(from the list below, case insensitive) or hex integers.  The hex
numbers or equivalent values for the text tokens are or'ed together to
form the flags integer.

If this argument is 0 or not given, all flags except for allcells,
instances, and flags are implied.  Thus, the sometimes very lengthly
cells/instances listing is skipped by default.  To obtain all
available information, pass -1 or "all" as the flags value.

The following table provides the keywords and equivalent hex values.

    filename (0x1)

      Print the name of the archive file for which the information
      applies.

    filetype (0x2)

      Print a string giving the format of the archive file:  one of
      "CIF", "CGX", "GDSII", or "OASIS".

    scale (0x4)

      This is unused, and will always print "1.0".

    alias (0x8)

      This is unused.


    reccounts (0x10)

      Print a table of the counts for record types found in the
      archive.  This is format-dependent.

    objcounts (0x20)

      Print a table of object counts found in the archive file.  The
      table contains the following keywords, each followed by a
      number.

      Records           Total record count
      Symbols           Number of cell definitions
      Boxes             Number of rectangles
      Polygons          Number of polygons
      Wires             Number of wire paths
      Avg Verts         Average vertex count per poly or wire
      Labels            Number of (non-physical) labels
      Srefs             Number of non-arrayed instances
      Arefs             Number of arrayed instances

    depthcnts (0x40)

      A table of the number of cell instantiations at each hierarchy
      level is printed, for each top-level cell found in the file. 
      The count for depth 0 is 1 (the top-level cell), the count at
      depth 1 is the number of subcells of the top-level cell, depth 2
      is the number of subcells of these subcells, etc.  Arrays are
      given one count, the same as a single instance.

    estsize (0x80)

      This flag will enable printing of the estimated memory required
      to read the entire file into Xic.  The system must be
      able to provide at least this much memory for a read to succeed.

    estchdsize (0x100)

      Print an estimate of the memory required by the present CHD.

      By default, a compression mechanism is used to reduce the data
      storage needed for instance lists.  The NoCompressContext
      variable, if set, will turn off use of compression.  If
      compression is used, the extchdsize field will include
      compression statistics.  The "ratio" is the space actually used
      to the space used if not compressed.

    layers (0x200)

      Print a list of the layer names encountered in the file.  For
      GDSII and OASIS files, the name will be a four-digit hex number
      specifying the layer number and datatype number as LLDD.

    unresolved (0x400)

      This will list cells that are referenced but not defined in the
      file.  These will also be listed if allcells is given.

    topcells (0x800)

      List the top-level cells, i.e., the cells in the file that are
      not used as a subcell by another cell in the file.  If allcells
      is also given, only the names are listed, otherwise the cells
      are listed including the offset, instances, bbs, and flags
      fields if these flags are set.  The list will be sorted as per
      offsort.

    allcells (0x1000)

      All cells found in the file are listed by name, including the
      offset, instances, bbs, and flags fields if these flags are also
      given.  The list will be sorted as per offsort.

The following flags apply only if at least one of topcells or allcells
is given.

    offsort (0x2000)

      If this flag is set, the cells will be listed in ascending order
      of the file offset, i.e., in the order in which the cell
      definitions appear in the archive file.  If not set, cells are
      listed alphabetically.

    offset (0x4000)

      When set, the cell name is followed by the offset of the cell
      definition record in the archive file.  This is given as a
      decimal number enclosed in square brackets.

    instances (0x8000)

      For each cell, the subcells used in the cell are listed.  The
      subcell names are indented and listed below the cell name.

    bbs (0x10000)

      For each cell the bounding box is shown, in L,B R,T form.  For
      subcells, the position, transformation, and array parameters are
      shown.  Coordinates are given in microns.  The subcell
      transformation and array parameters are represented by a
      concatenation of the following tokens, which follow the subcell
      reference position.  These are similar to the transformation
      tokens found in CIF, and have the same meanings.

      MY                Mirror about the x-axis.
      Ri,j              Rotate by an angle given by the vector i,j.
      Mmag              Magnify by mag.
      Anx,ny,dx,dy      Specifies an array, nx X ny with spacings dx,dy.

    flags (0x20000)

      This will display some flag values, none of which are used.

    all (0xffffffff)

      This enables all flags.


5.  ASCII Text Representation of Layout Files
---------------------------------------------

The supported file formats other than CIF are binary, and thus the
content is not easy to decipher.  This mode of the FileTool will convert
records from a layout file into an ASCII representation.  This may be
valuable for identifying problems in the file or understanding file
organization and content.

For this mode, the command takes the form:

    filetool [-set variables] -text layout_file
        [-o output_file] [start[-end]] [-c cells] [-r recs]

Following the layout file path, there are optional arguments.

    -o output_file

      If this is given, the text output will be placed in the supplied
      file name.  Without this option given, text output is to the
      standard output.

The remaining arguments control the range of text conversion.  Without
these options, the entire file will be written as ASCII text.  For all
but tiny layout files, the user will probably want to limit the size
of the output.

    [start[-end]]

      The start and end are file offsets, which can be given in
      decimal or "0x" hex form.  Printing will start with the first
      record with offset greater than or equal to start.  If end is
      given, the last record printed will be at most the record
      containing this offset.  If both numbers are given, they must be
      separated by a '-' with no white space.

    -c cells

      This options supplies a count, indicating the number of cell
      definitions that will be printed.  If the count is 0, and start
      is also given, the records from start to the end of the cell
      definition will be printed.

    -r recs

      This provides a count of the number of records to print. 
      Printing will stop after the indicated number of records have
      been output.

Printing will start at the beginning of the file or the start record
if given, and will end at the end of file or the point at which the
first end condition is satisfied.

There are two variables which may be of interest when using this mode.
These can be set with "-set" options ahead of the "-text" argument.

    OasPrintNoWrap
    Value: boolean

      This applies when converting OASIS input to ASCII text.  When
      set, the text output for a single record will occupy one
      (arbitrarily long) line.  When not set, lines are broken and
      continued with indentation.

    OasPrintOffset
    Value: boolean

      This applies when converting OASIS input to ASCII text.  When
      set, the first token for each record output gives the offset in
      the file or containing CBLOCK.  When not set, file offsets are
      not printed.


6.  Layout File Comparison
--------------------------

This mode compares the geometry and instance placements in cells from
two cell hierarchies, usually from different files.  The results are
written to a log file.

The command line format for this mode is

    filetool [-set variables] layout_file1 layout_file2 [comp_opts]


The layout file that is listed first is the "reference" when the list
of cells to compare is generated, so there is an asymmetry that should
be kept in mind, which will be further discussed with the cell list
entry below.

Beyond the layout file names, there is a large number of arguments
that are applied to set various modes and provide further input. 
These arguments must be given as separate tokens, and all start with a
'-' symbol.

There are three basic comparison modes.  The per-cell object mode
compares cell content object-to-object.  A difference will be
indicated if a given object does not have an exact counterpart in the
other cell.  The per-cell geometry mode does not look at objects, but
rather considers the area occupied by the objects.  Thus, differences
will be indicated only if the covered area differs.  The third
comparison mode logically flattens the hierarchy before comparing the
geometry.  Thus, differences will be indicated only if the flat
geometry (i.e., the mask layout) differs.

The results are written to a file named "diff.log" in the current
directory.  Each object or region that appears in one cell and not the
other corresponding cell is written in a CIF-like format to the log
file, unless the -d (diff only) option is given.  The !diffcells
command in Xic can be used to create cells from the log file for
visualizing the differences.

6.1 Common Options
------------------

The following options apply to all comparison modes.

    -c1 cellname ...

      This is a list of cell names found in layout_file1.  If more
      than one name appears, the list should be quoted using
      double-quote marks.

    -c2 cellname ...

      This is a list of equivalent cell names found in layout_file2. 
      If more that one name appears, the list should be quoted using
      double-quote marks.

      The actual list of cells to compare is generated by logic to be
      described.  The first layout file is taken as the "reference"
      for cell list creation.

      Generally, there is only one list of cells to compare, and each
      cell is sought in both sources.  If a cell is found in one
      source and not the other, this will appear in the log file, but
      is not considered to be an error.

      The exception to the single list rule is when cell names appear
      in the -c2 "equivalence" list.  If a -c2 list is given, there
      must be exactly the same number of entries given in the -c1
      list.  The cells in the two lists will be compared term-by-term,
      in order.  This is how one can compare cells with differing
      names.  In all other cases, the -c2 list should not appear.  It
      is an error if -c2 is given without -c1, or the list lengths
      differ.  The -c2 list is ignored if in per-cell comparison mode
      and the -h (recurse) option is given.

      The interpretation of a non-existing -c1 list depends on the
      comparison mode.  If in flat comparison mode, or in a per-cell
      mode and the -h (recurse) option is given, then the assumed cell
      list contains only the default cell from the first layout file
      given.

      In the other cases, a missing -c1 list is interpreted as all
      cells found in the first layout file given.

      In the per-cell modes with -h (recurse) option given, each entry
      in the -c1 list is hierarchically expanded to a full list of the
      cells under the given cell, and these names are merged into a
      new list that contains no duplicates.  If no -c1 list was given,
      per the discussion above, the cell list is effectively the
      hierarchy of the default cell from the first layout file.

      The "default cell" from the layout file is the first top-level
      cell found in the file.

    -l layer_list

      The layer_list is a space-separated list of layer names, which
      must be quoted if more than one layer appears.  If no layer_list
      is given, all layers will be checked for differences.

    -s

      If a layer_list is given, differences will be recorded in all
      layers except the layers in the layer_list.


    -d

      Don't record the actual differences, only whether or not the
      cells differ.

    -r max_diffs

      The integer max_diffs sets the maximum number of differences to
      allow before the comparison terminates.  If not given or given a
      value 0, there is no limit.  Beware that errors in the cell list
      could potentially lead to enormous output, so it is usually
      advisable to put a limit on the number of differences recorded.

The following options set the comparison mode.  The per-cell
comparison modes are generally faster and use less memory than the
flat mode, since only the geometry from the two cells being compared
is called into memory.  The flat mode is required if the two layouts
have differences in hierarchy.

    -g

      When -g is given, per-cell geometric comparison is used.  All
      "real" objects (boxes, polygons and wires) are considered when
      comparing geometry, text labels are ignored.

    -f

      The -f option indicates flat comparison mode, and will supersede
      -g if also given.  In flat comparison mode, geometry is
      logically flattened before comparison.

    If neither -f or -g appears in the argument list, per-cell object
    mode is used.

6.2  Per-Cell Object Mode Options
---------------------------------

    -t obj_types

      The obj_types is a word containing any or all of the letters
      c,b,p,w,l which indicate cells, boxes, polygons, wires, and
      labels.  The letters indicate the types of objects that will be
      considered.  If this option is not given, the default is cbpw,
      i.e., labels are ignored.

    -x

      Expand subcell arrays (if comparing subcells).  Cell arrays are
      converted to individual placements before comparison, avoiding
      false errors between arrayed and equivalent unarrayed layouts.

    -h

      The cell list is expanded so that all cells in the hierarchy
      under the given cells are compared.  The first source given is
      used to extract the hierarchy cells.

    -e

      If -e is given, electrical cells will be compared.  Otherwise,
      physical cells are compared.
  
6.3  Per-Cell Geometry Mode Options
-----------------------------------

All of the options for per-cell object mode are available and have the
same function, except that the only code that is considered for -t is
"c".  By default, subcell checking is not enabled.  If enabled ("-t c"
is given), then subcell placements are checked as in per-cell object
mode.

When using per-cell geometry mode, the geometry is compared within
areas of a grid whose size is given by the PartitionSize variable. 
Experimenting with this size can lead to improved speed, depending on
the layout density.  The default partition size is 100 microns.  For
best performance, this can be increased for low density, or reduced
for high density, where "density" refers to the number of trapezoids
per area.

6.4  Flat Mode Options
----------------------

None of the per-cell options apply in flat mode, though with the
exception of -e if given they will be benignly ignored.  Flat mode
applies only to physical data, and if -e is given, an error will
result.

    -a L,B,R,T

      The -a option specifies the rectangular area where comparison is
      performed.  If not given, comparison is performed over the
      entire cell area of both cells.  The word that follows -a
      consists of the four rectangle cordinate values, in microns,
      separated by commas.  There can be no white space.

The flat geometry mode is somewhat orthogonal to the other modes.  The
algorithm uses two levels of gridding to partition the layout into
pieces, and directly compares the geometry in each fine grid cell.

    -i fine_grid

      This sets the size of the fine grid used for comparison.  The
      geometry in each fine grid cell is compared.  The value is in
      microns in the range 1.0 - 100.0, if not given 20.0 is used.

    -m coarse_mult

      This sets the size of the coarse grid, as an integer multiple of
      the fine grid size.  The coarse grid size is the chunk size for
      reading geometry into memory.  Once in memory, the geometry is
      split into the fine grid cells and compared.  Using too large of
      a coarse grid can cause memory exhaustion for dense layouts, but
      on the other hand a larger coarse grid size usually improves
      speed.  The user should experiment to find the best values for
      the fine and coarse grid for their layouts.  The acceptable
      range for this parameter is 1 - 100.  If not given, 20 is used.


7.  Layout File Splitting
-------------------------

The FileTool can be used to split a large layout file into a collection
of smaller layout files.

For splitting, the command line takes the form:

    filetool [-set variables] -i filename -o basename.ext
      [-c cellname] -g gridsize [-b bloatval] [-w l,b,r,t] [-f] [-cl] [-e]

This mode will write output files corresponding to the partitions of a
square grid logically covering all or part of a specified cell in a
given layout file.  The output files contain physical data only. 
These files can be flat or hierarchical.

The arguments are as follows:

    -i filename

      This mandatory argument specifies a path to a layout file, or a
      path to a saved CHD file.  This source will provide cell data as
      input.

    -o basename.ext

      This mandatory argument provides the base name of the output
      files that will be created, and the type of file to write. 
      There are generally two components of the argument, separated by
      a period.  The basename component may be absent, but the period
      must remain.  If the basename is absent, the name of the
      top-level cell being split will be used. 

      The ext, which follows the period, must be one of the following
      to indicate the file format to be used for output.

        CGX     .cgx
        CIF     .cif
        GDSII   .gds, .str, .strm, .stream
        OASIS   .oas

      The GDSII and CGX extensions can be fillowed by ".gz", which
      will indicate gzip compression.

      The file names produced will have the form

        basename_X_Y.ext

      where X and Y are the indices of the corresponding grid cell.

    -c cellname

      This optional argument specifies the name of the cell to be used
      as the top-level in output.  If not given, this will be the
      first top-level cell found in the input file, or, if the input
      source is a CHD, the default cell configured into the CHD will
      be used.

    -g gridsize

      This mandatory argument specifies the length, in microns, of the
      side of a square grid cell.  The area to be written will be
      tiled with a grid of this size, with the origin at the lower
      left corner.  Each grid cell with nonzero overlap area with the
      area to be written will have a corresponding output file
      produced.

    -b bloatval

      This optional argument specifies how much, in microns, the grid
      cells will be bloated before the write operation.  If positive,
      the grid cells will be expanded, and the files will logically
      overlap.  The value can also be negative, which will leave
      logically unwritten area between output files.

    -w l,b,r,t

      This specifies a rectangular region, in the cell being written,
      which will be gridded and written to output files.  If not
      provided, the entire cell area is understood.  The four numbers
      are given in microns, separated by commas, with no intervening
      white space.

    -f

      If this flag is given, the output files will be flat.  All
      geometry will be contained in the top-level cell of each file. 
      Be aware that this can consume a lot of disk space.

      If not given, the output files will maintain the hierarchy of
      the original file.  In this mode, only the geometry needed to
      fully render the area of the top-level cell corresponding to the
      (possibly bloated) grid cell area is retained.  Subcells may
      therefor contain only part of the original geometry, or may not
      appear at all if not instantiated within the area.  Subcells may
      also become empty, these are not automatically stripped.

    -cl

      This flag will cause geometry to be clipped at the (possibly
      bloated) grid cell boundaries.  This applies whether flattening
      or not.  Note that when not flattening, clipping does not
      guarantee that geometry is confined to the clip area.

    -e

      This flag will turn on empty cell filtering.  When not
      flattening, due to the nature of the algorithm, it is possible
      that empty cells will be produced in output.  These generally do
      no harm, but they consume space.

The command will create a temporary CHD, if necessary.  Each grid
region is written out sequentially, in the manner of windowing from
the Conversion panel from the Convert Menu in Xic.


8.  Layout File Merging and Translation
---------------------------------------

The FileTool can take a list of arguments which correspond logically
to the keywords of an assembly specification script.  The argument list
begins after any "-set" variables present.

This automates reading of cells from archives, subsequent processing,
and writing to a new archive file.  It provides the capabilities of
the Conversion panel in the Convert Menu in Xic, such as format
translation, windowing, and flattening.  Additionally, multiple input
files and cells can be processed and merged into a larger archive,
on-the-fly or by using a Cell Hierarchy Digest (CHD) so as to avoid
memory limitations.  Cell definitions for the read and possibly
modified cells are streamed into the output file, and the output file
can contain a new top-level cell in which the cells read are
instantiated.  The input and output can be any of the supported
archive formats (CGX, CIF, GDSII, OASIS), in any combination.

The same operations can be controlled by a specification script file,
the path to which is given as the argument following "-eval".  The
script uses a language which will be described.  This supplies the
output file name and the description of the top-level cell (if any),
the files to be used as input, the cells to extract from these files,
and the operations to perform.  It is a simple text file, prepared by
the user, containing a number of keywords with values.  The
specification script can also be obtained from the Assemble command in
the Convert Menu, which is a graphical front-end to the !assemble
command in Xic.

Alternatively, the argument list can consist of a series of option
tokens and values.  These are logically almost equivalent to the
language of the specification file.  This gives the user the option to
enter job descriptions entirely from the command line.  These
command-line options start with a '-' character.

Only physical data are read, electrical data will be stripped in
output.  A log file is produced when the command is run.  This is
named "assemble.log" and is written in the current directory.  The log
file contains warning and error messages emitted by the readers during
file processing, and should be consulted if a problem occurs.

8.1  Assemble File and Option Argument Format
---------------------------------------------

The command parses and executes a specification file or option list in
the format described below.  The file text contains keyword directives
and values which specify the operations to be performed.  Each active
line begins with a keyword, and all keywords are case-insensitive. 
Blank lines and lines that begin with non-alpha characters are taken
as comments and are ignored.  Unrecognized tokens will generate an
error and no processing will be done.  There is an almost one-to-one
correspondence between file keywords and equivalent command-line
options.  For options that require a string, the string can be
double-quoted ("..."), and these must be quoted if they contain
white-space.

The command input can either come from a file, or from the
command-line arguments, but not both.

Overall, the input logically contains three levels of directives:

    Header Block
    Source Block
      [Placement Block]
      [...]
    [...]

The Header Block contains a mandatory output file specification line,
and optional additional lines.  The Source Block contains a reference
to a source file, and may contain zero or more Placement Blocks, which
identify a particular cell from that file.  The specification must
contain at least one Source Block.

Indentation can be used in the specification file to highlight the
scoping.  The same logic applies in an argument list, but may be less
visible since all options appear in one line.

8.1.1  Header Block

The Header Block contains global directives.  This must be followed by
at least one Source Block, which specifies an input source.

    OutFile out_file_name
    (option: -o out_file_name)

      This line or option is mandatory, and provides the name of the
      file to be used for output.  This must appear before any Source
      Blocks.  The output file name must have a recognized extension
      that corresponds to the format to be used.  These are:

        CGX     .cgx
        CIF     .cif
        GDSII   .gds, .str, .strm, .stream
        OASIS   .oas

      Only these extensions are recognized, however CGX and GDSII
      allow an additional ".gz" which will imply compression.

      Basic defaults for the various output formats are as specified in
      variables that may be set in "-set" arguments.

    TopCell cellname
    (option: -t cellname)

      This optional line or option specifies that a new top-level cell
      is to be created in output.  At most one TopCell can be given. 
      This must appear before any Source Block.

      If a TopCell is given, a corresponding cell definition will be
      created in the output file, and all cells specified in Placement
      Blocks (the "placements") will be instantiated in the new cell. 
      Whether or not a TopCell is given, the placements will be
      streamed to the output file, meaning that the cell definitions
      needed to describe the cell and possibly its hierarchy will be
      added to the output file.  With a TopCell given, the placements
      will be instantiated in the new top cell in output.  Otherwise,
      there is no placement, and redundant Placement Blocks will be
      ignored.  The output file can end up with multiple top-level
      cells, which may be desirable when creating a library.

The Header can also contain any of the Source Block or Placement Block
directives below.  These will be used as defaults in all blocks that
follow, but can be overridden from within the blocks, or set,
modified, or reset between Source Blocks.

8.1.2  Source Blocks

The Source Blocks specify an input file, and provide directives that
are active when the source is read.  The Source Block may contain
Placement Blocks, which identify individual cells or cell hierarchies
to be read.

The same file might be used in more than one Source Block, if the
directives, such as cell name modification, are different in the two
blocks.

The Source Blocks start with the following keyword:

    Source filename
    (option: -i filename)

      This line or option represents the start of a Source Block for
      the given input file.  The file must be in one of the supported
      archive formats, and the format is recognized automatically, so
      there is no name suffix requirement as with the output file
      name.

      The absence of any Placement Blocks defined in the Source Block
      implies that all cells found in the file will be read.

The Source Blocks can be terminated with:

    EndSource
    (option: -i-)

      This optional keyword or option terminates the present Source
      Block.  Lines or text tokens that follow, up to another Source
      keyword or -i option, are taken in the context of the Header
      Block.  Thus, directives can be set, modified, or reset between
      Source Blocks, and will remain in force (in the Header Block
      context) until reset or modified between subsequent Source
      Blocks.  This keyword is optional, as it is implicit if another
      Source line or -i option is given.  It is required only if one
      wishes to change the directives in the Header context for
      subsequent Source Blocks.

Within the Source Block, one may find Placement Blocks, Source Block
directives, and Placement Block directives.

8.1.3  Source Block Directives

The Source Block directives can be given in the context of the Header
Block, in which case they serve as defaults for the Source Blocks that
follow.  They can also be given in a Source Block, in which case they
apply in that Source Block only, and override a similar directive
active from a definition in the Header Block context.  The term
"Header Block context" means that the definition appears before any
Source Block, or after an EndSource line (-i- option) but before the
next Source line (-i option).

The Source Block directives can not appear inside of Placement Blocks,
where they would have no meaning.  Thus, in a Source Block, Source
Block directives can appear before the Placement Blocks, or between
EndPlace lines (-c- option) and the next Place (-c option) or PlaceTop
line (-ctop option).  The directives that apply are those logically in
force at the end of the Source Block.  The Source Block directives
apply to the Source Block, and will have the same effect for all
contained Placement Blocks, regardless of ordering.

The following lines define Source Block directives:

    LayerList list_of_layer_names
    (option: -l list_of_layer_names)

      This saves a list of space-separated layer names or hex-encoded
      pseudo-names to be used with the layer filtering directives
      OnlyLayers (-n option) and SkipLayers (-k option).  This
      directive in itself does not alter output.  This list is implied
      when a list_of_layer_names is provided with these keywords.  In
      the command line, the list of layer names must be quoted if it
      contains more than one entry, but this is not required in a
      file.

    OnlyLayers [list_of_layer_names]
    (option: -n)

      When active, only the listed layers will be used in output,
      geometry on other layers will be skipped.  Arguments following
      this keyword will be used to set or reset the LayerList, and
      have the same interpretation as for that keyword.  If no
      arguments follow, the LayerList currently in scope will be used. 
      The -n command line token does not accept a list of layer names,
      unlike the corresponding keyword.  This must be separately
      specified with a -l option.

    NoOnlyLayers
    (option: -n-)

      Turn off restriction to layers in the LayerList, if the
      OnlyLayers directive (-n option) is in force.  The corresponding
      LayerList remains defined.

    SkipLayers [list_of_layer_names]
    (option: -k)

      When active, listed layers will not appear in output, geometry
      on layers not listed will appear in output.  Arguments following
      this keyword will be used to set or reset the LayerList, and
      have the same interpretation as for that keyword.  If no
      arguments follow, the LayerList currently in scope will be used. 
      The -k command line token does not accept a list of layer names,
      unlike the corresponding keyword.  This must be separately
      specified with a -l option.

    NoSkipLayers
    (option: -k-)

      Turn off layer skipping, if the SkipLayers directive (-k option)
      is currently in force.  The associated LayerList remains
      defined.

    LayerAliases name1=alias1 name2=alias2 ...
    (option: -a name1=alias1 name2=alias2 ...)

      This keyword provides a list a layer aliasing definitions to
      apply in output.  The layer names can be hex-encoded
      pseudo-names when applicable.  This is similar to the layer
      aliasing found in the Conversion panel and elsewhere in Xic.  In
      the command line, the list must be quoted if it contains more
      than one entry, but this is not required in a file.

    ConvertScale scale_factor
    (option: -cs scale_factor)

      This directive has effect only in the case where there are no
      Placement Blocks, and is ignored otherwise.  This will scale all
      coordinates read from the source by the given factor, which can
      be in the range 0.001 through 1000.0.  Thus, in output, the
      corresponding cell definitions will be scaled by this factor. 
      This is similar to the Scale Placement Block directive (-s
      option), but applies when there are no Placement Blocks and
      Placement Block directives are ignored.

    ToLower
    (option: -tlo)
      This sets a flag to indicate conversion of upper case cell names
      to lower case in output.  Mixed-case cell names are unaffected.

    NoToLower
    (option: -tlo-)

      Turn off lower-casing, if the ToLower directive (-tlo option) is
      currently in force.

    ToUpper
    (option: -tup)

      This sets a flag to indicate conversion of lower case cell names
      to upper case.  Mixed-case cell names are unaffected.

    NoToUpper
    (option: -tup-)

      Turn off upper-casing, if the ToUpper directive (-tup option) is
      currently in force.

    CellNamePrefix prefix_string
    (option: -p prefix_string)

      Cell name change prefix.  This operation occurs after case
      conversion.  The prefix_string is interpreted in the manner of
      the InCellNamePrefix variable.

    CellNameSuffix suffix_string
    (option: -u suffix_string)

      Cell name change suffix.  This operation occurs after case
      conversion.  The suffix_string is interpreted in the manner of
      the InCellNameSuffix variable.

8.1.4  Placement Blocks

Placement Blocks can appear only within Source Blocks.  Each Source
Block can have zero or more Placement Blocks.  If no Placement Blocks
are given, all cells in the source file are written to output, and
Placement Block directives that may be in force are ignored.

A Placement Block is used to indicate a specific cell within the
source file, which will be written to output.  The Placement Block
directives specify actions to take, for example whether to process
just this cell or its hierarchy, whether to use flattening and/or
windowing, and the placement transform if the cell is to be
instantiated in a given TopCell.

As cells are written to output, a table is maintained to prevent
writing duplicate cell definitions.  Each cell needed to represent the
cell hierarchies contained in the output file is written once only. 
When different versions of the same cell are needed, such as with
different scaling, the names of the cells are altered to avoid a name
clash.  This is accomplished by appending "$N", where N is an integer
which makes the new name unique, to the cell names.

A new Placement Block, which can appear only within a Source Block,
will begin with either of the following keywords or options:

    Place cellname [placement_name]
    (option: -c cellname)

      The cellname, which must name a cell in the source file, will be
      included in the output file.  If a TopCell was given, the cell
      will also be instantiated in the given top cell.  The
      placement_name, if given, will replace cellname in output.  In
      either case, any cell name alteration presently in force will be
      applied.  If a Placement Block matches a previous block except
      for the transformation parameters (Translate, Rotate, Magnify,
      Reflect), then if a TopCell was given, an instance will be added
      with the new transform, but the cell definitions are already in
      the output and will not be streamed.  Thus, in this case with no
      TopCell, there would be no addition to output.

      In a command line, the placement_name can not follow the
      cellname as in a file.  Rather, there is a special option token

        -ca placement_name

      that can appear within the Placement Block which specifies the
      name change.

    PlaceTop [placement_name]
    (option: -ctop)

      The PlaceTop line (-ctop option) is equivalent to a Place line
      (-c option), except that it will automatically select the first
      top-level cell found in the source.  It is equivalent to the
      Place line (-c option) with the name of this cell as the first
      (only) argument.  This is convenient when the top-level cell
      name is unknown.  Unlike the keyword, the -ctop option does not
      take a following placement_name, which must be given by a -ca
      option within the Placement Block.

A Placement Block can be terminated with:

    PlaceEnd
    (option: -c-)

      This optional keyword will end the current Placement Block. 
      Subsequent lines will be accepted in the scope of the containing
      Source Block.  This keyword is optional, as it is implicit if a
      Place or PlaceTop keyword (-c or -ctop option) is given.  It is
      useful if one needs to add, modify, or reset Placement Block
      directives in the Source Block scope, which will apply to
      subsequent Placement Blocks.

      A Placement Block may contain any of the Placement Block
      directives, which control how the cell is treated in output. 
      The transformations apply only when a TopCell was given in the
      Header Block, and control the location and orientation of the
      instantiation.

8.1.5  Placement Block Directives

The Placement Block directives can appear in the Header Block context,
the Source Block context, or within a Placement Block.  Thus, they can
appear virtually anywhere in the specification file or command line,
though the location alters the scope.

If given in the Header Block context, meaning that the directive
appears before the first Source Block, or after an EndSource line (-i-
option) but ahead of the next Source line (-i option), then the
directive will be active as a default in all Source Blocks that
follow, until the directive is changed or reset in the Header Block
context.

Similarly, if a Placement Block directive is given in a Source Block,
it will override a similar directive set in the Header Block scope,
and will apply to all Placement Blocks that follow within the Source
Block, until changed or reset in the context of the same Source Block. 
Being given in a Source Block, or in the context of a Source Block,
means that the directive appears before the first Place or PlaceTop
line (-c or -ctop option), or after an EndPlace line (-c- option) but
before the next Place or PlaceTop line or equivalent options.

If the Placement Block directive appears within a Placement Block, it
will override a similar directive set in the Source Block or Header
Block, and will apply to the current Placement Block only.

Placement Block directives are ignored when reading a source that
has no Placement Blocks.

The following directives define the transformation applied to an
instantiation of the cell in the TopCell.  These will be ignored
unless a TopCell was given.

    Translate x y
    (options: -x x -y y)

      Specify the translation coordinates.  If not given, the default
      is 0, 0.  Note that the keyword corresponds to two command-line
      options.

    Rotate angle
    (option: -ang angle)

      Specify a rotation angle, which must be a multiple of 45
      degrees.  If not given, the default is no rotation.

    Magnify magn
    (option: -m magn)

      Specify an instance magnification.  If not given, the default is
      1.0.  Values from .001 to 1000.0 are accepted.

    Reflect
    (option: -my)

      Apply a mirror-Y transformation (before rotation, if any).

    NoReflect
    (option: -my-)

      Turn off the mirror-Y transformation, if the Reflect directive
      (-my option) is currently in force.

The following directives initiate operations on the cell definition,
as it is written to output.  These are performed whether or not a
TopCell was defined.

    Scale scale_factor
    (option: -s scale_factor)

      The cells read from the source will have all coordinates
      multiplied by the scale factor, which can be in the range .001 -
      1000.0.  This is distinct from the Magnify factor, which applies
      only to the instance created in the TopCell, and will in effect
      multiply the scale factor.  When there are no Placement Blocks,
      and so Placement Block directives are ignored, the ConvertScale
      Source Block directive (-cs option) can be used to obtain the
      same effect.

    NoHier
    (option: -h)

      If given, only the specified cell is written to output, and not
      its complete hierarchy as is the normal case.  This can produce
      output files with unresolved subcell references, which must be
      satisfied by some means.

    NoNoHier
    (option: -h-)

      Turn off the no-hierarchy mode, if the NoHier directive (-h
      option) is currently in force.

    NoEmpties
    (option: -e)

      If given, empty subcells under the cell being read will not be
      written to output.  Layer filtering will often produce empty
      cells.

    NoNoEmpties
    (option: -e-)

      Turn off empty cell filtering, if the NoEmpties directive (-e
      option) is currently in force.

    Flatten
    (option: -f)

      If given, all geometry under the cell being read will be written
      as part of the cell being read, i.e., the cell hierarchy will be
      flattened.  The NoHier directive (-h option) is ignored if this
      is active.

    NoFlatten
    (option: -f-)

      Turn off flattening, if the Flatten directive (-f option) is
      currently in force.

    Window left bottom right top
    (option: -w left,bottom,right,top)

      If given, only the subcells (if NoHier is not active) and
      objects needed to describe the given area in the cell being
      placed will be written.  The coordinates apply to cellname after
      any scaling is applied, and are given in microns.  The four
      numbers can be separated by commas and/or white space.  In the
      command line, if white space is present between numbers, the
      four numbers must be quoted.  but this is not required in a
      file.

    Clip
    (option: -cl)

      If Window was given, this will cause geometry to be clipped to
      the window.

    NoClip
    (option: -cl-)

      Turn off clipping, if the Clip directive (-cl option) is
      currently in force.

