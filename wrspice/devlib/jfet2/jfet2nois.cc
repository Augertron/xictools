
/*========================================================================*
 *                                                                        *
 *  XICTOOLS Integrated Circuit Design System                             *
 *  Copyright (c) 1996 Whiteley Research Inc, all rights reserved.        *
 *                                                                        *
 *                                                                        *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      *
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *
 *   INFRINGEMENT.  IN NO EVENT SHALL STEPHEN R. WHITELEY BE LIABLE       *
 *   FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION      *
 *   OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN           *
 *   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN         *
 *   THE SOFTWARE.                                                        *
 *                                                                        *
 *========================================================================*
 *                                                                        *
 * Device Library                                                         *
 *                                                                        *
 *========================================================================*
 $Id: jfet2nois.cc,v 2.14 2015/08/08 01:51:01 stevew Exp $
 *========================================================================*/

/**********
based on jfetnoi.c
Copyright 1990 Regents of the University of California.  All rights reserved.
Author: 1987 Gary W. Ng

Modified to jfet2 for PS model definition ( Anthony E. Parker )
   Copyright 1994  Macquarie University, Sydney Australia.
**********/

#include <stdio.h>
#include "jfet2defs.h"
#include "noisdefs.h"

#define JFET2nextModel      next()
#define JFET2nextInstance   next()
#define JFET2instances      inst()
#define JFET2name GENname
#define MAX SPMAX
#define NOISEAN sNOISEAN
#define Nintegrate(a, b, c, d) (d)->integrate(a, b, c)
#define NstartFreq JOBac.fstart()

/*
 * JFET2noise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with JFET2's.  It starts with the model *firstModel and
 *    traverses all of its insts.  It then proceeds to any other models
 *    on the linked list.  The total output noise density generated by
 *    all of the JFET2's is summed with the variable "OnDens".
 */


int
JFET2dev::noise (int mode, int operation, sGENmodel *genmod, sCKT *ckt,
    sNdata *data, double *OnDens)
{
    sJFET2model *model, *firstModel = static_cast<sJFET2model*>(genmod);
    sJFET2instance *inst;

    char jfet2name[N_MXVLNTH];
    double tempOnoise;
    double tempInoise;
    double noizDens[JFET2NSRCS];
    double lnNdens[JFET2NSRCS];
//    int error;
    int i;

    /* define the names of the noise sources */

    static const char *JFET2nNames[JFET2NSRCS] = {       /* Note that we have to keep the order */
        "_rd",              /* noise due to rd */        /* consistent with the index definitions */
        "_rs",              /* noise due to rs */        /* in JFET2defs.h */
        "_id",              /* noise due to id */
        "_1overf",          /* flicker (1/f) noise */
        ""                  /* total transistor noise */
    };

    for (model=firstModel; model != NULL; model=model->JFET2nextModel) {
        for (inst=model->JFET2instances; inst != NULL; inst=inst->JFET2nextInstance) {
            switch (operation) {

            case N_OPEN:

                /* see if we have to to produce a summary report */
                /* if so, name all the noise generators */

                if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                    switch (mode) {

                    case N_DENS:
                        for (i=0; i < JFET2NSRCS; i++) {
                            (void)sprintf(jfet2name,"onoise_%s%s",(char*)inst->JFET2name,JFET2nNames[i]);


/*
data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots + 1)*sizeof(IFuid));
if (!data->namelist) return(E_NOMEM);
                (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,jfet2name,UID_OTHER,(GENERIC **)NULL);
*/
                                /* we've added one more plot */
                Realloc(&data->namelist, data->numPlots+1,
                    data->numPlots);
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, jfet2name, UID_OTHER);


                        }
                        break;

                    case INT_NOIZ:
                        for (i=0; i < JFET2NSRCS; i++) {
                            (void)sprintf(jfet2name,"onoise_total_%s%s",(char*)inst->JFET2name,JFET2nNames[i]);


/*
data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots + 1)*sizeof(IFuid));
if (!data->namelist) return(E_NOMEM);
                (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,jfet2name,UID_OTHER,(GENERIC **)NULL);
*/
                                /* we've added one more plot */
                Realloc(&data->namelist, data->numPlots+2,
                    data->numPlots);
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, jfet2name, UID_OTHER);


                            (void)sprintf(jfet2name,"inoise_total_%s%s",(char*)inst->JFET2name,JFET2nNames[i]);


/*
data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots + 1)*sizeof(IFuid));
if (!data->namelist) return(E_NOMEM);
                (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,jfet2name,UID_OTHER,(GENERIC **)NULL);
*/
                                /* we've added one more plot */
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, jfet2name, UID_OTHER);

                        }
                        break;
                    }
                }
                break;

            case N_CALC:
                switch (mode) {

                case N_DENS:
                    NevalSrc(&noizDens[JFET2RDNOIZ],&lnNdens[JFET2RDNOIZ],
                                 ckt,THERMNOISE,inst->JFET2drainPrimeNode,inst->JFET2drainNode,
                                 model->JFET2drainConduct * inst->JFET2area);

                    NevalSrc(&noizDens[JFET2RSNOIZ],&lnNdens[JFET2RSNOIZ],
                                 ckt,THERMNOISE,inst->JFET2sourcePrimeNode,
                                 inst->JFET2sourceNode,model->JFET2sourceConduct*inst->JFET2area);

                    NevalSrc(&noizDens[JFET2IDNOIZ],&lnNdens[JFET2IDNOIZ],
                                 ckt,THERMNOISE,inst->JFET2drainPrimeNode,
                                 inst->JFET2sourcePrimeNode,
                                 (2.0/3.0 * FABS(*(ckt->CKTstate0 + inst->JFET2gm))));

                    NevalSrc(&noizDens[JFET2FLNOIZ],(double*)NULL,ckt,
                                 N_GAIN,inst->JFET2drainPrimeNode,
                                 inst->JFET2sourcePrimeNode, (double)0.0);
                    noizDens[JFET2FLNOIZ] *= model->JFET2fNcoef * 
                                 exp(model->JFET2fNexp *
                                 log(MAX(FABS(*(ckt->CKTstate0 + inst->JFET2cd)),N_MINLOG))) /
                                 data->freq;
                    lnNdens[JFET2FLNOIZ] = 
                                 log(MAX(noizDens[JFET2FLNOIZ],N_MINLOG));

                    noizDens[JFET2TOTNOIZ] = noizDens[JFET2RDNOIZ] +
                                                     noizDens[JFET2RSNOIZ] +
                                                     noizDens[JFET2IDNOIZ] +
                                                     noizDens[JFET2FLNOIZ];
                    lnNdens[JFET2TOTNOIZ] = 
                                 log(MAX(noizDens[JFET2TOTNOIZ], N_MINLOG));

                    *OnDens += noizDens[JFET2TOTNOIZ];

                    if (data->delFreq == 0.0) { 

                        /* if we haven't done any previous integration, we need to */
                        /* initialize our "history" variables                      */

                        for (i=0; i < JFET2NSRCS; i++) {
                            inst->JFET2nVar[LNLSTDENS][i] = lnNdens[i];
                        }

                        /* clear out our integration variables if it's the first pass */

                        if (data->freq == ((NOISEAN*)ckt->CKTcurJob)->NstartFreq) {
                            for (i=0; i < JFET2NSRCS; i++) {
                                inst->JFET2nVar[OUTNOIZ][i] = 0.0;
                                inst->JFET2nVar[INNOIZ][i] = 0.0;
                            }
                        }
                    } else {   /* data->delFreq != 0.0 (we have to integrate) */
                        for (i=0; i < JFET2NSRCS; i++) {
                            if (i != JFET2TOTNOIZ) {
                                tempOnoise = Nintegrate(noizDens[i], lnNdens[i],
                                      inst->JFET2nVar[LNLSTDENS][i], data);
                                tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
                                      lnNdens[i] + data->lnGainInv,
                                      inst->JFET2nVar[LNLSTDENS][i] + data->lnGainInv,
                                      data);
                                inst->JFET2nVar[LNLSTDENS][i] = lnNdens[i];
                                data->outNoiz += tempOnoise;
                                data->inNoise += tempInoise;
                                if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                                    inst->JFET2nVar[OUTNOIZ][i] += tempOnoise;
                                    inst->JFET2nVar[OUTNOIZ][JFET2TOTNOIZ] += tempOnoise;
                                    inst->JFET2nVar[INNOIZ][i] += tempInoise;
                                    inst->JFET2nVar[INNOIZ][JFET2TOTNOIZ] += tempInoise;
                                }
                            }
                        }
                    }
                    if (data->prtSummary) {
                        for (i=0; i < JFET2NSRCS; i++) {     /* print a summary report */
                            data->outpVector[data->outNumber++] = noizDens[i];
                        }
                    }
                    break;

                case INT_NOIZ:        /* already calculated, just output */
                    if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                        for (i=0; i < JFET2NSRCS; i++) {
                            data->outpVector[data->outNumber++] = inst->JFET2nVar[OUTNOIZ][i];
                            data->outpVector[data->outNumber++] = inst->JFET2nVar[INNOIZ][i];
                        }
                    }    /* if */
                    break;
                }    /* switch (mode) */
                break;

            case N_CLOSE:
                return (OK);         /* do nothing, the main calling routine will close */
                break;               /* the plots */
            }    /* switch (operation) */
        }    /* for inst */
    }    /* for model */

return(OK);
}
            
